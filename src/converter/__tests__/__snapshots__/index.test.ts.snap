// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`build - Calendar: calendar.graphql 1`] = `
directive @extractFromObjectDisplayName on FIELD_DEFINITION

directive @recordType on OBJECT

"""The application's top-level scripting object."""
type Application {
  calendars(after: ID, first: Int, whose: Condition): CalendarConnection!
  documents(after: ID, first: Int, whose: Condition): DocumentConnection!

  """Is this the active application?"""
  frontmost: Boolean!

  """The name of the application."""
  name: String!

  """The version number of the application."""
  version: String!
  windows(after: ID, first: Int, whose: Condition): WindowConnection!
}

"""This class represents a attendee."""
type Attendee {
  """The first and last name of the attendee."""
  displayName: String!

  """e-mail of the attendee."""
  email: String!

  """The invitation status for the attendee."""
  participationStatus: ParticipationStatus!
}

type AttendeeConnection {
  byId(id: ID!): Attendee
  edges: [AttendeeEdge!]!
  pageInfo: PageInfo!
}

type AttendeeEdge {
  cursor: String!
  node: Attendee!
}

"""This class represents a calendar."""
type Calendar implements Node {
  """This is the calendar description."""
  description: String!
  events(after: ID, first: Int, whose: Condition): EventConnection!

  """An unique calendar key"""
  id: ID! @extractFromObjectDisplayName

  """This is the calendar title."""
  name: String!

  """This is the calendar title."""
  title: String!

  """This is the calendar title."""
  writable: Boolean!
}

type CalendarConnection implements Connection {
  byId(id: ID!): Calendar
  edges: [CalendarEdge!]!
  pageInfo: PageInfo!
}

type CalendarEdge implements Edge {
  cursor: String!
  node: Calendar!
}

interface CalendarInterface implements Node {
  """This is the calendar description."""
  description: String!
  events(after: ID, first: Int, whose: Condition): EventConnection!

  """An unique calendar key"""
  id: ID! @extractFromObjectDisplayName

  """This is the calendar title."""
  name: String!

  """This is the calendar title."""
  title: String!

  """This is the calendar title."""
  writable: Boolean!
}

input Condition {
  enabled: Boolean! = true
  field: String
  operands: [Condition!]
  operator: String! = "="
  value: String! = "true"
}

interface Connection {
  byId(id: ID!): Node
  edges: [Edge!]!
  pageInfo: PageInfo!
}

"""This class represents a message alarm."""
type DisplayAlarm {
  """An absolute alarm date."""
  triggerDate: String!

  """
  The interval in minutes between the event and the alarm: (positive for alarm that trigger after the event date or negative for alarms that trigger before).
  """
  triggerInterval: Int!
}

type DisplayAlarmConnection {
  byId(id: ID!): DisplayAlarm
  edges: [DisplayAlarmEdge!]!
  pageInfo: PageInfo!
}

type DisplayAlarmEdge {
  cursor: String!
  node: DisplayAlarm!
}

"""A document."""
type Document {
  """Has it been modified since the last save?"""
  modified: Boolean!

  """Its name."""
  name: String!
}

type DocumentConnection {
  byId(id: ID!): Document
  edges: [DocumentEdge!]!
  pageInfo: PageInfo!
}

type DocumentEdge {
  cursor: String!
  node: Document!
}

interface Edge {
  cursor: String!
  node: Node!
}

"""This class represents an event."""
type Event implements Node {
  """True if the event is an all-day event"""
  alldayEvent: Boolean!
  attendees(after: ID, first: Int, whose: Condition): AttendeeConnection!

  """The events notes."""
  description: String!
  displayAlarms(after: ID, first: Int, whose: Condition): DisplayAlarmConnection!

  """The event end date."""
  endDate: String!

  """The exception dates."""
  excludedDates: [String!]!

  """An unique event key."""
  id: ID! @extractFromObjectDisplayName

  """This is the event location."""
  location: String!
  mailAlarms(after: ID, first: Int, whose: Condition): MailAlarmConnection!
  openFileAlarms(after: ID, first: Int, whose: Condition): OpenFileAlarmConnection!

  """
  The iCalendar (RFC 2445) string describing the event recurrence, if defined
  """
  recurrence: String!

  """The event version."""
  sequence: Int!
  soundAlarms(after: ID, first: Int, whose: Condition): SoundAlarmConnection!

  """The event modification date."""
  stampDate: String!

  """The event start date."""
  startDate: String!

  """The event status."""
  status: EventStatus!

  """This is the event summary."""
  summary: String!

  """The URL associated to the event."""
  url: String!
}

type EventConnection implements Connection {
  byId(id: ID!): Event
  edges: [EventEdge!]!
  pageInfo: PageInfo!
}

type EventEdge implements Edge {
  cursor: String!
  node: Event!
}

interface EventInterface implements Node {
  """True if the event is an all-day event"""
  alldayEvent: Boolean!
  attendees(after: ID, first: Int, whose: Condition): AttendeeConnection!

  """The events notes."""
  description: String!
  displayAlarms(after: ID, first: Int, whose: Condition): DisplayAlarmConnection!

  """The event end date."""
  endDate: String!

  """The exception dates."""
  excludedDates: [String!]!

  """An unique event key."""
  id: ID! @extractFromObjectDisplayName

  """This is the event location."""
  location: String!
  mailAlarms(after: ID, first: Int, whose: Condition): MailAlarmConnection!
  openFileAlarms(after: ID, first: Int, whose: Condition): OpenFileAlarmConnection!

  """
  The iCalendar (RFC 2445) string describing the event recurrence, if defined
  """
  recurrence: String!

  """The event version."""
  sequence: Int!
  soundAlarms(after: ID, first: Int, whose: Condition): SoundAlarmConnection!

  """The event modification date."""
  stampDate: String!

  """The event start date."""
  startDate: String!

  """The event status."""
  status: EventStatus!

  """This is the event summary."""
  summary: String!

  """The URL associated to the event."""
  url: String!
}

enum EventStatus {
  """A cancelled event"""
  CANCELLED

  """A confirmed event"""
  CONFIRMED

  """An event without status"""
  NONE

  """A tentative event"""
  TENTATIVE
}

"""This class represents a mail alarm."""
type MailAlarm {
  """An absolute alarm date."""
  triggerDate: String!

  """
  The interval in minutes between the event and the alarm: (positive for alarm that trigger after the event date or negative for alarms that trigger before).
  """
  triggerInterval: Int!
}

type MailAlarmConnection {
  byId(id: ID!): MailAlarm
  edges: [MailAlarmEdge!]!
  pageInfo: PageInfo!
}

type MailAlarmEdge {
  cursor: String!
  node: MailAlarm!
}

interface Node {
  id: ID!
}

"""
This class represents an 'open file' alarm. Starting with OS X 10.14, it is not possible to create new open file alarms or view URLs for existing open file alarms. Trying to save or modify an open file alarm will result in a save error. Editing other aspects of events or reminders that have existing open file alarms is allowed as long as the alarm isn't modified.
"""
type OpenFileAlarm {
  """The (POSIX) path to be opened by the alarm"""
  filepath: String!

  """An absolute alarm date."""
  triggerDate: String!

  """
  The interval in minutes between the event and the alarm: (positive for alarm that trigger after the event date or negative for alarms that trigger before).
  """
  triggerInterval: Int!
}

type OpenFileAlarmConnection {
  byId(id: ID!): OpenFileAlarm
  edges: [OpenFileAlarmEdge!]!
  pageInfo: PageInfo!
}

type OpenFileAlarmEdge {
  cursor: String!
  node: OpenFileAlarm!
}

type PageInfo {
  endCursor: String!
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String!
}

enum ParticipationStatus {
  """Invitation has been accepted"""
  ACCEPTED

  """Invitation has been declined"""
  DECLINED

  """Invitation has been tentatively accepted"""
  TENTATIVE

  """No anwser yet"""
  UNKNOWN
}

type Query {
  application: Application!
}

"""This class represents a sound alarm."""
type SoundAlarm {
  """The (POSIX) path to the sound file to be used for the alarm"""
  soundFile: String!

  """The system sound name to be used for the alarm"""
  soundName: String!

  """An absolute alarm date."""
  triggerDate: String!

  """
  The interval in minutes between the event and the alarm: (positive for alarm that trigger after the event date or negative for alarms that trigger before).
  """
  triggerInterval: Int!
}

type SoundAlarmConnection {
  byId(id: ID!): SoundAlarm
  edges: [SoundAlarmEdge!]!
  pageInfo: PageInfo!
}

type SoundAlarmEdge {
  cursor: String!
  node: SoundAlarm!
}

"""A window."""
type Window implements Node {
  """Does the window have a close button?"""
  closeable: Boolean!

  """The document whose contents are displayed in the window."""
  document: Document!

  """The unique identifier of the window."""
  id: ID! @extractFromObjectDisplayName

  """The index of the window, ordered front to back."""
  index: Int!

  """Does the window have a minimize button?"""
  miniaturizable: Boolean!

  """Is the window minimized right now?"""
  miniaturized: Boolean!

  """The title of the window."""
  name: String!

  """Can the window be resized?"""
  resizable: Boolean!

  """Is the window visible right now?"""
  visible: Boolean!

  """Does the window have a zoom button?"""
  zoomable: Boolean!

  """Is the window zoomed right now?"""
  zoomed: Boolean!
}

type WindowConnection implements Connection {
  byId(id: ID!): Window
  edges: [WindowEdge!]!
  pageInfo: PageInfo!
}

type WindowEdge implements Edge {
  cursor: String!
  node: Window!
}

interface WindowInterface implements Node {
  """Does the window have a close button?"""
  closeable: Boolean!

  """The document whose contents are displayed in the window."""
  document: Document!

  """The unique identifier of the window."""
  id: ID! @extractFromObjectDisplayName

  """The index of the window, ordered front to back."""
  index: Int!

  """Does the window have a minimize button?"""
  miniaturizable: Boolean!

  """Is the window minimized right now?"""
  miniaturized: Boolean!

  """The title of the window."""
  name: String!

  """Can the window be resized?"""
  resizable: Boolean!

  """Is the window visible right now?"""
  visible: Boolean!

  """Does the window have a zoom button?"""
  zoomable: Boolean!

  """Is the window zoomed right now?"""
  zoomed: Boolean!
}
`;

exports[`build - Finder: finder.graphql 1`] = `
directive @extractFromObjectDisplayName on FIELD_DEFINITION

directive @recordType on OBJECT

"""An alias file (created with “Make Alias”)"""
type AliasFile implements FileInterface {
  """
  the version of the product (visible at the top of the “Get Info” window)
  """
  productVersion: String!

  """Is the file a stationery pad?"""
  stationery: Boolean!

  """
  the version of the file (visible at the bottom of the “Get Info” window)
  """
  version: String!
}

type AliasFileConnection {
  byId(id: ID!): AliasFile
  edges: [AliasFileEdge!]!
  pageInfo: PageInfo!
}

type AliasFileEdge {
  cursor: String!
  node: AliasFile!
}

"""The Finder"""
type Application {
  aliasFiles(after: ID, first: Int, whose: Condition): AliasFileConnection!
  applicationFiles(after: ID, first: Int, whose: Condition): ApplicationFileConnection!
  clippingWindows(after: ID, first: Int, whose: Condition): ClippingWindowConnection!
  clippings(after: ID, first: Int, whose: Condition): ClippingConnection!

  """the computer location (as in Go > Computer)"""
  computerContainer: ComputerObject!
  containers(after: ID, first: Int, whose: Condition): ContainerConnection!

  """the desktop"""
  desktop: DesktopObject!

  """the desktop picture of the main monitor"""
  desktopPicture: File!
  disks(after: ID, first: Int, whose: Condition): DiskConnection!
  documentFiles(after: ID, first: Int, whose: Condition): DocumentFileConnection!
  files(after: ID, first: Int, whose: Condition): FileConnection!

  """Various preferences that apply to the Finder as a whole"""
  finderPreferences: Preferences!
  finderWindows(after: ID, first: Int, whose: Condition): FinderWindowConnection!
  folders(after: ID, first: Int, whose: Condition): FolderConnection!

  """Is the Finder the frontmost process?"""
  frontmost: Boolean!

  """the home directory"""
  home: Folder!
  internetLocationFiles(after: ID, first: Int, whose: Condition): InternetLocationFileConnection!
  items(after: ID, first: Int, whose: Condition): ItemConnection!

  """the Finder’s name"""
  name: String!
  packages(after: ID, first: Int, whose: Condition): PackageConnection!

  """the version of the System software running on this computer"""
  productVersion: String!

  """the startup disk"""
  startupDisk: Disk!

  """the trash"""
  trash: TrashObject!

  """the version of the Finder"""
  version: String!

  """Is the Finder’s layer visible?"""
  visible: Boolean!
  windows(after: ID, first: Int, whose: Condition): WindowConnection!
}

"""An application's file on disk"""
type ApplicationFile implements FileInterface & Node {
  """
  Is the application high-level event aware? (OBSOLETE: always returns true)
  """
  acceptsHighLevelEvents: Boolean!

  """
  Does the process have a scripting terminology, i.e., can it be scripted?
  """
  hasScriptingTerminology: Boolean!

  """the bundle identifier or creator type of the application"""
  id: ID! @extractFromObjectDisplayName

  """
  (AVAILABLE IN 10.1 TO 10.4) the smallest memory size with which the application can be launched
  """
  minimumSize: Int!

  """
  (AVAILABLE IN 10.1 TO 10.4) Should the application launch in the Classic environment?
  """
  opensInClassic: Boolean!

  """
  (AVAILABLE IN 10.1 TO 10.4) the memory size with which the application will be launched
  """
  preferredSize: Int!

  """
  the version of the product (visible at the top of the “Get Info” window)
  """
  productVersion: String!

  """Is the file a stationery pad?"""
  stationery: Boolean!

  """
  (AVAILABLE IN 10.1 TO 10.4) the memory size with which the developer recommends the application be launched
  """
  suggestedSize: Int!

  """
  the version of the file (visible at the bottom of the “Get Info” window)
  """
  version: String!
}

type ApplicationFileConnection implements Connection {
  byId(id: ID!): ApplicationFile
  edges: [ApplicationFileEdge!]!
  pageInfo: PageInfo!
}

type ApplicationFileEdge implements Edge {
  cursor: String!
  node: ApplicationFile!
}

interface ApplicationFileInterface implements Node {
  """
  Is the application high-level event aware? (OBSOLETE: always returns true)
  """
  acceptsHighLevelEvents: Boolean!

  """
  Does the process have a scripting terminology, i.e., can it be scripted?
  """
  hasScriptingTerminology: Boolean!

  """the bundle identifier or creator type of the application"""
  id: ID! @extractFromObjectDisplayName

  """
  (AVAILABLE IN 10.1 TO 10.4) the smallest memory size with which the application can be launched
  """
  minimumSize: Int!

  """
  (AVAILABLE IN 10.1 TO 10.4) Should the application launch in the Classic environment?
  """
  opensInClassic: Boolean!

  """
  (AVAILABLE IN 10.1 TO 10.4) the memory size with which the application will be launched
  """
  preferredSize: Int!

  """
  (AVAILABLE IN 10.1 TO 10.4) the memory size with which the developer recommends the application be launched
  """
  suggestedSize: Int!
}

"""A clipping"""
type Clipping implements FileInterface {
  """
  the version of the product (visible at the top of the “Get Info” window)
  """
  productVersion: String!

  """Is the file a stationery pad?"""
  stationery: Boolean!

  """
  the version of the file (visible at the bottom of the “Get Info” window)
  """
  version: String!
}

type ClippingConnection {
  byId(id: ID!): Clipping
  edges: [ClippingEdge!]!
  pageInfo: PageInfo!
}

type ClippingEdge {
  cursor: String!
  node: Clipping!
}

"""The window containing a clipping"""
type ClippingWindow implements Node & WindowInterface {
  """Does the window have a close box?"""
  closeable: Boolean!

  """Is the window collapsed"""
  collapsed: Boolean!

  """Does the window have a title bar?"""
  floating: Boolean!

  """the unique id for this window"""
  id: ID! @extractFromObjectDisplayName

  """the number of the window in the front-to-back layer ordering"""
  index: Int!

  """Is the window modal?"""
  modal: Boolean!

  """the name of the window"""
  name: String!

  """Is the window resizable?"""
  resizable: Boolean!

  """Does the window have a title bar?"""
  titled: Boolean!

  """Is the window visible (always true for open Finder windows)?"""
  visible: Boolean!

  """Is the window zoomable?"""
  zoomable: Boolean!

  """Is the window zoomed?"""
  zoomed: Boolean!
}

type ClippingWindowConnection implements Connection {
  byId(id: ID!): ClippingWindow
  edges: [ClippingWindowEdge!]!
  pageInfo: PageInfo!
}

type ClippingWindowEdge implements Edge {
  cursor: String!
  node: ClippingWindow!
}

"""a column of a list view"""
type Column {
  """the index in the front-to-back ordering within its container"""
  index: Int!

  """the maximum allowed width of this column"""
  maximumWidth: Int!

  """the minimum allowed width of this column"""
  minimumWidth: Int!

  """the column name"""
  name: Elsv!

  """The direction in which the window is sorted"""
  sortDirection: Sodr!

  """is this column visible"""
  visible: Boolean!

  """the width of this column"""
  width: Int!
}

type ColumnConnection {
  byId(id: ID!): Column
  edges: [ColumnEdge!]!
  pageInfo: PageInfo!
}

type ColumnEdge {
  cursor: String!
  node: Column!
}

"""the column view options"""
type ColumnViewOptions {
  """discloses the preview pane of the preview column in column view"""
  disclosesPreviewPane: Boolean!

  """displays an icon next to the label in column view"""
  showsIcon: Boolean!

  """displays a preview of the item in column view"""
  showsIconPreview: Boolean!

  """displays the preview column in column view"""
  showsPreviewColumn: Boolean!

  """the size of the text displayed in the column view"""
  textSize: Int!
}

"""the Computer location (as in Go > Computer)"""
type ComputerObject implements ItemInterface {
  """the comment of the item, displayed in the “Get Info” window"""
  comment: String!

  """the date on which the item was created"""
  creationDate: String!

  """a description of the item"""
  description: String!

  """the user-visible name of the item"""
  displayedName: String!
  everyonesPrivileges: Priv!

  """Is the item's extension hidden from the user?"""
  extensionHidden: Boolean!

  """the user or group that has special access to the container"""
  group: String!
  groupPrivileges: Priv!

  """the index in the front-to-back ordering within its container"""
  index: Int!

  """the kind of the item"""
  kind: String!

  """the label of the item"""
  labelIndex: Int!

  """Is the file locked?"""
  locked: Boolean!

  """the date on which the item was last modified"""
  modificationDate: String!

  """the name of the item"""
  name: String!

  """the name extension of the item (such as “txt”)"""
  nameExtension: String!

  """the user that owns the container"""
  owner: String!
  ownerPrivileges: Priv!

  """the URL of the item"""
  url: String!
}

input Condition {
  enabled: Boolean! = true
  field: String
  operands: [Condition!]
  operator: String! = "="
  value: String! = "true"
}

interface Connection {
  byId(id: ID!): Node
  edges: [Edge!]!
  pageInfo: PageInfo!
}

"""An item that contains other items"""
type Container implements ContainerInterface & ItemInterface {
  aliasFiles(after: ID, first: Int, whose: Condition): AliasFileConnection!
  applicationFiles(after: ID, first: Int, whose: Condition): ApplicationFileConnection!
  clippings(after: ID, first: Int, whose: Condition): ClippingConnection!

  """the comment of the item, displayed in the “Get Info” window"""
  comment: String!

  """
  (NOT AVAILABLE YET) Are the container and all of its children opened as outlines? (can only be set for containers viewed as lists)
  """
  completelyExpanded: Boolean!
  containers(after: ID, first: Int, whose: Condition): ContainerConnection!

  """the date on which the item was created"""
  creationDate: String!

  """a description of the item"""
  description: String!

  """the user-visible name of the item"""
  displayedName: String!
  documentFiles(after: ID, first: Int, whose: Condition): DocumentFileConnection!
  everyonesPrivileges: Priv!

  """
  (NOT AVAILABLE YET) Is the container capable of being expanded as an outline?
  """
  expandable: Boolean!

  """
  (NOT AVAILABLE YET) Is the container opened as an outline? (can only be set for containers viewed as lists)
  """
  expanded: Boolean!

  """Is the item's extension hidden from the user?"""
  extensionHidden: Boolean!
  files(after: ID, first: Int, whose: Condition): FileConnection!
  folders(after: ID, first: Int, whose: Condition): FolderConnection!

  """the user or group that has special access to the container"""
  group: String!
  groupPrivileges: Priv!

  """the index in the front-to-back ordering within its container"""
  index: Int!
  internetLocationFiles(after: ID, first: Int, whose: Condition): InternetLocationFileConnection!
  items(after: ID, first: Int, whose: Condition): ItemConnection!

  """the kind of the item"""
  kind: String!

  """the label of the item"""
  labelIndex: Int!

  """Is the file locked?"""
  locked: Boolean!

  """the date on which the item was last modified"""
  modificationDate: String!

  """the name of the item"""
  name: String!

  """the name extension of the item (such as “txt”)"""
  nameExtension: String!

  """the user that owns the container"""
  owner: String!
  ownerPrivileges: Priv!
  packages(after: ID, first: Int, whose: Condition): PackageConnection!

  """the URL of the item"""
  url: String!
}

type ContainerConnection {
  byId(id: ID!): ContainerInterface
  edges: [ContainerEdge!]!
  pageInfo: PageInfo!
}

type ContainerEdge {
  cursor: String!
  node: ContainerInterface!
}

interface ContainerInterface {
  aliasFiles(after: ID, first: Int, whose: Condition): AliasFileConnection!
  applicationFiles(after: ID, first: Int, whose: Condition): ApplicationFileConnection!
  clippings(after: ID, first: Int, whose: Condition): ClippingConnection!

  """
  (NOT AVAILABLE YET) Are the container and all of its children opened as outlines? (can only be set for containers viewed as lists)
  """
  completelyExpanded: Boolean!
  containers(after: ID, first: Int, whose: Condition): ContainerConnection!
  documentFiles(after: ID, first: Int, whose: Condition): DocumentFileConnection!

  """
  (NOT AVAILABLE YET) Is the container capable of being expanded as an outline?
  """
  expandable: Boolean!

  """
  (NOT AVAILABLE YET) Is the container opened as an outline? (can only be set for containers viewed as lists)
  """
  expanded: Boolean!
  files(after: ID, first: Int, whose: Condition): FileConnection!
  folders(after: ID, first: Int, whose: Condition): FolderConnection!
  internetLocationFiles(after: ID, first: Int, whose: Condition): InternetLocationFileConnection!
  items(after: ID, first: Int, whose: Condition): ItemConnection!
  packages(after: ID, first: Int, whose: Condition): PackageConnection!
}

"""Desktop-object is the class of the “desktop” object"""
type DesktopObject implements ContainerInterface {
  aliasFiles(after: ID, first: Int, whose: Condition): AliasFileConnection!
  applicationFiles(after: ID, first: Int, whose: Condition): ApplicationFileConnection!
  clippings(after: ID, first: Int, whose: Condition): ClippingConnection!

  """
  (NOT AVAILABLE YET) Are the container and all of its children opened as outlines? (can only be set for containers viewed as lists)
  """
  completelyExpanded: Boolean!
  containers(after: ID, first: Int, whose: Condition): ContainerConnection!
  disks(after: ID, first: Int, whose: Condition): DiskConnection!
  documentFiles(after: ID, first: Int, whose: Condition): DocumentFileConnection!

  """
  (NOT AVAILABLE YET) Is the container capable of being expanded as an outline?
  """
  expandable: Boolean!

  """
  (NOT AVAILABLE YET) Is the container opened as an outline? (can only be set for containers viewed as lists)
  """
  expanded: Boolean!
  files(after: ID, first: Int, whose: Condition): FileConnection!
  folders(after: ID, first: Int, whose: Condition): FolderConnection!
  internetLocationFiles(after: ID, first: Int, whose: Condition): InternetLocationFileConnection!
  items(after: ID, first: Int, whose: Condition): ItemConnection!
  packages(after: ID, first: Int, whose: Condition): PackageConnection!
}

"""the desktop window"""
type DesktopWindow implements FinderWindowInterface {
  """the column view options for the container window"""
  columnViewOptions: ColumnViewOptions!

  """the current view for the container window"""
  currentView: Ecvw!

  """the icon view options for the container window"""
  iconViewOptions: IconViewOptions!

  """the list view options for the container window"""
  listViewOptions: ListViewOptions!

  """Is the window's path bar visible?"""
  pathbarVisible: Boolean!

  """the width of the sidebar for the container window"""
  sidebarWidth: Int!

  """Is the window's status bar visible?"""
  statusbarVisible: Boolean!

  """Is the window's toolbar visible?"""
  toolbarVisible: Boolean!
}

"""A disk"""
type Disk implements ContainerInterface & Node {
  aliasFiles(after: ID, first: Int, whose: Condition): AliasFileConnection!
  applicationFiles(after: ID, first: Int, whose: Condition): ApplicationFileConnection!
  clippings(after: ID, first: Int, whose: Condition): ClippingConnection!

  """
  (NOT AVAILABLE YET) Are the container and all of its children opened as outlines? (can only be set for containers viewed as lists)
  """
  completelyExpanded: Boolean!
  containers(after: ID, first: Int, whose: Condition): ContainerConnection!
  documentFiles(after: ID, first: Int, whose: Condition): DocumentFileConnection!

  """Can the media be ejected (floppies, CDs, and so on)?"""
  ejectable: Boolean!

  """
  (NOT AVAILABLE YET) Is the container capable of being expanded as an outline?
  """
  expandable: Boolean!

  """
  (NOT AVAILABLE YET) Is the container opened as an outline? (can only be set for containers viewed as lists)
  """
  expanded: Boolean!
  files(after: ID, first: Int, whose: Condition): FileConnection!
  folders(after: ID, first: Int, whose: Condition): FolderConnection!

  """the filesystem format of this disk"""
  format: Edfm!

  """
  the unique id for this disk (unchanged while disk remains connected and Finder remains running)
  """
  id: ID! @extractFromObjectDisplayName

  """Ignore permissions on this disk?"""
  ignorePrivileges: Boolean!
  internetLocationFiles(after: ID, first: Int, whose: Condition): InternetLocationFileConnection!
  items(after: ID, first: Int, whose: Condition): ItemConnection!

  """Does this disk do file system journaling?"""
  journalingEnabled: Boolean!

  """Is the media a local volume (as opposed to a file server)?"""
  localVolume: Boolean!
  packages(after: ID, first: Int, whose: Condition): PackageConnection!

  """Is this disk the boot disk?"""
  startup: Boolean!
}

type DiskConnection implements Connection {
  byId(id: ID!): Disk
  edges: [DiskEdge!]!
  pageInfo: PageInfo!
}

type DiskEdge implements Edge {
  cursor: String!
  node: Disk!
}

interface DiskInterface implements Node {
  aliasFiles(after: ID, first: Int, whose: Condition): AliasFileConnection!
  applicationFiles(after: ID, first: Int, whose: Condition): ApplicationFileConnection!
  clippings(after: ID, first: Int, whose: Condition): ClippingConnection!
  containers(after: ID, first: Int, whose: Condition): ContainerConnection!
  documentFiles(after: ID, first: Int, whose: Condition): DocumentFileConnection!

  """Can the media be ejected (floppies, CDs, and so on)?"""
  ejectable: Boolean!
  files(after: ID, first: Int, whose: Condition): FileConnection!
  folders(after: ID, first: Int, whose: Condition): FolderConnection!

  """the filesystem format of this disk"""
  format: Edfm!

  """
  the unique id for this disk (unchanged while disk remains connected and Finder remains running)
  """
  id: ID! @extractFromObjectDisplayName

  """Ignore permissions on this disk?"""
  ignorePrivileges: Boolean!
  internetLocationFiles(after: ID, first: Int, whose: Condition): InternetLocationFileConnection!
  items(after: ID, first: Int, whose: Condition): ItemConnection!

  """Does this disk do file system journaling?"""
  journalingEnabled: Boolean!

  """Is the media a local volume (as opposed to a file server)?"""
  localVolume: Boolean!
  packages(after: ID, first: Int, whose: Condition): PackageConnection!

  """Is this disk the boot disk?"""
  startup: Boolean!
}

"""A document file"""
type DocumentFile implements FileInterface {
  """
  the version of the product (visible at the top of the “Get Info” window)
  """
  productVersion: String!

  """Is the file a stationery pad?"""
  stationery: Boolean!

  """
  the version of the file (visible at the bottom of the “Get Info” window)
  """
  version: String!
}

type DocumentFileConnection {
  byId(id: ID!): DocumentFile
  edges: [DocumentFileEdge!]!
  pageInfo: PageInfo!
}

type DocumentFileEdge {
  cursor: String!
  node: DocumentFile!
}

enum Earr {
  ARRANGED_BY_CREATION_DATE
  ARRANGED_BY_KIND
  ARRANGED_BY_LABEL
  ARRANGED_BY_MODIFICATION_DATE
  ARRANGED_BY_NAME
  ARRANGED_BY_SIZE
  NOT_ARRANGED
  SNAP_TO_GRID
}

enum Ecvw {
  COLUMN_VIEW
  FLOW_VIEW
  GROUP_VIEW
  ICON_VIEW
  LIST_VIEW
}

enum Edfm {
  APFS_FORMAT
  APPLESHARE_FORMAT
  APPLE_PHOTO_FORMAT
  AUDIO_FORMAT
  EXFAT_FORMAT
  FTP_FORMAT
  HIGH_SIERRA_FORMAT
  ISO_9660_FORMAT
  MAC_OS_EXTENDED_FORMAT
  MAC_OS_FORMAT
  MSDOS_FORMAT
  NFS_FORMAT
  NTFS_FORMAT
  PACKET_WRITTEN_UDF_FORMAT
  PRODOS_FORMAT
  QUICKTAKE_FORMAT
  SMB_FORMAT
  UDF_FORMAT
  UFS_FORMAT
  UNKNOWN_FORMAT
  WEBDAV_FORMAT
  XSAN_FORMAT
}

interface Edge {
  cursor: String!
  node: Node!
}

enum Elsv {
  COMMENT_COLUMN
  CREATION_DATE_COLUMN
  KIND_COLUMN
  LABEL_COLUMN
  MODIFICATION_DATE_COLUMN
  NAME_COLUMN
  SIZE_COLUMN
  VERSION_COLUMN
}

enum Epos {
  BOTTOM
  RIGHT
}

"""A file"""
type File implements FileInterface & ItemInterface {
  """the comment of the item, displayed in the “Get Info” window"""
  comment: String!

  """the date on which the item was created"""
  creationDate: String!

  """a description of the item"""
  description: String!

  """the user-visible name of the item"""
  displayedName: String!
  everyonesPrivileges: Priv!

  """Is the item's extension hidden from the user?"""
  extensionHidden: Boolean!

  """the user or group that has special access to the container"""
  group: String!
  groupPrivileges: Priv!

  """the index in the front-to-back ordering within its container"""
  index: Int!

  """the kind of the item"""
  kind: String!

  """the label of the item"""
  labelIndex: Int!

  """Is the file locked?"""
  locked: Boolean!

  """the date on which the item was last modified"""
  modificationDate: String!

  """the name of the item"""
  name: String!

  """the name extension of the item (such as “txt”)"""
  nameExtension: String!

  """the user that owns the container"""
  owner: String!
  ownerPrivileges: Priv!

  """
  the version of the product (visible at the top of the “Get Info” window)
  """
  productVersion: String!

  """Is the file a stationery pad?"""
  stationery: Boolean!

  """the URL of the item"""
  url: String!

  """
  the version of the file (visible at the bottom of the “Get Info” window)
  """
  version: String!
}

type FileConnection {
  byId(id: ID!): FileInterface
  edges: [FileEdge!]!
  pageInfo: PageInfo!
}

type FileEdge {
  cursor: String!
  node: FileInterface!
}

interface FileInterface {
  """
  the version of the product (visible at the top of the “Get Info” window)
  """
  productVersion: String!

  """Is the file a stationery pad?"""
  stationery: Boolean!

  """
  the version of the file (visible at the bottom of the “Get Info” window)
  """
  version: String!
}

"""A file viewer window"""
type FinderWindow implements FinderWindowInterface & Node & WindowInterface {
  """Does the window have a close box?"""
  closeable: Boolean!

  """Is the window collapsed"""
  collapsed: Boolean!

  """the column view options for the container window"""
  columnViewOptions: ColumnViewOptions!

  """the current view for the container window"""
  currentView: Ecvw!

  """Does the window have a title bar?"""
  floating: Boolean!

  """the icon view options for the container window"""
  iconViewOptions: IconViewOptions!

  """the unique id for this window"""
  id: ID! @extractFromObjectDisplayName

  """the number of the window in the front-to-back layer ordering"""
  index: Int!

  """the list view options for the container window"""
  listViewOptions: ListViewOptions!

  """Is the window modal?"""
  modal: Boolean!

  """the name of the window"""
  name: String!

  """Is the window's path bar visible?"""
  pathbarVisible: Boolean!

  """Is the window resizable?"""
  resizable: Boolean!

  """the width of the sidebar for the container window"""
  sidebarWidth: Int!

  """Is the window's status bar visible?"""
  statusbarVisible: Boolean!

  """Does the window have a title bar?"""
  titled: Boolean!

  """Is the window's toolbar visible?"""
  toolbarVisible: Boolean!

  """Is the window visible (always true for open Finder windows)?"""
  visible: Boolean!

  """Is the window zoomable?"""
  zoomable: Boolean!

  """Is the window zoomed?"""
  zoomed: Boolean!
}

type FinderWindowConnection {
  byId(id: ID!): FinderWindowInterface
  edges: [FinderWindowEdge!]!
  pageInfo: PageInfo!
}

type FinderWindowEdge {
  cursor: String!
  node: FinderWindowInterface!
}

interface FinderWindowInterface {
  """the column view options for the container window"""
  columnViewOptions: ColumnViewOptions!

  """the current view for the container window"""
  currentView: Ecvw!

  """the icon view options for the container window"""
  iconViewOptions: IconViewOptions!

  """the list view options for the container window"""
  listViewOptions: ListViewOptions!

  """Is the window's path bar visible?"""
  pathbarVisible: Boolean!

  """the width of the sidebar for the container window"""
  sidebarWidth: Int!

  """Is the window's status bar visible?"""
  statusbarVisible: Boolean!

  """Is the window's toolbar visible?"""
  toolbarVisible: Boolean!
}

"""A folder"""
type Folder implements ContainerInterface {
  aliasFiles(after: ID, first: Int, whose: Condition): AliasFileConnection!
  applicationFiles(after: ID, first: Int, whose: Condition): ApplicationFileConnection!
  clippings(after: ID, first: Int, whose: Condition): ClippingConnection!

  """
  (NOT AVAILABLE YET) Are the container and all of its children opened as outlines? (can only be set for containers viewed as lists)
  """
  completelyExpanded: Boolean!
  containers(after: ID, first: Int, whose: Condition): ContainerConnection!
  documentFiles(after: ID, first: Int, whose: Condition): DocumentFileConnection!

  """
  (NOT AVAILABLE YET) Is the container capable of being expanded as an outline?
  """
  expandable: Boolean!

  """
  (NOT AVAILABLE YET) Is the container opened as an outline? (can only be set for containers viewed as lists)
  """
  expanded: Boolean!
  files(after: ID, first: Int, whose: Condition): FileConnection!
  folders(after: ID, first: Int, whose: Condition): FolderConnection!
  internetLocationFiles(after: ID, first: Int, whose: Condition): InternetLocationFileConnection!
  items(after: ID, first: Int, whose: Condition): ItemConnection!
  packages(after: ID, first: Int, whose: Condition): PackageConnection!
}

type FolderConnection {
  byId(id: ID!): Folder
  edges: [FolderEdge!]!
  pageInfo: PageInfo!
}

type FolderEdge {
  cursor: String!
  node: Folder!
}

"""the icon view options"""
type IconViewOptions {
  """the property by which to keep icons arranged"""
  arrangement: Earr!

  """the background picture of the icon view"""
  backgroundPicture: File!

  """the size of icons displayed in the icon view"""
  iconSize: Int!

  """the location of the label in reference to the icon"""
  labelPosition: Epos!

  """displays a preview of the item in icon view"""
  showsIconPreview: Boolean!

  """additional info about an item displayed in icon view"""
  showsItemInfo: Boolean!

  """the size of the text displayed in the icon view"""
  textSize: Int!
}

"""An inspector window (opened by “Show Info”)"""
type InformationWindow implements Node & WindowInterface {
  """Does the window have a close box?"""
  closeable: Boolean!

  """Is the window collapsed"""
  collapsed: Boolean!

  """the current panel in the information window"""
  currentPanel: Ipnl!

  """Does the window have a title bar?"""
  floating: Boolean!

  """the unique id for this window"""
  id: ID! @extractFromObjectDisplayName

  """the number of the window in the front-to-back layer ordering"""
  index: Int!

  """Is the window modal?"""
  modal: Boolean!

  """the name of the window"""
  name: String!

  """Is the window resizable?"""
  resizable: Boolean!

  """Does the window have a title bar?"""
  titled: Boolean!

  """Is the window visible (always true for open Finder windows)?"""
  visible: Boolean!

  """Is the window zoomable?"""
  zoomable: Boolean!

  """Is the window zoomed?"""
  zoomed: Boolean!
}

type InformationWindowConnection implements Connection {
  byId(id: ID!): InformationWindow
  edges: [InformationWindowEdge!]!
  pageInfo: PageInfo!
}

type InformationWindowEdge implements Edge {
  cursor: String!
  node: InformationWindow!
}

"""A file containing an internet location"""
type InternetLocationFile implements FileInterface {
  """the internet location"""
  location: String!

  """
  the version of the product (visible at the top of the “Get Info” window)
  """
  productVersion: String!

  """Is the file a stationery pad?"""
  stationery: Boolean!

  """
  the version of the file (visible at the bottom of the “Get Info” window)
  """
  version: String!
}

type InternetLocationFileConnection {
  byId(id: ID!): InternetLocationFile
  edges: [InternetLocationFileEdge!]!
  pageInfo: PageInfo!
}

type InternetLocationFileEdge {
  cursor: String!
  node: InternetLocationFile!
}

enum Ipnl {
  APPLICATION_PANEL
  BURNING_PANEL
  COMMENTS_PANEL
  CONTENT_INDEX_PANEL
  GENERAL_INFORMATION_PANEL
  LANGUAGES_PANEL
  MEMORY_PANEL
  MORE_INFO_PANEL
  NAME__AND__EXTENSION_PANEL
  PLUGINS_PANEL
  PREVIEW_PANEL
  SHARING_PANEL
  SIMPLE_HEADER_PANEL
}

"""An item"""
type Item implements ItemInterface {
  """the comment of the item, displayed in the “Get Info” window"""
  comment: String!

  """the date on which the item was created"""
  creationDate: String!

  """a description of the item"""
  description: String!

  """the user-visible name of the item"""
  displayedName: String!
  everyonesPrivileges: Priv!

  """Is the item's extension hidden from the user?"""
  extensionHidden: Boolean!

  """the user or group that has special access to the container"""
  group: String!
  groupPrivileges: Priv!

  """the index in the front-to-back ordering within its container"""
  index: Int!

  """the kind of the item"""
  kind: String!

  """the label of the item"""
  labelIndex: Int!

  """Is the file locked?"""
  locked: Boolean!

  """the date on which the item was last modified"""
  modificationDate: String!

  """the name of the item"""
  name: String!

  """the name extension of the item (such as “txt”)"""
  nameExtension: String!

  """the user that owns the container"""
  owner: String!
  ownerPrivileges: Priv!

  """the URL of the item"""
  url: String!
}

type ItemConnection {
  byId(id: ID!): ItemInterface
  edges: [ItemEdge!]!
  pageInfo: PageInfo!
}

type ItemEdge {
  cursor: String!
  node: ItemInterface!
}

interface ItemInterface {
  """the comment of the item, displayed in the “Get Info” window"""
  comment: String!

  """the date on which the item was created"""
  creationDate: String!

  """a description of the item"""
  description: String!

  """the user-visible name of the item"""
  displayedName: String!
  everyonesPrivileges: Priv!

  """Is the item's extension hidden from the user?"""
  extensionHidden: Boolean!

  """the user or group that has special access to the container"""
  group: String!
  groupPrivileges: Priv!

  """the index in the front-to-back ordering within its container"""
  index: Int!

  """the kind of the item"""
  kind: String!

  """the label of the item"""
  labelIndex: Int!

  """Is the file locked?"""
  locked: Boolean!

  """the date on which the item was last modified"""
  modificationDate: String!

  """the name of the item"""
  name: String!

  """the name extension of the item (such as “txt”)"""
  nameExtension: String!

  """the user that owns the container"""
  owner: String!
  ownerPrivileges: Priv!

  """the URL of the item"""
  url: String!
}

"""the list view options"""
type ListViewOptions {
  """Are folder sizes calculated and displayed in the window?"""
  calculatesFolderSizes: Boolean!
  columns(after: ID, first: Int, whose: Condition): ColumnConnection!

  """the size of icons displayed in the list view"""
  iconSize: Lvic!

  """displays a preview of the item in list view"""
  showsIconPreview: Boolean!

  """the column that the list view is sorted on"""
  sortColumn: Column!

  """the size of the text displayed in the list view"""
  textSize: Int!

  """Are relative dates (e.g., today, yesterday) shown in the list view?"""
  usesRelativeDates: Boolean!
}

enum Lvic {
  LARGE_ICON
  SMALL_ICON
}

interface Node {
  id: ID!
}

"""A package"""
type Package implements ItemInterface {
  """the comment of the item, displayed in the “Get Info” window"""
  comment: String!

  """the date on which the item was created"""
  creationDate: String!

  """a description of the item"""
  description: String!

  """the user-visible name of the item"""
  displayedName: String!
  everyonesPrivileges: Priv!

  """Is the item's extension hidden from the user?"""
  extensionHidden: Boolean!

  """the user or group that has special access to the container"""
  group: String!
  groupPrivileges: Priv!

  """the index in the front-to-back ordering within its container"""
  index: Int!

  """the kind of the item"""
  kind: String!

  """the label of the item"""
  labelIndex: Int!

  """Is the file locked?"""
  locked: Boolean!

  """the date on which the item was last modified"""
  modificationDate: String!

  """the name of the item"""
  name: String!

  """the name extension of the item (such as “txt”)"""
  nameExtension: String!

  """the user that owns the container"""
  owner: String!
  ownerPrivileges: Priv!

  """the URL of the item"""
  url: String!
}

type PackageConnection {
  byId(id: ID!): Package
  edges: [PackageEdge!]!
  pageInfo: PageInfo!
}

type PackageEdge {
  cursor: String!
  node: Package!
}

type PageInfo {
  endCursor: String!
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String!
}

enum Pple {
  ADVANCED_PREFERENCES_PANEL
  GENERAL_PREFERENCES_PANEL
  LABEL_PREFERENCES_PANEL
  SIDEBAR_PREFERENCES_PANEL
}

"""The Finder Preferences"""
type Preferences {
  """Show name extensions, even for items whose “extension hidden” is true?"""
  allNameExtensionsShowing: Boolean!

  """the column view options for all windows"""
  columnViewOptions: ColumnViewOptions!

  """
  the delay before springing open a container in seconds (from 0.167 to 1.169)
  """
  delayBeforeSpringing: Float!

  """Connected servers appear on the desktop?"""
  desktopShowsConnectedServers: Boolean!

  """External hard disks appear on the desktop?"""
  desktopShowsExternalHardDisks: Boolean!

  """Hard disks appear on the desktop?"""
  desktopShowsHardDisks: Boolean!

  """CDs, DVDs, and iPods appear on the desktop?"""
  desktopShowsRemovableMedia: Boolean!

  """Folders open into new tabs?"""
  foldersOpenInNewTabs: Boolean!

  """Folders open into new windows?"""
  foldersOpenInNewWindows: Boolean!

  """Spring open folders after the specified delay?"""
  foldersSpringOpen: Boolean!

  """the default icon view options"""
  iconViewOptions: IconViewOptions!

  """the default list view options"""
  listViewOptions: ListViewOptions!

  """Open new windows in column view?"""
  newWindowsOpenInColumnView: Boolean!

  """the window that would open if Finder preferences was opened"""
  window: PreferencesWindow!
}

"""The Finder Preferences window"""
type PreferencesWindow implements Node & WindowInterface {
  """Does the window have a close box?"""
  closeable: Boolean!

  """Is the window collapsed"""
  collapsed: Boolean!

  """The current panel in the Finder preferences window"""
  currentPanel: Pple!

  """Does the window have a title bar?"""
  floating: Boolean!

  """the unique id for this window"""
  id: ID! @extractFromObjectDisplayName

  """the number of the window in the front-to-back layer ordering"""
  index: Int!

  """Is the window modal?"""
  modal: Boolean!

  """the name of the window"""
  name: String!

  """Is the window resizable?"""
  resizable: Boolean!

  """Does the window have a title bar?"""
  titled: Boolean!

  """Is the window visible (always true for open Finder windows)?"""
  visible: Boolean!

  """Is the window zoomable?"""
  zoomable: Boolean!

  """Is the window zoomed?"""
  zoomed: Boolean!
}

type PreferencesWindowConnection implements Connection {
  byId(id: ID!): PreferencesWindow
  edges: [PreferencesWindowEdge!]!
  pageInfo: PageInfo!
}

type PreferencesWindowEdge implements Edge {
  cursor: String!
  node: PreferencesWindow!
}

enum Priv {
  NONE
  READ_ONLY
  READ_WRITE
  WRITE_ONLY
}

type Query {
  application: Application!
}

enum Sodr {
  NORMAL
  REVERSED
}

"""Trash-object is the class of the “trash” object"""
type TrashObject implements ContainerInterface {
  aliasFiles(after: ID, first: Int, whose: Condition): AliasFileConnection!
  applicationFiles(after: ID, first: Int, whose: Condition): ApplicationFileConnection!
  clippings(after: ID, first: Int, whose: Condition): ClippingConnection!

  """
  (NOT AVAILABLE YET) Are the container and all of its children opened as outlines? (can only be set for containers viewed as lists)
  """
  completelyExpanded: Boolean!
  containers(after: ID, first: Int, whose: Condition): ContainerConnection!
  documentFiles(after: ID, first: Int, whose: Condition): DocumentFileConnection!

  """
  (NOT AVAILABLE YET) Is the container capable of being expanded as an outline?
  """
  expandable: Boolean!

  """
  (NOT AVAILABLE YET) Is the container opened as an outline? (can only be set for containers viewed as lists)
  """
  expanded: Boolean!
  files(after: ID, first: Int, whose: Condition): FileConnection!
  folders(after: ID, first: Int, whose: Condition): FolderConnection!
  internetLocationFiles(after: ID, first: Int, whose: Condition): InternetLocationFileConnection!
  items(after: ID, first: Int, whose: Condition): ItemConnection!
  packages(after: ID, first: Int, whose: Condition): PackageConnection!

  """Display a dialog when emptying the trash?"""
  warnsBeforeEmptying: Boolean!
}

"""A window"""
type Window implements Node & WindowInterface {
  """Does the window have a close box?"""
  closeable: Boolean!

  """Is the window collapsed"""
  collapsed: Boolean!

  """Does the window have a title bar?"""
  floating: Boolean!

  """the unique id for this window"""
  id: ID! @extractFromObjectDisplayName

  """the number of the window in the front-to-back layer ordering"""
  index: Int!

  """Is the window modal?"""
  modal: Boolean!

  """the name of the window"""
  name: String!

  """Is the window resizable?"""
  resizable: Boolean!

  """Does the window have a title bar?"""
  titled: Boolean!

  """Is the window visible (always true for open Finder windows)?"""
  visible: Boolean!

  """Is the window zoomable?"""
  zoomable: Boolean!

  """Is the window zoomed?"""
  zoomed: Boolean!
}

type WindowConnection implements Connection {
  byId(id: ID!): WindowInterface
  edges: [WindowEdge!]!
  pageInfo: PageInfo!
}

type WindowEdge implements Edge {
  cursor: String!
  node: WindowInterface!
}

interface WindowInterface implements Node {
  """Does the window have a close box?"""
  closeable: Boolean!

  """Is the window collapsed"""
  collapsed: Boolean!

  """Does the window have a title bar?"""
  floating: Boolean!

  """the unique id for this window"""
  id: ID! @extractFromObjectDisplayName

  """the number of the window in the front-to-back layer ordering"""
  index: Int!

  """Is the window modal?"""
  modal: Boolean!

  """the name of the window"""
  name: String!

  """Is the window resizable?"""
  resizable: Boolean!

  """Does the window have a title bar?"""
  titled: Boolean!

  """Is the window visible (always true for open Finder windows)?"""
  visible: Boolean!

  """Is the window zoomable?"""
  zoomable: Boolean!

  """Is the window zoomed?"""
  zoomed: Boolean!
}
`;

exports[`build - OmniFocus: omnifocus.graphql 1`] = `
directive @extractFromObjectDisplayName on FIELD_DEFINITION

directive @recordType on OBJECT

"""The ancestor trees of this tree."""
type AncestorTree implements Node & TreeInterface {
  """The ancestor trees of this tree."""
  ancestorTrees(after: ID, first: Int, whose: Condition): AncestorTreeConnection!

  """
  All the descendant trees in the user-specified sort ordering, listing each tree, then its children and so forth.
  """
  descendantTrees(after: ID, first: Int, whose: Condition): DescendantTreeConnection!

  """This is true if the node is expanded."""
  expanded: Boolean!

  """
  The sibling trees of this tree after it in the user-specified sort ordering.
  """
  followingSiblings(after: ID, first: Int, whose: Condition): FollowingSiblingConnection!

  """The identifier of object being represented by this tree."""
  id: ID! @extractFromObjectDisplayName

  """The descendants of this tree that have no children themselves."""
  leafs(after: ID, first: Int, whose: Condition): LeafConnection!

  """The name of the object being represented by this tree."""
  name: String!

  """This is true if the node note is expanded."""
  noteExpanded: Boolean!

  """
  The sibling trees of this tree before it in the user-specified sort ordering.
  """
  precedingSiblings(after: ID, first: Int, whose: Condition): PrecedingSiblingConnection!

  """
  This is true if the node is selected.  Note that attempts to set this while the node is not visible (collapsed parent, etc.) will silently do nothing.
  """
  selected: Boolean!

  """The trees of this tree that are selected in the user interface."""
  selectedTrees(after: ID, first: Int, whose: Condition): SelectedTreeConnection!

  """
  The immediate child trees of this tree in the user-specified sort ordering.
  """
  trees(after: ID, first: Int, whose: Condition): TreeConnection!
}

type AncestorTreeConnection implements Connection {
  byId(id: ID!): AncestorTree
  edges: [AncestorTreeEdge!]!
  pageInfo: PageInfo!
}

type AncestorTreeEdge implements Edge {
  cursor: String!
  node: AncestorTree!
}

"""The application's top-level scripting object."""
type Application {
  """
  This is the build number of the application, for example 63.1 or 63.  Major and minor versions are separated by a dot.  So 63.10 comes after 63.1.
  """
  buildNumber: String!

  """
  The current time offset from a reference date. Useful for timing scripts.
  """
  currentTimeOffset: Float!

  """The user's default document."""
  defaultDocument: Document!
  documents(after: ID, first: Int, whose: Condition): DocumentConnection!

  """Is this the active application?"""
  frontmost: Boolean!

  """The name of the application."""
  name: String!

  """The names of all available perspectives in the default document."""
  perspectiveNames: [String!]!
  perspectives(after: ID, first: Int, whose: Condition): PerspectiveConnection!
  preferences(after: ID, first: Int, whose: Condition): PreferenceConnection!

  """The Quick Entry panel for the default document."""
  quickEntry: QuickEntryTree!

  """
  The date on from which the date collated smart groups are based.  When set, the reference date will be rounded to the first instant of the day of the specified date.
  """
  referenceDate: String!

  """The version number of the application."""
  version: String!
  windows(after: ID, first: Int, whose: Condition): WindowConnection!
}

"""An attribute of a style."""
type Attribute {
  """
  The style responsible for the effective value in this attributes's style.  This processes the local values, inherited styles and cascade chain.
  """
  definingStyle: Style!

  """
  If true, the containing style defines a local value for this attribute.
  """
  hasLocalValue: Boolean!

  """The name of the attribute."""
  name: String!

  """The style to which the attribute refers."""
  style: Style!
}

type AttributeConnection {
  byId(id: ID!): Attribute
  edges: [AttributeEdge!]!
  pageInfo: PageInfo!
}

type AttributeEdge {
  cursor: String!
  node: Attribute!
}

"""
A task that is available for action.  This is simply a filter on the existing tasks and should be considred a read-only element.  These cannot be created directly; instead create a normal task.
"""
type AvailableTask implements Node & TaskInterface {
  """
  True if the task has a task that must be completed prior to it being actionable.
  """
  blocked: Boolean!

  """
  True if the task is completed. Use the "mark complete" and "mark incomplete" commands to change a task's status.
  """
  completed: Boolean!

  """If true, complete when children are completed."""
  completedByChildren: Boolean!

  """
  The task's date of completion. This can only be modified on a completed task to backdate the completion date.
  """
  completionDate: String

  """
  The task's project, up however many levels of parent tasks.  Inbox tasks aren't considered contained by their provisionalliy assigned container, so if the task is actually an inbox task, this will be missing value.
  """
  containingProject: Project

  """
  When the task was created.  This can only be set when the object is still in the inserted state.  For objects created in the document, it can be passed with the creation properties.  For objects in a quick entry tree, it can be set until the quick entry panel is saved.
  """
  creationDate: String!

  """When the task should become available for action."""
  deferDate: String

  """
  True if the task is dropped. Use the "mark dropped" and "mark incomplete" commands to change a task's status.
  """
  dropped: Boolean!

  """
  The date the task was dropped. This can only be modified on a dropped task to backdate the dropped date.
  """
  droppedDate: String

  """When the task must be finished."""
  dueDate: String

  """
  When the task should become available for action (including inherited).
  """
  effectiveDeferDate: String

  """When the task must be finished (including inherited)."""
  effectiveDueDate: String

  """
  True if the task is completed, or any of it's containing tasks or project are completed.
  """
  effectivelyCompleted: Boolean!

  """
  True if the task is dropped, or any of it's containing tasks or project are dropped.
  """
  effectivelyDropped: Boolean!

  """
  The estimated time, in whole minutes, that this task will take to finish.
  """
  estimatedMinutes: Int

  """True if flagged"""
  flagged: Boolean!
  flattenedTasks(after: ID, first: Int, whose: Condition): FlattenedTaskConnection!

  """The identifier of the task."""
  id: ID! @extractFromObjectDisplayName

  """
  Returns true if the task itself is an inbox task or if the task is contained by an inbox task.
  """
  inInbox: Boolean!

  """When the task was last modified."""
  modificationDate: String!

  """The name of the task."""
  name: String!

  """If the task is the next task of its containing project, next is true."""
  next: Boolean!

  """
  The next defer date if this task repeats on a fixed schedule and it has a defer date.
  """
  nextDeferDate: String

  """
  The next due date if this task repeats on a fixed schedule and it has a due date.
  """
  nextDueDate: String

  """The note of the task."""
  note: RichText!

  """The number of available direct children of this task."""
  numberOfAvailableTasks: Int!

  """The number of completed direct children of this task."""
  numberOfCompletedTasks: Int!

  """The number of direct children of this task."""
  numberOfTasks: Int!

  """
  The task holding this task.  If this is missing value, then this is a top level task -- either the root of a project or an inbox item.
  """
  parentTask: Task

  """
  The task's first tag. Setting this will remove the current first tag on the task, if any and move or add the new tag as the first tag on the task. Setting this to missing value will remove the current first tag and leave any other remaining tags.
  """
  primaryTag: Tag

  """
  The repetition interval of the task, or missing value if it does not repeat. This property is deprecated in favor of “repetition rule” and is here only for backwards compatibility with existing scripts.
  """
  repetition: RepetitionInterval

  """
  The repetition rule for this task, or missing value if it does not repeat.
  """
  repetitionRule: RepetitionRule

  """If true, any children are sequentially dependent."""
  sequential: Boolean!

  """
  When set, the due date and defer date properties will use floating time zones. (Note: if a Task has no due or defer dates assigned, this property will revert to the database’s default setting.)
  """
  shouldUseFloatingTimeZone: Boolean!

  """The tags assigned to this task."""
  tags(after: ID, first: Int, whose: Condition): TagConnection!

  """The tasks having this task as their container."""
  tasks(after: ID, first: Int, whose: Condition): TaskConnection!
}

type AvailableTaskConnection implements Connection {
  byId(id: ID!): AvailableTask
  edges: [AvailableTaskEdge!]!
  pageInfo: PageInfo!
}

type AvailableTaskEdge implements Edge {
  cursor: String!
  node: AvailableTask!
}

"""A built-in perspective."""
type BuiltinPerspective implements Node & PerspectiveInterface {
  """The identifier of the perspective."""
  id: ID! @extractFromObjectDisplayName

  """The name of the perspective."""
  name: String!
}

type BuiltinPerspectiveConnection implements Connection {
  byId(id: ID!): BuiltinPerspective
  edges: [BuiltinPerspectiveEdge!]!
  pageInfo: PageInfo!
}

type BuiltinPerspectiveEdge implements Edge {
  cursor: String!
  node: BuiltinPerspective!
}

input Condition {
  enabled: Boolean! = true
  field: String
  operands: [Condition!]
  operator: String! = "="
  value: String! = "true"
}

interface Connection {
  byId(id: ID!): Node
  edges: [Edge!]!
  pageInfo: PageInfo!
}

"""The tree of objects in the main window content."""
type ContentTree implements Node & TreeInterface {
  """The ancestor trees of this tree."""
  ancestorTrees(after: ID, first: Int, whose: Condition): AncestorTreeConnection!

  """
  The list of possible identifiers that can be set as the selected grouping identifier.
  """
  availableGroupingIdentifiers: [String!]!

  """
  The list of possible identifiers that can be set as the selected sorting identifier.
  """
  availableSortingIdentifiers: [String!]!

  """
  The list of possible identifiers that can be set as the selected task duration filter identifier.
  """
  availableTaskDurationFilterIdentifiers: [String!]!

  """
  The list of possible identifiers that can be set as the selected task flagged filter identifier.
  """
  availableTaskFlaggedFilterIdentifiers: [String!]!

  """
  The list of possible identifiers that can be set as the selected task state filter identifier.
  """
  availableTaskStateFilterIdentifiers: [String!]!

  """
  All the descendant trees in the user-specified sort ordering, listing each tree, then its children and so forth.
  """
  descendantTrees(after: ID, first: Int, whose: Condition): DescendantTreeConnection!

  """This is true if the node is expanded."""
  expanded: Boolean!

  """
  The sibling trees of this tree after it in the user-specified sort ordering.
  """
  followingSiblings(after: ID, first: Int, whose: Condition): FollowingSiblingConnection!

  """The identifier of object being represented by this tree."""
  id: ID! @extractFromObjectDisplayName

  """The descendants of this tree that have no children themselves."""
  leafs(after: ID, first: Int, whose: Condition): LeafConnection!

  """The name of the object being represented by this tree."""
  name: String!

  """This is true if the node note is expanded."""
  noteExpanded: Boolean!

  """
  The sibling trees of this tree before it in the user-specified sort ordering.
  """
  precedingSiblings(after: ID, first: Int, whose: Condition): PrecedingSiblingConnection!

  """
  This is true if the node is selected.  Note that attempts to set this while the node is not visible (collapsed parent, etc.) will silently do nothing.
  """
  selected: Boolean!

  """
  The currently selected grouping identifier, controlling how the results shown in the content area are grouped.
  """
  selectedGroupingIdentifier: String!

  """
  The currently selected sorting identifier, controlling how the results shown in the content area are ordered.
  """
  selectedSortingIdentifier: String!

  """The currently selected task duration filter identifier."""
  selectedTaskDurationFilterIdentifier: String!

  """The currently selected task flagged filter identifier."""
  selectedTaskFlaggedFilterIdentifier: String!

  """The currently selected task state filter identifier."""
  selectedTaskStateFilterIdentifier: String!

  """The trees of this tree that are selected in the user interface."""
  selectedTrees(after: ID, first: Int, whose: Condition): SelectedTreeConnection!

  """
  The immediate child trees of this tree in the user-specified sort ordering.
  """
  trees(after: ID, first: Int, whose: Condition): TreeConnection!
}

type ContentTreeConnection implements Connection {
  byId(id: ID!): ContentTree
  edges: [ContentTreeEdge!]!
  pageInfo: PageInfo!
}

type ContentTreeEdge implements Edge {
  cursor: String!
  node: ContentTree!
}

"""A user created perspective."""
type CustomPerspective implements Node & PerspectiveInterface {
  """The identifier of the perspective."""
  id: ID! @extractFromObjectDisplayName

  """The name of the perspective."""
  name: String!
}

type CustomPerspectiveConnection implements Connection {
  byId(id: ID!): CustomPerspective
  edges: [CustomPerspectiveEdge!]!
  pageInfo: PageInfo!
}

type CustomPerspectiveEdge implements Edge {
  cursor: String!
  node: CustomPerspective!
}

"""
Deprecated. Where you would look up a "context" by name, id, or index before, you can now use the term "tag". Where you would get or set the "context" property of a task before, you can now use "primary tag". You may also use the "add", "remove", and "move" commands to manage multiple ordered tags on a task now.
"""
type DeprecatedContext implements Node & TagInterface {
  """
  If false, tasks associated with this tag will be skipped when determining the next action for a project.
  """
  allowsNextAction: Boolean!

  """
  A count of the number of unblocked and incomplete tasks of this tag and all its active descendent tags.
  """
  availableTaskCount: Int!
  availableTasks(after: ID, first: Int, whose: Condition): AvailableTaskConnection!

  """The containing tag."""
  container: Tag!

  """Deprecated; use tags."""
  deprecatedContexts(after: ID, first: Int, whose: Condition): DeprecatedContextConnection!

  """
  Set if the tag is currently hidden or any of its container tags are hidden.
  """
  effectivelyHidden: Boolean!
  flattenedTags(after: ID, first: Int, whose: Condition): FlattenedTagConnection!

  """Set if the tag is currently hidden."""
  hidden: Boolean!

  """The identifier of the tag."""
  id: ID! @extractFromObjectDisplayName

  """The physical location associated with the tag."""
  location: LocationInformation

  """The name of the tag."""
  name: String!

  """The note of the tag."""
  note: RichText!

  """
  A count of the number of incomplete tasks of this tag and all its active descendent tags.
  """
  remainingTaskCount: Int!
  remainingTasks(after: ID, first: Int, whose: Condition): RemainingTaskConnection!

  """The tags having this tag as their container."""
  tags(after: ID, first: Int, whose: Condition): TagConnection!

  """The tasks having this tag."""
  tasks(after: ID, first: Int, whose: Condition): TaskConnection!
}

type DeprecatedContextConnection implements Connection {
  byId(id: ID!): DeprecatedContext
  edges: [DeprecatedContextEdge!]!
  pageInfo: PageInfo!
}

type DeprecatedContextEdge implements Edge {
  cursor: String!
  node: DeprecatedContext!
}

"""
All the descendant trees in the user-specified sort ordering, listing each tree, then its children and so forth.
"""
type DescendantTree implements Node & TreeInterface {
  """The ancestor trees of this tree."""
  ancestorTrees(after: ID, first: Int, whose: Condition): AncestorTreeConnection!

  """
  All the descendant trees in the user-specified sort ordering, listing each tree, then its children and so forth.
  """
  descendantTrees(after: ID, first: Int, whose: Condition): DescendantTreeConnection!

  """This is true if the node is expanded."""
  expanded: Boolean!

  """
  The sibling trees of this tree after it in the user-specified sort ordering.
  """
  followingSiblings(after: ID, first: Int, whose: Condition): FollowingSiblingConnection!

  """The identifier of object being represented by this tree."""
  id: ID! @extractFromObjectDisplayName

  """The descendants of this tree that have no children themselves."""
  leafs(after: ID, first: Int, whose: Condition): LeafConnection!

  """The name of the object being represented by this tree."""
  name: String!

  """This is true if the node note is expanded."""
  noteExpanded: Boolean!

  """
  The sibling trees of this tree before it in the user-specified sort ordering.
  """
  precedingSiblings(after: ID, first: Int, whose: Condition): PrecedingSiblingConnection!

  """
  This is true if the node is selected.  Note that attempts to set this while the node is not visible (collapsed parent, etc.) will silently do nothing.
  """
  selected: Boolean!

  """The trees of this tree that are selected in the user interface."""
  selectedTrees(after: ID, first: Int, whose: Condition): SelectedTreeConnection!

  """
  The immediate child trees of this tree in the user-specified sort ordering.
  """
  trees(after: ID, first: Int, whose: Condition): TreeConnection!
}

type DescendantTreeConnection implements Connection {
  byId(id: ID!): DescendantTree
  edges: [DescendantTreeEdge!]!
  pageInfo: PageInfo!
}

type DescendantTreeEdge implements Edge {
  cursor: String!
  node: DescendantTree!
}

"""A document."""
type Document {
  """Whether the document can redo the most recently undone command."""
  canRedo: Boolean!

  """Whether the document can undo the most recent command."""
  canUndo: Boolean!

  """
  Whether the document will write compressed transactions to disk; defaults to true.
  """
  compressesTransactions: Boolean!

  """Deprecated; use tags."""
  deprecatedContexts(after: ID, first: Int, whose: Condition): DeprecatedContextConnection!

  """If set, automatic cleanup of inbox items won't happen."""
  disableAutomaticInboxCleanup: Boolean!

  """The windows of this document."""
  documentWindows(after: ID, first: Int, whose: Condition): DocumentWindowConnection!
  flattenedFolders(after: ID, first: Int, whose: Condition): FlattenedFolderConnection!
  flattenedProjects(after: ID, first: Int, whose: Condition): FlattenedProjectConnection!
  flattenedTags(after: ID, first: Int, whose: Condition): FlattenedTagConnection!
  flattenedTasks(after: ID, first: Int, whose: Condition): FlattenedTaskConnection!

  """
  The subset of the sections that are folders; folders having this folder as their container.
  """
  folders(after: ID, first: Int, whose: Condition): FolderConnection!

  """The document's unique identifier."""
  id: ID! @extractFromObjectDisplayName
  inboxTasks(after: ID, first: Int, whose: Condition): InboxTaskConnection!

  """
  Whether the document will write computed summary information when writing transactions.
  """
  includesSummaries: Boolean!

  """Date of the last sync."""
  lastSyncDate: String!

  """Error message (if any) for the last sync."""
  lastSyncError: String!

  """Has it been modified since the last save?"""
  modified: Boolean!

  """Its name."""
  name: String!

  """The document's path on disk."""
  path: String!

  """The names of all available perspectives in this document."""
  perspectiveNames: [String!]!
  perspectives(after: ID, first: Int, whose: Condition): PerspectiveConnection!

  """
  The subset of the sections that are projects; projects having this folder as their container.
  """
  projects(after: ID, first: Int, whose: Condition): ProjectConnection!

  """The Quick Entry panel for the document."""
  quickEntry: QuickEntryTree!

  """The projects and folders contained by no folder."""
  sections(after: ID, first: Int, whose: Condition): SectionConnection!
  settings(after: ID, first: Int, whose: Condition): SettingConnection!

  """True if the document is currently syncing, false otherwise."""
  syncing: Boolean!

  """The top-level tags of the document."""
  tags(after: ID, first: Int, whose: Condition): TagConnection!
  tasks(after: ID, first: Int, whose: Condition): TaskConnection!

  """Whether the document will autosave."""
  willAutosave: Boolean!
}

type DocumentConnection {
  byId(id: ID!): Document
  edges: [DocumentEdge!]!
  pageInfo: PageInfo!
}

type DocumentEdge {
  cursor: String!
  node: Document!
}

"""A window of an OmniFocus document."""
type DocumentWindow implements Node & WindowInterface {
  """Does the window have a close button?"""
  closeable: Boolean!

  """The tree of objects in the main window content."""
  content: ContentTree!

  """The document whose contents are displayed in the window."""
  document: Document!

  """The unique identifier of the window."""
  id: ID! @extractFromObjectDisplayName

  """The index of the window, ordered front to back."""
  index: Int!

  """Does the window have a minimize button?"""
  miniaturizable: Boolean!

  """Is the window minimized right now?"""
  miniaturized: Boolean!

  """The title of the window."""
  name: String!

  """The name of a perspective."""
  perspectiveName: String!

  """Can the window be resized?"""
  resizable: Boolean!

  """
  The search term in the toolbar.  If there is no search toolbar item, this will return missing value instead of an empty string and setting it will cause an error.
  """
  searchTerm: String!

  """Is the window visible right now?"""
  visible: Boolean!

  """Does the window have a zoom button?"""
  zoomable: Boolean!

  """Is the window zoomed right now?"""
  zoomed: Boolean!
}

type DocumentWindowConnection implements Connection {
  byId(id: ID!): DocumentWindow
  edges: [DocumentWindowEdge!]!
  pageInfo: PageInfo!
}

type DocumentWindowEdge implements Edge {
  cursor: String!
  node: DocumentWindow!
}

interface Edge {
  cursor: String!
  node: Node!
}

"""A flattened list of folders in a document."""
type FlattenedFolder implements FolderInterface & Node {
  """When the folder was created."""
  creationDate: String!

  """
  Set if the folder is currently hidden or any of its container folders are hidden.
  """
  effectivelyHidden: Boolean!
  flattenedFolders(after: ID, first: Int, whose: Condition): FlattenedFolderConnection!
  flattenedProjects(after: ID, first: Int, whose: Condition): FlattenedProjectConnection!

  """
  The subset of the sections that are folders; folders having this folder as their container.
  """
  folders(after: ID, first: Int, whose: Condition): FolderConnection!

  """Set if the folder is currently hidden."""
  hidden: Boolean!

  """The identifier of the folder."""
  id: ID! @extractFromObjectDisplayName

  """When the folder was last modified."""
  modificationDate: String!

  """The name of the folder."""
  name: String!

  """The note of the folder."""
  note: RichText!

  """
  The subset of the sections that are projects; projects having this folder as their container.
  """
  projects(after: ID, first: Int, whose: Condition): ProjectConnection!

  """The projects and folders having this folder as their container."""
  sections(after: ID, first: Int, whose: Condition): SectionConnection!
}

type FlattenedFolderConnection implements Connection {
  byId(id: ID!): FlattenedFolder
  edges: [FlattenedFolderEdge!]!
  pageInfo: PageInfo!
}

type FlattenedFolderEdge implements Edge {
  cursor: String!
  node: FlattenedFolder!
}

"""A flattened list of projects under a folder or document."""
type FlattenedProject implements Node & ProjectInterface {
  """
  True if the project has a project that must be completed prior to it being actionable.
  """
  blocked: Boolean!

  """
  True if the project is completed. Use the "mark complete" and "mark incomplete" commands to change a project's status.
  """
  completed: Boolean!

  """If true, complete when children are completed."""
  completedByChildren: Boolean!

  """
  The project's date of completion. This can only be modified on a completed project to backdate the completion date.
  """
  completionDate: String

  """
  When the project was created.  This can only be set when the object is still in the inserted state.  For objects created in the document, it can be passed with the creation properties.  For objects in a quick entry tree, it can be set until the quick entry panel is saved.
  """
  creationDate: String!

  """
  True if the project is the default holder of sington actions.  Only one project can have this flag set; setting it on a project will clear it on any other project having it.  Setting this to true will set 'singleton action holder' to true if not already so set.
  """
  defaultSingletonActionHolder: Boolean!

  """When the project should become available for action."""
  deferDate: String

  """
  True if the project is dropped. Use the "mark dropped" and "mark incomplete" commands to change a project's status.
  """
  dropped: Boolean!

  """
  The date the project was dropped. This can only be modified on a dropped project to backdate the dropped date.
  """
  droppedDate: String

  """When the project must be finished."""
  dueDate: String

  """
  When the project should become available for action (including inherited).
  """
  effectiveDeferDate: String

  """When the project must be finished (including inherited)."""
  effectiveDueDate: String

  """The effective status of the project."""
  effectiveStatus: ProjectStatus!

  """True if the project is completed"""
  effectivelyCompleted: Boolean!

  """True if the project is dropped"""
  effectivelyDropped: Boolean!

  """
  The estimated time, in whole minutes, that this project will take to finish.
  """
  estimatedMinutes: Int

  """True if flagged"""
  flagged: Boolean!

  """
  The folder of the project, or missing value if it is contained directly by the document.
  """
  folder: Folder

  """The identifier of the project."""
  id: ID! @extractFromObjectDisplayName

  """When the project was last reviewed."""
  lastReviewDate: String!

  """When the project was last modified."""
  modificationDate: String!

  """The name of the project."""
  name: String!

  """
  The next defer date if this project repeats on a fixed schedule and it has a defer date.
  """
  nextDeferDate: String

  """
  The next due date if this project repeats on a fixed schedule and it has a due date.
  """
  nextDueDate: String

  """
  When the project should next be reviewed. Setting this to missing value will set the review date based off the last review date and review interval.
  """
  nextReviewDate: String

  """The next actionable child of this project."""
  nextTask: Task

  """The note of the project."""
  note: RichText!

  """The number of available direct children of this project."""
  numberOfAvailableTasks: Int!

  """The number of completed direct children of this project."""
  numberOfCompletedTasks: Int!

  """The number of direct children of this project."""
  numberOfTasks: Int!

  """
  The project's first tag. Setting this will remove the current first tag on the project, if any and move or add the new tag as the first tag on the project. Setting this to missing value will remove the current first tag and leave any other remaining tags.
  """
  primaryTag: Tag

  """
  The repetition interval of the project, or missing value if it does not repeat. This property is deprecated in favor of “repetition rule” and is here only for backwards compatibility with existing scripts.
  """
  repetition: RepetitionInterval

  """
  The repetition rule for this project, or missing value if it does not repeat.
  """
  repetitionRule: RepetitionRule

  """The review interval for the project."""
  reviewInterval: RepetitionInterval!

  """
  The root task of this project, holding the project's name, note, dates and child tasks.
  """
  rootTask: Task!

  """If true, any children are sequentially dependent."""
  sequential: Boolean!

  """
  When set, the due date and defer date properties will use floating time zones. (Note: if a Task has no due or defer dates assigned, this property will revert to the database’s default setting.)
  """
  shouldUseFloatingTimeZone: Boolean!

  """True if the project contains singleton actions."""
  singletonActionHolder: Boolean!

  """The status of the project."""
  status: ProjectStatus!
}

type FlattenedProjectConnection implements Connection {
  byId(id: ID!): FlattenedProject
  edges: [FlattenedProjectEdge!]!
  pageInfo: PageInfo!
}

type FlattenedProjectEdge implements Edge {
  cursor: String!
  node: FlattenedProject!
}

"""A flattened list of tags in a document."""
type FlattenedTag implements Node & TagInterface {
  """
  If false, tasks associated with this tag will be skipped when determining the next action for a project.
  """
  allowsNextAction: Boolean!

  """
  A count of the number of unblocked and incomplete tasks of this tag and all its active descendent tags.
  """
  availableTaskCount: Int!
  availableTasks(after: ID, first: Int, whose: Condition): AvailableTaskConnection!

  """The containing tag."""
  container: Tag!

  """Deprecated; use tags."""
  deprecatedContexts(after: ID, first: Int, whose: Condition): DeprecatedContextConnection!

  """
  Set if the tag is currently hidden or any of its container tags are hidden.
  """
  effectivelyHidden: Boolean!
  flattenedTags(after: ID, first: Int, whose: Condition): FlattenedTagConnection!

  """Set if the tag is currently hidden."""
  hidden: Boolean!

  """The identifier of the tag."""
  id: ID! @extractFromObjectDisplayName

  """The physical location associated with the tag."""
  location: LocationInformation

  """The name of the tag."""
  name: String!

  """The note of the tag."""
  note: RichText!

  """
  A count of the number of incomplete tasks of this tag and all its active descendent tags.
  """
  remainingTaskCount: Int!
  remainingTasks(after: ID, first: Int, whose: Condition): RemainingTaskConnection!

  """The tags having this tag as their container."""
  tags(after: ID, first: Int, whose: Condition): TagConnection!

  """The tasks having this tag."""
  tasks(after: ID, first: Int, whose: Condition): TaskConnection!
}

type FlattenedTagConnection implements Connection {
  byId(id: ID!): FlattenedTag
  edges: [FlattenedTagEdge!]!
  pageInfo: PageInfo!
}

type FlattenedTagEdge implements Edge {
  cursor: String!
  node: FlattenedTag!
}

"""A flattened list of tasks under a task or document."""
type FlattenedTask implements Node & TaskInterface {
  """
  True if the task has a task that must be completed prior to it being actionable.
  """
  blocked: Boolean!

  """
  True if the task is completed. Use the "mark complete" and "mark incomplete" commands to change a task's status.
  """
  completed: Boolean!

  """If true, complete when children are completed."""
  completedByChildren: Boolean!

  """
  The task's date of completion. This can only be modified on a completed task to backdate the completion date.
  """
  completionDate: String

  """
  The task's project, up however many levels of parent tasks.  Inbox tasks aren't considered contained by their provisionalliy assigned container, so if the task is actually an inbox task, this will be missing value.
  """
  containingProject: Project

  """
  When the task was created.  This can only be set when the object is still in the inserted state.  For objects created in the document, it can be passed with the creation properties.  For objects in a quick entry tree, it can be set until the quick entry panel is saved.
  """
  creationDate: String!

  """When the task should become available for action."""
  deferDate: String

  """
  True if the task is dropped. Use the "mark dropped" and "mark incomplete" commands to change a task's status.
  """
  dropped: Boolean!

  """
  The date the task was dropped. This can only be modified on a dropped task to backdate the dropped date.
  """
  droppedDate: String

  """When the task must be finished."""
  dueDate: String

  """
  When the task should become available for action (including inherited).
  """
  effectiveDeferDate: String

  """When the task must be finished (including inherited)."""
  effectiveDueDate: String

  """
  True if the task is completed, or any of it's containing tasks or project are completed.
  """
  effectivelyCompleted: Boolean!

  """
  True if the task is dropped, or any of it's containing tasks or project are dropped.
  """
  effectivelyDropped: Boolean!

  """
  The estimated time, in whole minutes, that this task will take to finish.
  """
  estimatedMinutes: Int

  """True if flagged"""
  flagged: Boolean!
  flattenedTasks(after: ID, first: Int, whose: Condition): FlattenedTaskConnection!

  """The identifier of the task."""
  id: ID! @extractFromObjectDisplayName

  """
  Returns true if the task itself is an inbox task or if the task is contained by an inbox task.
  """
  inInbox: Boolean!

  """When the task was last modified."""
  modificationDate: String!

  """The name of the task."""
  name: String!

  """If the task is the next task of its containing project, next is true."""
  next: Boolean!

  """
  The next defer date if this task repeats on a fixed schedule and it has a defer date.
  """
  nextDeferDate: String

  """
  The next due date if this task repeats on a fixed schedule and it has a due date.
  """
  nextDueDate: String

  """The note of the task."""
  note: RichText!

  """The number of available direct children of this task."""
  numberOfAvailableTasks: Int!

  """The number of completed direct children of this task."""
  numberOfCompletedTasks: Int!

  """The number of direct children of this task."""
  numberOfTasks: Int!

  """
  The task holding this task.  If this is missing value, then this is a top level task -- either the root of a project or an inbox item.
  """
  parentTask: Task

  """
  The task's first tag. Setting this will remove the current first tag on the task, if any and move or add the new tag as the first tag on the task. Setting this to missing value will remove the current first tag and leave any other remaining tags.
  """
  primaryTag: Tag

  """
  The repetition interval of the task, or missing value if it does not repeat. This property is deprecated in favor of “repetition rule” and is here only for backwards compatibility with existing scripts.
  """
  repetition: RepetitionInterval

  """
  The repetition rule for this task, or missing value if it does not repeat.
  """
  repetitionRule: RepetitionRule

  """If true, any children are sequentially dependent."""
  sequential: Boolean!

  """
  When set, the due date and defer date properties will use floating time zones. (Note: if a Task has no due or defer dates assigned, this property will revert to the database’s default setting.)
  """
  shouldUseFloatingTimeZone: Boolean!

  """The tags assigned to this task."""
  tags(after: ID, first: Int, whose: Condition): TagConnection!

  """The tasks having this task as their container."""
  tasks(after: ID, first: Int, whose: Condition): TaskConnection!
}

type FlattenedTaskConnection implements Connection {
  byId(id: ID!): FlattenedTask
  edges: [FlattenedTaskEdge!]!
  pageInfo: PageInfo!
}

type FlattenedTaskEdge implements Edge {
  cursor: String!
  node: FlattenedTask!
}

"""
A group of projects and sub-folders representing an area of responsibility.
"""
type Folder implements FolderInterface & Node & SectionInterface {
  """When the folder was created."""
  creationDate: String!

  """
  Set if the folder is currently hidden or any of its container folders are hidden.
  """
  effectivelyHidden: Boolean!
  flattenedFolders(after: ID, first: Int, whose: Condition): FlattenedFolderConnection!
  flattenedProjects(after: ID, first: Int, whose: Condition): FlattenedProjectConnection!

  """
  The subset of the sections that are folders; folders having this folder as their container.
  """
  folders(after: ID, first: Int, whose: Condition): FolderConnection!

  """Set if the folder is currently hidden."""
  hidden: Boolean!

  """The identifier of the folder."""
  id: ID! @extractFromObjectDisplayName

  """When the folder was last modified."""
  modificationDate: String!

  """The name of the folder."""
  name: String!

  """The note of the folder."""
  note: RichText!

  """
  The subset of the sections that are projects; projects having this folder as their container.
  """
  projects(after: ID, first: Int, whose: Condition): ProjectConnection!

  """The projects and folders having this folder as their container."""
  sections(after: ID, first: Int, whose: Condition): SectionConnection!
}

type FolderConnection implements Connection {
  byId(id: ID!): FolderInterface
  edges: [FolderEdge!]!
  pageInfo: PageInfo!
}

type FolderEdge implements Edge {
  cursor: String!
  node: FolderInterface!
}

interface FolderInterface implements Node {
  """When the folder was created."""
  creationDate: String!

  """
  Set if the folder is currently hidden or any of its container folders are hidden.
  """
  effectivelyHidden: Boolean!
  flattenedFolders(after: ID, first: Int, whose: Condition): FlattenedFolderConnection!
  flattenedProjects(after: ID, first: Int, whose: Condition): FlattenedProjectConnection!

  """
  The subset of the sections that are folders; folders having this folder as their container.
  """
  folders(after: ID, first: Int, whose: Condition): FolderConnection!

  """Set if the folder is currently hidden."""
  hidden: Boolean!

  """The identifier of the folder."""
  id: ID! @extractFromObjectDisplayName

  """When the folder was last modified."""
  modificationDate: String!

  """The name of the folder."""
  name: String!

  """The note of the folder."""
  note: RichText!

  """
  The subset of the sections that are projects; projects having this folder as their container.
  """
  projects(after: ID, first: Int, whose: Condition): ProjectConnection!

  """The projects and folders having this folder as their container."""
  sections(after: ID, first: Int, whose: Condition): SectionConnection!
}

"""
The sibling trees of this tree after it in the user-specified sort ordering.
"""
type FollowingSibling implements Node & TreeInterface {
  """The ancestor trees of this tree."""
  ancestorTrees(after: ID, first: Int, whose: Condition): AncestorTreeConnection!

  """
  All the descendant trees in the user-specified sort ordering, listing each tree, then its children and so forth.
  """
  descendantTrees(after: ID, first: Int, whose: Condition): DescendantTreeConnection!

  """This is true if the node is expanded."""
  expanded: Boolean!

  """
  The sibling trees of this tree after it in the user-specified sort ordering.
  """
  followingSiblings(after: ID, first: Int, whose: Condition): FollowingSiblingConnection!

  """The identifier of object being represented by this tree."""
  id: ID! @extractFromObjectDisplayName

  """The descendants of this tree that have no children themselves."""
  leafs(after: ID, first: Int, whose: Condition): LeafConnection!

  """The name of the object being represented by this tree."""
  name: String!

  """This is true if the node note is expanded."""
  noteExpanded: Boolean!

  """
  The sibling trees of this tree before it in the user-specified sort ordering.
  """
  precedingSiblings(after: ID, first: Int, whose: Condition): PrecedingSiblingConnection!

  """
  This is true if the node is selected.  Note that attempts to set this while the node is not visible (collapsed parent, etc.) will silently do nothing.
  """
  selected: Boolean!

  """The trees of this tree that are selected in the user interface."""
  selectedTrees(after: ID, first: Int, whose: Condition): SelectedTreeConnection!

  """
  The immediate child trees of this tree in the user-specified sort ordering.
  """
  trees(after: ID, first: Int, whose: Condition): TreeConnection!
}

type FollowingSiblingConnection implements Connection {
  byId(id: ID!): FollowingSibling
  edges: [FollowingSiblingEdge!]!
  pageInfo: PageInfo!
}

type FollowingSiblingEdge implements Edge {
  cursor: String!
  node: FollowingSibling!
}

"""A day in the forecast sidebar tree."""
type ForecastDay implements Node {
  """
  The count shown in the sidebar for this forecast day, or zero if there is no count shown.
  """
  badgeCount: Int!

  """
  True if the forecast day has no content at all. Note that some content will not cause a badge to be shown in the sidebar, and some content is controlled by user preferences.
  """
  empty: Boolean!

  """The identifier of the task."""
  id: ID! @extractFromObjectDisplayName

  """A display name for the forecast day."""
  name: String!
}

type ForecastDayConnection implements Connection {
  byId(id: ID!): ForecastDay
  edges: [ForecastDayEdge!]!
  pageInfo: PageInfo!
}

type ForecastDayEdge implements Edge {
  cursor: String!
  node: ForecastDay!
}

interface ForecastDayInterface implements Node {
  """
  The count shown in the sidebar for this forecast day, or zero if there is no count shown.
  """
  badgeCount: Int!

  """
  True if the forecast day has no content at all. Note that some content will not cause a badge to be shown in the sidebar, and some content is controlled by user preferences.
  """
  empty: Boolean!

  """The identifier of the task."""
  id: ID! @extractFromObjectDisplayName

  """A display name for the forecast day."""
  name: String!
}

"""
The sidebar tree used when the window's sidebar tab property is set to forecast tab.
"""
type ForecastSidebarTree implements SidebarTreeInterface {
  """
  The list of possible smart group identifiers that can be set as the selected smart group identifier.
  """
  availableSmartGroupIdentifiers: [String!]!
  forecastDays(after: ID, first: Int, whose: Condition): ForecastDayConnection!

  """The currently selected smart group identifier."""
  selectedSmartGroupIdentifier: String
}

"""A task that is in the document's inbox"""
type InboxTask implements Node & TaskInterface {
  """
  True if the task has a task that must be completed prior to it being actionable.
  """
  blocked: Boolean!

  """
  True if the task is completed. Use the "mark complete" and "mark incomplete" commands to change a task's status.
  """
  completed: Boolean!

  """If true, complete when children are completed."""
  completedByChildren: Boolean!

  """
  The task's date of completion. This can only be modified on a completed task to backdate the completion date.
  """
  completionDate: String

  """
  The task's project, up however many levels of parent tasks.  Inbox tasks aren't considered contained by their provisionalliy assigned container, so if the task is actually an inbox task, this will be missing value.
  """
  containingProject: Project

  """
  When the task was created.  This can only be set when the object is still in the inserted state.  For objects created in the document, it can be passed with the creation properties.  For objects in a quick entry tree, it can be set until the quick entry panel is saved.
  """
  creationDate: String!

  """When the task should become available for action."""
  deferDate: String

  """
  True if the task is dropped. Use the "mark dropped" and "mark incomplete" commands to change a task's status.
  """
  dropped: Boolean!

  """
  The date the task was dropped. This can only be modified on a dropped task to backdate the dropped date.
  """
  droppedDate: String

  """When the task must be finished."""
  dueDate: String

  """
  When the task should become available for action (including inherited).
  """
  effectiveDeferDate: String

  """When the task must be finished (including inherited)."""
  effectiveDueDate: String

  """
  True if the task is completed, or any of it's containing tasks or project are completed.
  """
  effectivelyCompleted: Boolean!

  """
  True if the task is dropped, or any of it's containing tasks or project are dropped.
  """
  effectivelyDropped: Boolean!

  """
  The estimated time, in whole minutes, that this task will take to finish.
  """
  estimatedMinutes: Int

  """True if flagged"""
  flagged: Boolean!
  flattenedTasks(after: ID, first: Int, whose: Condition): FlattenedTaskConnection!

  """The identifier of the task."""
  id: ID! @extractFromObjectDisplayName

  """
  Returns true if the task itself is an inbox task or if the task is contained by an inbox task.
  """
  inInbox: Boolean!

  """When the task was last modified."""
  modificationDate: String!

  """The name of the task."""
  name: String!

  """If the task is the next task of its containing project, next is true."""
  next: Boolean!

  """
  The next defer date if this task repeats on a fixed schedule and it has a defer date.
  """
  nextDeferDate: String

  """
  The next due date if this task repeats on a fixed schedule and it has a due date.
  """
  nextDueDate: String

  """The note of the task."""
  note: RichText!

  """The number of available direct children of this task."""
  numberOfAvailableTasks: Int!

  """The number of completed direct children of this task."""
  numberOfCompletedTasks: Int!

  """The number of direct children of this task."""
  numberOfTasks: Int!

  """
  The task holding this task.  If this is missing value, then this is a top level task -- either the root of a project or an inbox item.
  """
  parentTask: Task

  """
  The task's first tag. Setting this will remove the current first tag on the task, if any and move or add the new tag as the first tag on the task. Setting this to missing value will remove the current first tag and leave any other remaining tags.
  """
  primaryTag: Tag

  """
  The repetition interval of the task, or missing value if it does not repeat. This property is deprecated in favor of “repetition rule” and is here only for backwards compatibility with existing scripts.
  """
  repetition: RepetitionInterval

  """
  The repetition rule for this task, or missing value if it does not repeat.
  """
  repetitionRule: RepetitionRule

  """If true, any children are sequentially dependent."""
  sequential: Boolean!

  """
  When set, the due date and defer date properties will use floating time zones. (Note: if a Task has no due or defer dates assigned, this property will revert to the database’s default setting.)
  """
  shouldUseFloatingTimeZone: Boolean!

  """The tags assigned to this task."""
  tags(after: ID, first: Int, whose: Condition): TagConnection!

  """The tasks having this task as their container."""
  tasks(after: ID, first: Int, whose: Condition): TaskConnection!
}

type InboxTaskConnection implements Connection {
  byId(id: ID!): InboxTask
  edges: [InboxTaskEdge!]!
  pageInfo: PageInfo!
}

type InboxTaskEdge implements Edge {
  cursor: String!
  node: InboxTask!
}

"""The tree in the sidebar representing the Inbox."""
type InboxTree implements Node & TreeInterface {
  """The ancestor trees of this tree."""
  ancestorTrees(after: ID, first: Int, whose: Condition): AncestorTreeConnection!

  """
  All the descendant trees in the user-specified sort ordering, listing each tree, then its children and so forth.
  """
  descendantTrees(after: ID, first: Int, whose: Condition): DescendantTreeConnection!

  """This is true if the node is expanded."""
  expanded: Boolean!

  """
  The sibling trees of this tree after it in the user-specified sort ordering.
  """
  followingSiblings(after: ID, first: Int, whose: Condition): FollowingSiblingConnection!

  """The identifier of object being represented by this tree."""
  id: ID! @extractFromObjectDisplayName

  """The descendants of this tree that have no children themselves."""
  leafs(after: ID, first: Int, whose: Condition): LeafConnection!

  """The name of the object being represented by this tree."""
  name: String!

  """This is true if the node note is expanded."""
  noteExpanded: Boolean!

  """
  The sibling trees of this tree before it in the user-specified sort ordering.
  """
  precedingSiblings(after: ID, first: Int, whose: Condition): PrecedingSiblingConnection!

  """
  This is true if the node is selected.  Note that attempts to set this while the node is not visible (collapsed parent, etc.) will silently do nothing.
  """
  selected: Boolean!

  """The trees of this tree that are selected in the user interface."""
  selectedTrees(after: ID, first: Int, whose: Condition): SelectedTreeConnection!

  """
  The immediate child trees of this tree in the user-specified sort ordering.
  """
  trees(after: ID, first: Int, whose: Condition): TreeConnection!
}

type InboxTreeConnection implements Connection {
  byId(id: ID!): InboxTree
  edges: [InboxTreeEdge!]!
  pageInfo: PageInfo!
}

type InboxTreeEdge implements Edge {
  cursor: String!
  node: InboxTree!
}

enum IntervalUnit {
  """Days"""
  DAY

  """Hours"""
  HOUR

  """Minutes"""
  MINUTE

  """Months"""
  MONTH

  """Weeks"""
  WEEK

  """Years"""
  YEAR
}

"""The descendants of a tree that have no children themselves."""
type Leaf implements Node & TreeInterface {
  """The ancestor trees of this tree."""
  ancestorTrees(after: ID, first: Int, whose: Condition): AncestorTreeConnection!

  """
  All the descendant trees in the user-specified sort ordering, listing each tree, then its children and so forth.
  """
  descendantTrees(after: ID, first: Int, whose: Condition): DescendantTreeConnection!

  """This is true if the node is expanded."""
  expanded: Boolean!

  """
  The sibling trees of this tree after it in the user-specified sort ordering.
  """
  followingSiblings(after: ID, first: Int, whose: Condition): FollowingSiblingConnection!

  """The identifier of object being represented by this tree."""
  id: ID! @extractFromObjectDisplayName

  """The descendants of this tree that have no children themselves."""
  leafs(after: ID, first: Int, whose: Condition): LeafConnection!

  """The name of the object being represented by this tree."""
  name: String!

  """This is true if the node note is expanded."""
  noteExpanded: Boolean!

  """
  The sibling trees of this tree before it in the user-specified sort ordering.
  """
  precedingSiblings(after: ID, first: Int, whose: Condition): PrecedingSiblingConnection!

  """
  This is true if the node is selected.  Note that attempts to set this while the node is not visible (collapsed parent, etc.) will silently do nothing.
  """
  selected: Boolean!

  """The trees of this tree that are selected in the user interface."""
  selectedTrees(after: ID, first: Int, whose: Condition): SelectedTreeConnection!

  """
  The immediate child trees of this tree in the user-specified sort ordering.
  """
  trees(after: ID, first: Int, whose: Condition): TreeConnection!
}

type LeafConnection implements Connection {
  byId(id: ID!): Leaf
  edges: [LeafEdge!]!
  pageInfo: PageInfo!
}

type LeafEdge implements Edge {
  cursor: String!
  node: Leaf!
}

"""The tree in the sidebar representing the top level library of objects."""
type LibraryTree implements Node & TreeInterface {
  """The ancestor trees of this tree."""
  ancestorTrees(after: ID, first: Int, whose: Condition): AncestorTreeConnection!

  """
  All the descendant trees in the user-specified sort ordering, listing each tree, then its children and so forth.
  """
  descendantTrees(after: ID, first: Int, whose: Condition): DescendantTreeConnection!

  """This is true if the node is expanded."""
  expanded: Boolean!

  """
  The sibling trees of this tree after it in the user-specified sort ordering.
  """
  followingSiblings(after: ID, first: Int, whose: Condition): FollowingSiblingConnection!

  """The identifier of object being represented by this tree."""
  id: ID! @extractFromObjectDisplayName

  """The descendants of this tree that have no children themselves."""
  leafs(after: ID, first: Int, whose: Condition): LeafConnection!

  """The name of the object being represented by this tree."""
  name: String!

  """This is true if the node note is expanded."""
  noteExpanded: Boolean!

  """
  The sibling trees of this tree before it in the user-specified sort ordering.
  """
  precedingSiblings(after: ID, first: Int, whose: Condition): PrecedingSiblingConnection!

  """
  This is true if the node is selected.  Note that attempts to set this while the node is not visible (collapsed parent, etc.) will silently do nothing.
  """
  selected: Boolean!

  """The trees of this tree that are selected in the user interface."""
  selectedTrees(after: ID, first: Int, whose: Condition): SelectedTreeConnection!

  """
  The immediate child trees of this tree in the user-specified sort ordering.
  """
  trees(after: ID, first: Int, whose: Condition): TreeConnection!
}

type LibraryTreeConnection implements Connection {
  byId(id: ID!): LibraryTree
  edges: [LibraryTreeEdge!]!
  pageInfo: PageInfo!
}

type LibraryTreeEdge implements Edge {
  cursor: String!
  node: LibraryTree!
}

type LocationInformation @recordType {
  """Altitude in meters from sea level."""
  altitude: Float!

  """Latitude in degrees from -90 to +90."""
  latitude: Float!

  """Longitude in degrees from -180 to +180."""
  longitude: Float!

  """A display name for the location."""
  name: String!

  """Radius of accuracy in kilometers, from 0.1km to 10km."""
  radius: Float!

  """Location notification trigger."""
  trigger: LocationTrigger!
}

enum LocationTrigger {
  """notify when arriving at this location"""
  NOTIFY_WHEN_ARRIVING

  """notify when leaving this location"""
  NOTIFY_WHEN_LEAVING
}

"""A named style object."""
type NamedStyle implements Node & StyleInterface {
  attributes(after: ID, first: Int, whose: Condition): AttributeConnection!

  """The name of the font of the style."""
  font: String!

  """
  An identifier for the named style that is unique within its document.  Currently this identifier is not persistent between two different sessions of editing the document.
  """
  id: ID! @extractFromObjectDisplayName

  """The name of the style.  Must be unique within the containing document."""
  name: String!
  namedStyles(after: ID, first: Int, whose: Condition): NamedStyleConnection!
}

type NamedStyleConnection implements Connection {
  byId(id: ID!): NamedStyle
  edges: [NamedStyleEdge!]!
  pageInfo: PageInfo!
}

type NamedStyleEdge implements Edge {
  cursor: String!
  node: NamedStyle!
}

interface NamedStyleInterface implements Node {
  """
  An identifier for the named style that is unique within its document.  Currently this identifier is not persistent between two different sessions of editing the document.
  """
  id: ID! @extractFromObjectDisplayName

  """The name of the style.  Must be unique within the containing document."""
  name: String!
}

interface Node {
  id: ID!
}

type PageInfo {
  endCursor: String!
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String!
}

"""A perspective."""
type Perspective implements Node & PerspectiveInterface {
  """The identifier of the perspective."""
  id: ID! @extractFromObjectDisplayName

  """The name of the perspective."""
  name: String!
}

type PerspectiveConnection implements Connection {
  byId(id: ID!): PerspectiveInterface
  edges: [PerspectiveEdge!]!
  pageInfo: PageInfo!
}

type PerspectiveEdge implements Edge {
  cursor: String!
  node: PerspectiveInterface!
}

interface PerspectiveInterface implements Node {
  """The identifier of the perspective."""
  id: ID! @extractFromObjectDisplayName

  """The name of the perspective."""
  name: String!
}

"""
The sibling trees of this tree before it in the user-specified sort ordering.
"""
type PrecedingSibling implements Node & TreeInterface {
  """The ancestor trees of this tree."""
  ancestorTrees(after: ID, first: Int, whose: Condition): AncestorTreeConnection!

  """
  All the descendant trees in the user-specified sort ordering, listing each tree, then its children and so forth.
  """
  descendantTrees(after: ID, first: Int, whose: Condition): DescendantTreeConnection!

  """This is true if the node is expanded."""
  expanded: Boolean!

  """
  The sibling trees of this tree after it in the user-specified sort ordering.
  """
  followingSiblings(after: ID, first: Int, whose: Condition): FollowingSiblingConnection!

  """The identifier of object being represented by this tree."""
  id: ID! @extractFromObjectDisplayName

  """The descendants of this tree that have no children themselves."""
  leafs(after: ID, first: Int, whose: Condition): LeafConnection!

  """The name of the object being represented by this tree."""
  name: String!

  """This is true if the node note is expanded."""
  noteExpanded: Boolean!

  """
  The sibling trees of this tree before it in the user-specified sort ordering.
  """
  precedingSiblings(after: ID, first: Int, whose: Condition): PrecedingSiblingConnection!

  """
  This is true if the node is selected.  Note that attempts to set this while the node is not visible (collapsed parent, etc.) will silently do nothing.
  """
  selected: Boolean!

  """The trees of this tree that are selected in the user interface."""
  selectedTrees(after: ID, first: Int, whose: Condition): SelectedTreeConnection!

  """
  The immediate child trees of this tree in the user-specified sort ordering.
  """
  trees(after: ID, first: Int, whose: Condition): TreeConnection!
}

type PrecedingSiblingConnection implements Connection {
  byId(id: ID!): PrecedingSibling
  edges: [PrecedingSiblingEdge!]!
  pageInfo: PageInfo!
}

type PrecedingSiblingEdge implements Edge {
  cursor: String!
  node: PrecedingSibling!
}

"""Application preference"""
type Preference implements Node {
  """The identifier of the preference."""
  id: ID! @extractFromObjectDisplayName
}

type PreferenceConnection implements Connection {
  byId(id: ID!): Preference
  edges: [PreferenceEdge!]!
  pageInfo: PageInfo!
}

type PreferenceEdge implements Edge {
  cursor: String!
  node: Preference!
}

interface PreferenceInterface implements Node {
  """The identifier of the preference."""
  id: ID! @extractFromObjectDisplayName
}

"""A project."""
type Project implements Node & ProjectInterface & SectionInterface {
  """
  True if the project has a project that must be completed prior to it being actionable.
  """
  blocked: Boolean!

  """
  True if the project is completed. Use the "mark complete" and "mark incomplete" commands to change a project's status.
  """
  completed: Boolean!

  """If true, complete when children are completed."""
  completedByChildren: Boolean!

  """
  The project's date of completion. This can only be modified on a completed project to backdate the completion date.
  """
  completionDate: String

  """
  When the project was created.  This can only be set when the object is still in the inserted state.  For objects created in the document, it can be passed with the creation properties.  For objects in a quick entry tree, it can be set until the quick entry panel is saved.
  """
  creationDate: String!

  """
  True if the project is the default holder of sington actions.  Only one project can have this flag set; setting it on a project will clear it on any other project having it.  Setting this to true will set 'singleton action holder' to true if not already so set.
  """
  defaultSingletonActionHolder: Boolean!

  """When the project should become available for action."""
  deferDate: String

  """
  True if the project is dropped. Use the "mark dropped" and "mark incomplete" commands to change a project's status.
  """
  dropped: Boolean!

  """
  The date the project was dropped. This can only be modified on a dropped project to backdate the dropped date.
  """
  droppedDate: String

  """When the project must be finished."""
  dueDate: String

  """
  When the project should become available for action (including inherited).
  """
  effectiveDeferDate: String

  """When the project must be finished (including inherited)."""
  effectiveDueDate: String

  """The effective status of the project."""
  effectiveStatus: ProjectStatus!

  """True if the project is completed"""
  effectivelyCompleted: Boolean!

  """True if the project is dropped"""
  effectivelyDropped: Boolean!

  """
  The estimated time, in whole minutes, that this project will take to finish.
  """
  estimatedMinutes: Int

  """True if flagged"""
  flagged: Boolean!

  """
  The folder of the project, or missing value if it is contained directly by the document.
  """
  folder: Folder

  """The identifier of the project."""
  id: ID! @extractFromObjectDisplayName

  """When the project was last reviewed."""
  lastReviewDate: String!

  """When the project was last modified."""
  modificationDate: String!

  """The name of the project."""
  name: String!

  """
  The next defer date if this project repeats on a fixed schedule and it has a defer date.
  """
  nextDeferDate: String

  """
  The next due date if this project repeats on a fixed schedule and it has a due date.
  """
  nextDueDate: String

  """
  When the project should next be reviewed. Setting this to missing value will set the review date based off the last review date and review interval.
  """
  nextReviewDate: String

  """The next actionable child of this project."""
  nextTask: Task

  """The note of the project."""
  note: RichText!

  """The number of available direct children of this project."""
  numberOfAvailableTasks: Int!

  """The number of completed direct children of this project."""
  numberOfCompletedTasks: Int!

  """The number of direct children of this project."""
  numberOfTasks: Int!

  """
  The project's first tag. Setting this will remove the current first tag on the project, if any and move or add the new tag as the first tag on the project. Setting this to missing value will remove the current first tag and leave any other remaining tags.
  """
  primaryTag: Tag

  """
  The repetition interval of the project, or missing value if it does not repeat. This property is deprecated in favor of “repetition rule” and is here only for backwards compatibility with existing scripts.
  """
  repetition: RepetitionInterval

  """
  The repetition rule for this project, or missing value if it does not repeat.
  """
  repetitionRule: RepetitionRule

  """The review interval for the project."""
  reviewInterval: RepetitionInterval!

  """
  The root task of this project, holding the project's name, note, dates and child tasks.
  """
  rootTask: Task!

  """If true, any children are sequentially dependent."""
  sequential: Boolean!

  """
  When set, the due date and defer date properties will use floating time zones. (Note: if a Task has no due or defer dates assigned, this property will revert to the database’s default setting.)
  """
  shouldUseFloatingTimeZone: Boolean!

  """True if the project contains singleton actions."""
  singletonActionHolder: Boolean!

  """The status of the project."""
  status: ProjectStatus!
}

type ProjectConnection implements Connection {
  byId(id: ID!): ProjectInterface
  edges: [ProjectEdge!]!
  pageInfo: PageInfo!
}

type ProjectEdge implements Edge {
  cursor: String!
  node: ProjectInterface!
}

interface ProjectInterface implements Node {
  """
  True if the project has a project that must be completed prior to it being actionable.
  """
  blocked: Boolean!

  """
  True if the project is completed. Use the "mark complete" and "mark incomplete" commands to change a project's status.
  """
  completed: Boolean!

  """If true, complete when children are completed."""
  completedByChildren: Boolean!

  """
  The project's date of completion. This can only be modified on a completed project to backdate the completion date.
  """
  completionDate: String

  """
  When the project was created.  This can only be set when the object is still in the inserted state.  For objects created in the document, it can be passed with the creation properties.  For objects in a quick entry tree, it can be set until the quick entry panel is saved.
  """
  creationDate: String!

  """
  True if the project is the default holder of sington actions.  Only one project can have this flag set; setting it on a project will clear it on any other project having it.  Setting this to true will set 'singleton action holder' to true if not already so set.
  """
  defaultSingletonActionHolder: Boolean!

  """When the project should become available for action."""
  deferDate: String

  """
  True if the project is dropped. Use the "mark dropped" and "mark incomplete" commands to change a project's status.
  """
  dropped: Boolean!

  """
  The date the project was dropped. This can only be modified on a dropped project to backdate the dropped date.
  """
  droppedDate: String

  """When the project must be finished."""
  dueDate: String

  """
  When the project should become available for action (including inherited).
  """
  effectiveDeferDate: String

  """When the project must be finished (including inherited)."""
  effectiveDueDate: String

  """The effective status of the project."""
  effectiveStatus: ProjectStatus!

  """True if the project is completed"""
  effectivelyCompleted: Boolean!

  """True if the project is dropped"""
  effectivelyDropped: Boolean!

  """
  The estimated time, in whole minutes, that this project will take to finish.
  """
  estimatedMinutes: Int

  """True if flagged"""
  flagged: Boolean!

  """
  The folder of the project, or missing value if it is contained directly by the document.
  """
  folder: Folder

  """The identifier of the project."""
  id: ID! @extractFromObjectDisplayName

  """When the project was last reviewed."""
  lastReviewDate: String!

  """When the project was last modified."""
  modificationDate: String!

  """The name of the project."""
  name: String!

  """
  The next defer date if this project repeats on a fixed schedule and it has a defer date.
  """
  nextDeferDate: String

  """
  The next due date if this project repeats on a fixed schedule and it has a due date.
  """
  nextDueDate: String

  """
  When the project should next be reviewed. Setting this to missing value will set the review date based off the last review date and review interval.
  """
  nextReviewDate: String

  """The next actionable child of this project."""
  nextTask: Task

  """The note of the project."""
  note: RichText!

  """The number of available direct children of this project."""
  numberOfAvailableTasks: Int!

  """The number of completed direct children of this project."""
  numberOfCompletedTasks: Int!

  """The number of direct children of this project."""
  numberOfTasks: Int!

  """
  The project's first tag. Setting this will remove the current first tag on the project, if any and move or add the new tag as the first tag on the project. Setting this to missing value will remove the current first tag and leave any other remaining tags.
  """
  primaryTag: Tag

  """
  The repetition interval of the project, or missing value if it does not repeat. This property is deprecated in favor of “repetition rule” and is here only for backwards compatibility with existing scripts.
  """
  repetition: RepetitionInterval

  """
  The repetition rule for this project, or missing value if it does not repeat.
  """
  repetitionRule: RepetitionRule

  """The review interval for the project."""
  reviewInterval: RepetitionInterval!

  """
  The root task of this project, holding the project's name, note, dates and child tasks.
  """
  rootTask: Task!

  """If true, any children are sequentially dependent."""
  sequential: Boolean!

  """
  When set, the due date and defer date properties will use floating time zones. (Note: if a Task has no due or defer dates assigned, this property will revert to the database’s default setting.)
  """
  shouldUseFloatingTimeZone: Boolean!

  """True if the project contains singleton actions."""
  singletonActionHolder: Boolean!

  """The status of the project."""
  status: ProjectStatus!
}

enum ProjectStatus {
  """Active"""
  ACTIVE_STATUS

  """Done"""
  DONE_STATUS

  """Dropped"""
  DROPPED_STATUS

  """On Hold"""
  ON_HOLD_STATUS
}

type Query {
  application: Application!
}

"""The Quick Entry panel."""
type QuickEntryTree implements Node & TreeInterface {
  """The ancestor trees of this tree."""
  ancestorTrees(after: ID, first: Int, whose: Condition): AncestorTreeConnection!

  """Deprecated; use tags."""
  deprecatedContexts(after: ID, first: Int, whose: Condition): DeprecatedContextConnection!

  """
  All the descendant trees in the user-specified sort ordering, listing each tree, then its children and so forth.
  """
  descendantTrees(after: ID, first: Int, whose: Condition): DescendantTreeConnection!

  """This is true if the node is expanded."""
  expanded: Boolean!
  folders(after: ID, first: Int, whose: Condition): FolderConnection!

  """
  The sibling trees of this tree after it in the user-specified sort ordering.
  """
  followingSiblings(after: ID, first: Int, whose: Condition): FollowingSiblingConnection!

  """The identifier of object being represented by this tree."""
  id: ID! @extractFromObjectDisplayName
  inboxTasks(after: ID, first: Int, whose: Condition): InboxTaskConnection!

  """The descendants of this tree that have no children themselves."""
  leafs(after: ID, first: Int, whose: Condition): LeafConnection!

  """The name of the object being represented by this tree."""
  name: String!

  """This is true if the node note is expanded."""
  noteExpanded: Boolean!

  """
  The sibling trees of this tree before it in the user-specified sort ordering.
  """
  precedingSiblings(after: ID, first: Int, whose: Condition): PrecedingSiblingConnection!
  projects(after: ID, first: Int, whose: Condition): ProjectConnection!

  """
  This is true if the node is selected.  Note that attempts to set this while the node is not visible (collapsed parent, etc.) will silently do nothing.
  """
  selected: Boolean!

  """The trees of this tree that are selected in the user interface."""
  selectedTrees(after: ID, first: Int, whose: Condition): SelectedTreeConnection!
  tags(after: ID, first: Int, whose: Condition): TagConnection!

  """
  The immediate child trees of this tree in the user-specified sort ordering.
  """
  trees(after: ID, first: Int, whose: Condition): TreeConnection!

  """Whether the quick entry panel is currently visible."""
  visible: Boolean!
}

type QuickEntryTreeConnection implements Connection {
  byId(id: ID!): QuickEntryTree
  edges: [QuickEntryTreeEdge!]!
  pageInfo: PageInfo!
}

type QuickEntryTreeEdge implements Edge {
  cursor: String!
  node: QuickEntryTree!
}

"""
A task that is not complete, though it may be blocked.  This is simply a filter on the existing tasks and should be considred a read-only element.  These cannot be created directly; instead create a normal task.
"""
type RemainingTask implements Node & TaskInterface {
  """
  True if the task has a task that must be completed prior to it being actionable.
  """
  blocked: Boolean!

  """
  True if the task is completed. Use the "mark complete" and "mark incomplete" commands to change a task's status.
  """
  completed: Boolean!

  """If true, complete when children are completed."""
  completedByChildren: Boolean!

  """
  The task's date of completion. This can only be modified on a completed task to backdate the completion date.
  """
  completionDate: String

  """
  The task's project, up however many levels of parent tasks.  Inbox tasks aren't considered contained by their provisionalliy assigned container, so if the task is actually an inbox task, this will be missing value.
  """
  containingProject: Project

  """
  When the task was created.  This can only be set when the object is still in the inserted state.  For objects created in the document, it can be passed with the creation properties.  For objects in a quick entry tree, it can be set until the quick entry panel is saved.
  """
  creationDate: String!

  """When the task should become available for action."""
  deferDate: String

  """
  True if the task is dropped. Use the "mark dropped" and "mark incomplete" commands to change a task's status.
  """
  dropped: Boolean!

  """
  The date the task was dropped. This can only be modified on a dropped task to backdate the dropped date.
  """
  droppedDate: String

  """When the task must be finished."""
  dueDate: String

  """
  When the task should become available for action (including inherited).
  """
  effectiveDeferDate: String

  """When the task must be finished (including inherited)."""
  effectiveDueDate: String

  """
  True if the task is completed, or any of it's containing tasks or project are completed.
  """
  effectivelyCompleted: Boolean!

  """
  True if the task is dropped, or any of it's containing tasks or project are dropped.
  """
  effectivelyDropped: Boolean!

  """
  The estimated time, in whole minutes, that this task will take to finish.
  """
  estimatedMinutes: Int

  """True if flagged"""
  flagged: Boolean!
  flattenedTasks(after: ID, first: Int, whose: Condition): FlattenedTaskConnection!

  """The identifier of the task."""
  id: ID! @extractFromObjectDisplayName

  """
  Returns true if the task itself is an inbox task or if the task is contained by an inbox task.
  """
  inInbox: Boolean!

  """When the task was last modified."""
  modificationDate: String!

  """The name of the task."""
  name: String!

  """If the task is the next task of its containing project, next is true."""
  next: Boolean!

  """
  The next defer date if this task repeats on a fixed schedule and it has a defer date.
  """
  nextDeferDate: String

  """
  The next due date if this task repeats on a fixed schedule and it has a due date.
  """
  nextDueDate: String

  """The note of the task."""
  note: RichText!

  """The number of available direct children of this task."""
  numberOfAvailableTasks: Int!

  """The number of completed direct children of this task."""
  numberOfCompletedTasks: Int!

  """The number of direct children of this task."""
  numberOfTasks: Int!

  """
  The task holding this task.  If this is missing value, then this is a top level task -- either the root of a project or an inbox item.
  """
  parentTask: Task

  """
  The task's first tag. Setting this will remove the current first tag on the task, if any and move or add the new tag as the first tag on the task. Setting this to missing value will remove the current first tag and leave any other remaining tags.
  """
  primaryTag: Tag

  """
  The repetition interval of the task, or missing value if it does not repeat. This property is deprecated in favor of “repetition rule” and is here only for backwards compatibility with existing scripts.
  """
  repetition: RepetitionInterval

  """
  The repetition rule for this task, or missing value if it does not repeat.
  """
  repetitionRule: RepetitionRule

  """If true, any children are sequentially dependent."""
  sequential: Boolean!

  """
  When set, the due date and defer date properties will use floating time zones. (Note: if a Task has no due or defer dates assigned, this property will revert to the database’s default setting.)
  """
  shouldUseFloatingTimeZone: Boolean!

  """The tags assigned to this task."""
  tags(after: ID, first: Int, whose: Condition): TagConnection!

  """The tasks having this task as their container."""
  tasks(after: ID, first: Int, whose: Condition): TaskConnection!
}

type RemainingTaskConnection implements Connection {
  byId(id: ID!): RemainingTask
  edges: [RemainingTaskEdge!]!
  pageInfo: PageInfo!
}

type RemainingTaskEdge implements Edge {
  cursor: String!
  node: RemainingTask!
}

type RepetitionInterval @recordType {
  """
  If fixed, the next repetition will be relative to a fixed calendar.  If sliding, the next repetition will be calculated when needed.
  """
  fixed: Boolean!

  """The count of the repetition interval."""
  steps: Int!

  """The units of the repetition interval."""
  unit: IntervalUnit!
}

enum RepetitionMethod {
  """Due again after completion."""
  DUE_AFTER_COMPLETION

  """Repeat on a fixed schedule."""
  FIXED_REPETITION

  """Start again after completion."""
  START_AFTER_COMPLETION
}

type RepetitionRule @recordType {
  """The iCalendar (RFC 2445) string describing the recurrence."""
  recurrence: String!

  """
  The repetition method. If fixed, the next repetition will be relative to a fixed calendar.  If sliding, the next repetition will be calculated when the action or inbox item is resolved.
  """
  repetitionMethod: RepetitionMethod!
}

scalar RichText

"""A portion of a folder or document; either a project or a folder."""
type Section implements Node & SectionInterface {
  """The identifier of the project or folder."""
  id: ID! @extractFromObjectDisplayName

  """The name of the project or folder."""
  name: String!
}

type SectionConnection implements Connection {
  byId(id: ID!): SectionInterface
  edges: [SectionEdge!]!
  pageInfo: PageInfo!
}

type SectionEdge implements Edge {
  cursor: String!
  node: SectionInterface!
}

interface SectionInterface implements Node {
  """The identifier of the project or folder."""
  id: ID! @extractFromObjectDisplayName

  """The name of the project or folder."""
  name: String!
}

"""
The trees of this tree that are selected in the user interface, possibly including this tree.
"""
type SelectedTree implements Node & TreeInterface {
  """The ancestor trees of this tree."""
  ancestorTrees(after: ID, first: Int, whose: Condition): AncestorTreeConnection!

  """
  All the descendant trees in the user-specified sort ordering, listing each tree, then its children and so forth.
  """
  descendantTrees(after: ID, first: Int, whose: Condition): DescendantTreeConnection!

  """This is true if the node is expanded."""
  expanded: Boolean!

  """
  The sibling trees of this tree after it in the user-specified sort ordering.
  """
  followingSiblings(after: ID, first: Int, whose: Condition): FollowingSiblingConnection!

  """The identifier of object being represented by this tree."""
  id: ID! @extractFromObjectDisplayName

  """The descendants of this tree that have no children themselves."""
  leafs(after: ID, first: Int, whose: Condition): LeafConnection!

  """The name of the object being represented by this tree."""
  name: String!

  """This is true if the node note is expanded."""
  noteExpanded: Boolean!

  """
  The sibling trees of this tree before it in the user-specified sort ordering.
  """
  precedingSiblings(after: ID, first: Int, whose: Condition): PrecedingSiblingConnection!

  """
  This is true if the node is selected.  Note that attempts to set this while the node is not visible (collapsed parent, etc.) will silently do nothing.
  """
  selected: Boolean!

  """The trees of this tree that are selected in the user interface."""
  selectedTrees(after: ID, first: Int, whose: Condition): SelectedTreeConnection!

  """
  The immediate child trees of this tree in the user-specified sort ordering.
  """
  trees(after: ID, first: Int, whose: Condition): TreeConnection!
}

type SelectedTreeConnection implements Connection {
  byId(id: ID!): SelectedTree
  edges: [SelectedTreeEdge!]!
  pageInfo: PageInfo!
}

type SelectedTreeEdge implements Edge {
  cursor: String!
  node: SelectedTree!
}

"""Document setting"""
type Setting implements Node {
  """The identifier of the setting."""
  id: ID! @extractFromObjectDisplayName
}

type SettingConnection implements Connection {
  byId(id: ID!): Setting
  edges: [SettingEdge!]!
  pageInfo: PageInfo!
}

type SettingEdge implements Edge {
  cursor: String!
  node: Setting!
}

interface SettingInterface implements Node {
  """The identifier of the setting."""
  id: ID! @extractFromObjectDisplayName
}

"""The tree of objects in the window sidebar."""
type SidebarTree implements Node & SidebarTreeInterface & TreeInterface {
  """The ancestor trees of this tree."""
  ancestorTrees(after: ID, first: Int, whose: Condition): AncestorTreeConnection!

  """
  The list of possible smart group identifiers that can be set as the selected smart group identifier.
  """
  availableSmartGroupIdentifiers: [String!]!

  """
  All the descendant trees in the user-specified sort ordering, listing each tree, then its children and so forth.
  """
  descendantTrees(after: ID, first: Int, whose: Condition): DescendantTreeConnection!

  """This is true if the node is expanded."""
  expanded: Boolean!

  """
  The sibling trees of this tree after it in the user-specified sort ordering.
  """
  followingSiblings(after: ID, first: Int, whose: Condition): FollowingSiblingConnection!

  """The identifier of object being represented by this tree."""
  id: ID! @extractFromObjectDisplayName

  """The descendants of this tree that have no children themselves."""
  leafs(after: ID, first: Int, whose: Condition): LeafConnection!

  """The name of the object being represented by this tree."""
  name: String!

  """This is true if the node note is expanded."""
  noteExpanded: Boolean!

  """
  The sibling trees of this tree before it in the user-specified sort ordering.
  """
  precedingSiblings(after: ID, first: Int, whose: Condition): PrecedingSiblingConnection!

  """
  This is true if the node is selected.  Note that attempts to set this while the node is not visible (collapsed parent, etc.) will silently do nothing.
  """
  selected: Boolean!

  """The currently selected smart group identifier."""
  selectedSmartGroupIdentifier: String

  """The trees of this tree that are selected in the user interface."""
  selectedTrees(after: ID, first: Int, whose: Condition): SelectedTreeConnection!

  """
  The immediate child trees of this tree in the user-specified sort ordering.
  """
  trees(after: ID, first: Int, whose: Condition): TreeConnection!
}

interface SidebarTreeInterface {
  """
  The list of possible smart group identifiers that can be set as the selected smart group identifier.
  """
  availableSmartGroupIdentifiers: [String!]!

  """The currently selected smart group identifier."""
  selectedSmartGroupIdentifier: String
}

"""A style object."""
type Style implements StyleInterface {
  attributes(after: ID, first: Int, whose: Condition): AttributeConnection!

  """The name of the font of the style."""
  font: String!
  namedStyles(after: ID, first: Int, whose: Condition): NamedStyleConnection!
}

interface StyleInterface {
  attributes(after: ID, first: Int, whose: Condition): AttributeConnection!

  """The name of the font of the style."""
  font: String!
  namedStyles(after: ID, first: Int, whose: Condition): NamedStyleConnection!
}

"""A tag."""
type Tag implements Node & TagInterface {
  """
  If false, tasks associated with this tag will be skipped when determining the next action for a project.
  """
  allowsNextAction: Boolean!

  """
  A count of the number of unblocked and incomplete tasks of this tag and all its active descendent tags.
  """
  availableTaskCount: Int!
  availableTasks(after: ID, first: Int, whose: Condition): AvailableTaskConnection!

  """The containing tag."""
  container: Tag!

  """Deprecated; use tags."""
  deprecatedContexts(after: ID, first: Int, whose: Condition): DeprecatedContextConnection!

  """
  Set if the tag is currently hidden or any of its container tags are hidden.
  """
  effectivelyHidden: Boolean!
  flattenedTags(after: ID, first: Int, whose: Condition): FlattenedTagConnection!

  """Set if the tag is currently hidden."""
  hidden: Boolean!

  """The identifier of the tag."""
  id: ID! @extractFromObjectDisplayName

  """The physical location associated with the tag."""
  location: LocationInformation

  """The name of the tag."""
  name: String!

  """The note of the tag."""
  note: RichText!

  """
  A count of the number of incomplete tasks of this tag and all its active descendent tags.
  """
  remainingTaskCount: Int!
  remainingTasks(after: ID, first: Int, whose: Condition): RemainingTaskConnection!

  """The tags having this tag as their container."""
  tags(after: ID, first: Int, whose: Condition): TagConnection!

  """The tasks having this tag."""
  tasks(after: ID, first: Int, whose: Condition): TaskConnection!
}

type TagConnection implements Connection {
  byId(id: ID!): TagInterface
  edges: [TagEdge!]!
  pageInfo: PageInfo!
}

type TagEdge implements Edge {
  cursor: String!
  node: TagInterface!
}

interface TagInterface implements Node {
  """
  If false, tasks associated with this tag will be skipped when determining the next action for a project.
  """
  allowsNextAction: Boolean!

  """
  A count of the number of unblocked and incomplete tasks of this tag and all its active descendent tags.
  """
  availableTaskCount: Int!
  availableTasks(after: ID, first: Int, whose: Condition): AvailableTaskConnection!

  """The containing tag."""
  container: Tag!

  """Deprecated; use tags."""
  deprecatedContexts(after: ID, first: Int, whose: Condition): DeprecatedContextConnection!

  """
  Set if the tag is currently hidden or any of its container tags are hidden.
  """
  effectivelyHidden: Boolean!
  flattenedTags(after: ID, first: Int, whose: Condition): FlattenedTagConnection!

  """Set if the tag is currently hidden."""
  hidden: Boolean!

  """The identifier of the tag."""
  id: ID! @extractFromObjectDisplayName

  """The physical location associated with the tag."""
  location: LocationInformation

  """The name of the tag."""
  name: String!

  """The note of the tag."""
  note: RichText!

  """
  A count of the number of incomplete tasks of this tag and all its active descendent tags.
  """
  remainingTaskCount: Int!
  remainingTasks(after: ID, first: Int, whose: Condition): RemainingTaskConnection!

  """The tags having this tag as their container."""
  tags(after: ID, first: Int, whose: Condition): TagConnection!

  """The tasks having this tag."""
  tasks(after: ID, first: Int, whose: Condition): TaskConnection!
}

"""
A task. This might represent the root of a project, an action within a project or other action or an inbox item.
"""
type Task implements Node & TaskInterface {
  """
  True if the task has a task that must be completed prior to it being actionable.
  """
  blocked: Boolean!

  """
  True if the task is completed. Use the "mark complete" and "mark incomplete" commands to change a task's status.
  """
  completed: Boolean!

  """If true, complete when children are completed."""
  completedByChildren: Boolean!

  """
  The task's date of completion. This can only be modified on a completed task to backdate the completion date.
  """
  completionDate: String

  """
  The task's project, up however many levels of parent tasks.  Inbox tasks aren't considered contained by their provisionalliy assigned container, so if the task is actually an inbox task, this will be missing value.
  """
  containingProject: Project

  """
  When the task was created.  This can only be set when the object is still in the inserted state.  For objects created in the document, it can be passed with the creation properties.  For objects in a quick entry tree, it can be set until the quick entry panel is saved.
  """
  creationDate: String!

  """When the task should become available for action."""
  deferDate: String

  """
  True if the task is dropped. Use the "mark dropped" and "mark incomplete" commands to change a task's status.
  """
  dropped: Boolean!

  """
  The date the task was dropped. This can only be modified on a dropped task to backdate the dropped date.
  """
  droppedDate: String

  """When the task must be finished."""
  dueDate: String

  """
  When the task should become available for action (including inherited).
  """
  effectiveDeferDate: String

  """When the task must be finished (including inherited)."""
  effectiveDueDate: String

  """
  True if the task is completed, or any of it's containing tasks or project are completed.
  """
  effectivelyCompleted: Boolean!

  """
  True if the task is dropped, or any of it's containing tasks or project are dropped.
  """
  effectivelyDropped: Boolean!

  """
  The estimated time, in whole minutes, that this task will take to finish.
  """
  estimatedMinutes: Int

  """True if flagged"""
  flagged: Boolean!
  flattenedTasks(after: ID, first: Int, whose: Condition): FlattenedTaskConnection!

  """The identifier of the task."""
  id: ID! @extractFromObjectDisplayName

  """
  Returns true if the task itself is an inbox task or if the task is contained by an inbox task.
  """
  inInbox: Boolean!

  """When the task was last modified."""
  modificationDate: String!

  """The name of the task."""
  name: String!

  """If the task is the next task of its containing project, next is true."""
  next: Boolean!

  """
  The next defer date if this task repeats on a fixed schedule and it has a defer date.
  """
  nextDeferDate: String

  """
  The next due date if this task repeats on a fixed schedule and it has a due date.
  """
  nextDueDate: String

  """The note of the task."""
  note: RichText!

  """The number of available direct children of this task."""
  numberOfAvailableTasks: Int!

  """The number of completed direct children of this task."""
  numberOfCompletedTasks: Int!

  """The number of direct children of this task."""
  numberOfTasks: Int!

  """
  The task holding this task.  If this is missing value, then this is a top level task -- either the root of a project or an inbox item.
  """
  parentTask: Task

  """
  The task's first tag. Setting this will remove the current first tag on the task, if any and move or add the new tag as the first tag on the task. Setting this to missing value will remove the current first tag and leave any other remaining tags.
  """
  primaryTag: Tag

  """
  The repetition interval of the task, or missing value if it does not repeat. This property is deprecated in favor of “repetition rule” and is here only for backwards compatibility with existing scripts.
  """
  repetition: RepetitionInterval

  """
  The repetition rule for this task, or missing value if it does not repeat.
  """
  repetitionRule: RepetitionRule

  """If true, any children are sequentially dependent."""
  sequential: Boolean!

  """
  When set, the due date and defer date properties will use floating time zones. (Note: if a Task has no due or defer dates assigned, this property will revert to the database’s default setting.)
  """
  shouldUseFloatingTimeZone: Boolean!

  """The tags assigned to this task."""
  tags(after: ID, first: Int, whose: Condition): TagConnection!

  """The tasks having this task as their container."""
  tasks(after: ID, first: Int, whose: Condition): TaskConnection!
}

type TaskConnection implements Connection {
  byId(id: ID!): TaskInterface
  edges: [TaskEdge!]!
  pageInfo: PageInfo!
}

type TaskEdge implements Edge {
  cursor: String!
  node: TaskInterface!
}

interface TaskInterface implements Node {
  """
  True if the task has a task that must be completed prior to it being actionable.
  """
  blocked: Boolean!

  """
  True if the task is completed. Use the "mark complete" and "mark incomplete" commands to change a task's status.
  """
  completed: Boolean!

  """If true, complete when children are completed."""
  completedByChildren: Boolean!

  """
  The task's date of completion. This can only be modified on a completed task to backdate the completion date.
  """
  completionDate: String

  """
  The task's project, up however many levels of parent tasks.  Inbox tasks aren't considered contained by their provisionalliy assigned container, so if the task is actually an inbox task, this will be missing value.
  """
  containingProject: Project

  """
  When the task was created.  This can only be set when the object is still in the inserted state.  For objects created in the document, it can be passed with the creation properties.  For objects in a quick entry tree, it can be set until the quick entry panel is saved.
  """
  creationDate: String!

  """When the task should become available for action."""
  deferDate: String

  """
  True if the task is dropped. Use the "mark dropped" and "mark incomplete" commands to change a task's status.
  """
  dropped: Boolean!

  """
  The date the task was dropped. This can only be modified on a dropped task to backdate the dropped date.
  """
  droppedDate: String

  """When the task must be finished."""
  dueDate: String

  """
  When the task should become available for action (including inherited).
  """
  effectiveDeferDate: String

  """When the task must be finished (including inherited)."""
  effectiveDueDate: String

  """
  True if the task is completed, or any of it's containing tasks or project are completed.
  """
  effectivelyCompleted: Boolean!

  """
  True if the task is dropped, or any of it's containing tasks or project are dropped.
  """
  effectivelyDropped: Boolean!

  """
  The estimated time, in whole minutes, that this task will take to finish.
  """
  estimatedMinutes: Int

  """True if flagged"""
  flagged: Boolean!
  flattenedTasks(after: ID, first: Int, whose: Condition): FlattenedTaskConnection!

  """The identifier of the task."""
  id: ID! @extractFromObjectDisplayName

  """
  Returns true if the task itself is an inbox task or if the task is contained by an inbox task.
  """
  inInbox: Boolean!

  """When the task was last modified."""
  modificationDate: String!

  """The name of the task."""
  name: String!

  """If the task is the next task of its containing project, next is true."""
  next: Boolean!

  """
  The next defer date if this task repeats on a fixed schedule and it has a defer date.
  """
  nextDeferDate: String

  """
  The next due date if this task repeats on a fixed schedule and it has a due date.
  """
  nextDueDate: String

  """The note of the task."""
  note: RichText!

  """The number of available direct children of this task."""
  numberOfAvailableTasks: Int!

  """The number of completed direct children of this task."""
  numberOfCompletedTasks: Int!

  """The number of direct children of this task."""
  numberOfTasks: Int!

  """
  The task holding this task.  If this is missing value, then this is a top level task -- either the root of a project or an inbox item.
  """
  parentTask: Task

  """
  The task's first tag. Setting this will remove the current first tag on the task, if any and move or add the new tag as the first tag on the task. Setting this to missing value will remove the current first tag and leave any other remaining tags.
  """
  primaryTag: Tag

  """
  The repetition interval of the task, or missing value if it does not repeat. This property is deprecated in favor of “repetition rule” and is here only for backwards compatibility with existing scripts.
  """
  repetition: RepetitionInterval

  """
  The repetition rule for this task, or missing value if it does not repeat.
  """
  repetitionRule: RepetitionRule

  """If true, any children are sequentially dependent."""
  sequential: Boolean!

  """
  When set, the due date and defer date properties will use floating time zones. (Note: if a Task has no due or defer dates assigned, this property will revert to the database’s default setting.)
  """
  shouldUseFloatingTimeZone: Boolean!

  """The tags assigned to this task."""
  tags(after: ID, first: Int, whose: Condition): TagConnection!

  """The tasks having this task as their container."""
  tasks(after: ID, first: Int, whose: Condition): TaskConnection!
}

"""A tree representing an object, along with its sub-trees."""
type Tree implements Node & TreeInterface {
  """The ancestor trees of this tree."""
  ancestorTrees(after: ID, first: Int, whose: Condition): AncestorTreeConnection!

  """
  All the descendant trees in the user-specified sort ordering, listing each tree, then its children and so forth.
  """
  descendantTrees(after: ID, first: Int, whose: Condition): DescendantTreeConnection!

  """This is true if the node is expanded."""
  expanded: Boolean!

  """
  The sibling trees of this tree after it in the user-specified sort ordering.
  """
  followingSiblings(after: ID, first: Int, whose: Condition): FollowingSiblingConnection!

  """The identifier of object being represented by this tree."""
  id: ID! @extractFromObjectDisplayName

  """The descendants of this tree that have no children themselves."""
  leafs(after: ID, first: Int, whose: Condition): LeafConnection!

  """The name of the object being represented by this tree."""
  name: String!

  """This is true if the node note is expanded."""
  noteExpanded: Boolean!

  """
  The sibling trees of this tree before it in the user-specified sort ordering.
  """
  precedingSiblings(after: ID, first: Int, whose: Condition): PrecedingSiblingConnection!

  """
  This is true if the node is selected.  Note that attempts to set this while the node is not visible (collapsed parent, etc.) will silently do nothing.
  """
  selected: Boolean!

  """The trees of this tree that are selected in the user interface."""
  selectedTrees(after: ID, first: Int, whose: Condition): SelectedTreeConnection!

  """
  The immediate child trees of this tree in the user-specified sort ordering.
  """
  trees(after: ID, first: Int, whose: Condition): TreeConnection!
}

type TreeConnection implements Connection {
  byId(id: ID!): TreeInterface
  edges: [TreeEdge!]!
  pageInfo: PageInfo!
}

type TreeEdge implements Edge {
  cursor: String!
  node: TreeInterface!
}

interface TreeInterface implements Node {
  """The ancestor trees of this tree."""
  ancestorTrees(after: ID, first: Int, whose: Condition): AncestorTreeConnection!

  """
  All the descendant trees in the user-specified sort ordering, listing each tree, then its children and so forth.
  """
  descendantTrees(after: ID, first: Int, whose: Condition): DescendantTreeConnection!

  """This is true if the node is expanded."""
  expanded: Boolean!

  """
  The sibling trees of this tree after it in the user-specified sort ordering.
  """
  followingSiblings(after: ID, first: Int, whose: Condition): FollowingSiblingConnection!

  """The identifier of object being represented by this tree."""
  id: ID! @extractFromObjectDisplayName

  """The descendants of this tree that have no children themselves."""
  leafs(after: ID, first: Int, whose: Condition): LeafConnection!

  """The name of the object being represented by this tree."""
  name: String!

  """This is true if the node note is expanded."""
  noteExpanded: Boolean!

  """
  The sibling trees of this tree before it in the user-specified sort ordering.
  """
  precedingSiblings(after: ID, first: Int, whose: Condition): PrecedingSiblingConnection!

  """
  This is true if the node is selected.  Note that attempts to set this while the node is not visible (collapsed parent, etc.) will silently do nothing.
  """
  selected: Boolean!

  """The trees of this tree that are selected in the user interface."""
  selectedTrees(after: ID, first: Int, whose: Condition): SelectedTreeConnection!

  """
  The immediate child trees of this tree in the user-specified sort ordering.
  """
  trees(after: ID, first: Int, whose: Condition): TreeConnection!
}

"""A window."""
type Window implements Node & WindowInterface {
  """Does the window have a close button?"""
  closeable: Boolean!

  """The document whose contents are displayed in the window."""
  document: Document!

  """The unique identifier of the window."""
  id: ID! @extractFromObjectDisplayName

  """The index of the window, ordered front to back."""
  index: Int!

  """Does the window have a minimize button?"""
  miniaturizable: Boolean!

  """Is the window minimized right now?"""
  miniaturized: Boolean!

  """The title of the window."""
  name: String!

  """Can the window be resized?"""
  resizable: Boolean!

  """Is the window visible right now?"""
  visible: Boolean!

  """Does the window have a zoom button?"""
  zoomable: Boolean!

  """Is the window zoomed right now?"""
  zoomed: Boolean!
}

type WindowConnection implements Connection {
  byId(id: ID!): WindowInterface
  edges: [WindowEdge!]!
  pageInfo: PageInfo!
}

type WindowEdge implements Edge {
  cursor: String!
  node: WindowInterface!
}

interface WindowInterface implements Node {
  """Does the window have a close button?"""
  closeable: Boolean!

  """The document whose contents are displayed in the window."""
  document: Document!

  """The unique identifier of the window."""
  id: ID! @extractFromObjectDisplayName

  """The index of the window, ordered front to back."""
  index: Int!

  """Does the window have a minimize button?"""
  miniaturizable: Boolean!

  """Is the window minimized right now?"""
  miniaturized: Boolean!

  """The title of the window."""
  name: String!

  """Can the window be resized?"""
  resizable: Boolean!

  """Is the window visible right now?"""
  visible: Boolean!

  """Does the window have a zoom button?"""
  zoomable: Boolean!

  """Is the window zoomed right now?"""
  zoomed: Boolean!
}
`;
