// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`build - Calendar: calendar.graphql 1`] = `
directive @extractFromObjectDisplayName on FIELD_DEFINITION

directive @recordType on OBJECT

"""The application's top-level scripting object."""
type Application implements Node {
  calendars(after: ID, first: Int, whose: Condition): CalendarConnection!
  documents(after: ID, first: Int, whose: Condition): DocumentConnection!

  """Is this the active application?"""
  frontmost: Boolean!
  id: ID! @extractFromObjectDisplayName

  """The name of the application."""
  name: String!

  """The version number of the application."""
  version: String!
  windows(after: ID, first: Int, whose: Condition): WindowConnection!
}

type ApplicationConnection implements Connection {
  byId(id: ID!): Application
  edges: [ApplicationEdge!]!
  pageInfo: PageInfo!
}

type ApplicationEdge implements Edge {
  cursor: String!
  node: Application!
}

interface ApplicationInterface implements Node {
  documents(after: ID, first: Int, whose: Condition): DocumentConnection!

  """Is this the active application?"""
  frontmost: Boolean!
  id: ID! @extractFromObjectDisplayName

  """The name of the application."""
  name: String!

  """The version number of the application."""
  version: String!
  windows(after: ID, first: Int, whose: Condition): WindowConnection!
}

"""This class represents a attendee."""
type Attendee implements Node {
  """The first and last name of the attendee."""
  displayName: String!

  """e-mail of the attendee."""
  email: String!
  id: ID! @extractFromObjectDisplayName

  """The invitation status for the attendee."""
  participationStatus: ParticipationStatus!
}

type AttendeeConnection implements Connection {
  byId(id: ID!): Attendee
  edges: [AttendeeEdge!]!
  pageInfo: PageInfo!
}

type AttendeeEdge implements Edge {
  cursor: String!
  node: Attendee!
}

interface AttendeeInterface implements Node {
  """The first and last name of the attendee."""
  displayName: String!

  """e-mail of the attendee."""
  email: String!
  id: ID! @extractFromObjectDisplayName

  """The invitation status for the attendee."""
  participationStatus: ParticipationStatus!
}

"""This class represents a calendar."""
type Calendar implements Node {
  """This is the calendar description."""
  description: String!
  events(after: ID, first: Int, whose: Condition): EventConnection!

  """An unique calendar key"""
  id: ID! @extractFromObjectDisplayName

  """This is the calendar title."""
  name: String!

  """This is the calendar title."""
  title: String!

  """This is the calendar title."""
  writable: Boolean!
}

type CalendarConnection implements Connection {
  byId(id: ID!): Calendar
  edges: [CalendarEdge!]!
  pageInfo: PageInfo!
}

type CalendarEdge implements Edge {
  cursor: String!
  node: Calendar!
}

interface CalendarInterface implements Node {
  """This is the calendar description."""
  description: String!
  events(after: ID, first: Int, whose: Condition): EventConnection!

  """An unique calendar key"""
  id: ID! @extractFromObjectDisplayName

  """This is the calendar title."""
  name: String!

  """This is the calendar title."""
  title: String!

  """This is the calendar title."""
  writable: Boolean!
}

input Condition {
  enabled: Boolean! = true
  field: String
  operands: [Condition!]
  operator: String! = "="
  value: String! = "true"
}

interface Connection {
  byId(id: ID!): Node
  edges: [Edge!]!
  pageInfo: PageInfo!
}

"""This class represents a message alarm."""
type DisplayAlarm implements Node {
  id: ID! @extractFromObjectDisplayName

  """An absolute alarm date."""
  triggerDate: String!

  """
  The interval in minutes between the event and the alarm: (positive for alarm that trigger after the event date or negative for alarms that trigger before).
  """
  triggerInterval: Int!
}

type DisplayAlarmConnection implements Connection {
  byId(id: ID!): DisplayAlarm
  edges: [DisplayAlarmEdge!]!
  pageInfo: PageInfo!
}

type DisplayAlarmEdge implements Edge {
  cursor: String!
  node: DisplayAlarm!
}

interface DisplayAlarmInterface implements Node {
  id: ID! @extractFromObjectDisplayName

  """An absolute alarm date."""
  triggerDate: String!

  """
  The interval in minutes between the event and the alarm: (positive for alarm that trigger after the event date or negative for alarms that trigger before).
  """
  triggerInterval: Int!
}

"""A document."""
type Document implements Node {
  id: ID! @extractFromObjectDisplayName

  """Has it been modified since the last save?"""
  modified: Boolean!

  """Its name."""
  name: String!
}

type DocumentConnection implements Connection {
  byId(id: ID!): Document
  edges: [DocumentEdge!]!
  pageInfo: PageInfo!
}

type DocumentEdge implements Edge {
  cursor: String!
  node: Document!
}

interface DocumentInterface implements Node {
  id: ID! @extractFromObjectDisplayName

  """Has it been modified since the last save?"""
  modified: Boolean!

  """Its name."""
  name: String!
}

interface Edge {
  cursor: String!
  node: Node!
}

"""This class represents an event."""
type Event implements Node {
  """True if the event is an all-day event"""
  alldayEvent: Boolean!
  attendees(after: ID, first: Int, whose: Condition): AttendeeConnection!

  """The events notes."""
  description: String!
  displayAlarms(after: ID, first: Int, whose: Condition): DisplayAlarmConnection!

  """The event end date."""
  endDate: String!

  """The exception dates."""
  excludedDates: [String!]!

  """An unique event key."""
  id: ID! @extractFromObjectDisplayName

  """This is the event location."""
  location: String!
  mailAlarms(after: ID, first: Int, whose: Condition): MailAlarmConnection!
  openFileAlarms(after: ID, first: Int, whose: Condition): OpenFileAlarmConnection!

  """
  The iCalendar (RFC 2445) string describing the event recurrence, if defined
  """
  recurrence: String!

  """The event version."""
  sequence: Int!
  soundAlarms(after: ID, first: Int, whose: Condition): SoundAlarmConnection!

  """The event modification date."""
  stampDate: String!

  """The event start date."""
  startDate: String!

  """The event status."""
  status: EventStatus!

  """This is the event summary."""
  summary: String!

  """The URL associated to the event."""
  url: String!
}

type EventConnection implements Connection {
  byId(id: ID!): Event
  edges: [EventEdge!]!
  pageInfo: PageInfo!
}

type EventEdge implements Edge {
  cursor: String!
  node: Event!
}

interface EventInterface implements Node {
  """True if the event is an all-day event"""
  alldayEvent: Boolean!
  attendees(after: ID, first: Int, whose: Condition): AttendeeConnection!

  """The events notes."""
  description: String!
  displayAlarms(after: ID, first: Int, whose: Condition): DisplayAlarmConnection!

  """The event end date."""
  endDate: String!

  """The exception dates."""
  excludedDates: [String!]!

  """An unique event key."""
  id: ID! @extractFromObjectDisplayName

  """This is the event location."""
  location: String!
  mailAlarms(after: ID, first: Int, whose: Condition): MailAlarmConnection!
  openFileAlarms(after: ID, first: Int, whose: Condition): OpenFileAlarmConnection!

  """
  The iCalendar (RFC 2445) string describing the event recurrence, if defined
  """
  recurrence: String!

  """The event version."""
  sequence: Int!
  soundAlarms(after: ID, first: Int, whose: Condition): SoundAlarmConnection!

  """The event modification date."""
  stampDate: String!

  """The event start date."""
  startDate: String!

  """The event status."""
  status: EventStatus!

  """This is the event summary."""
  summary: String!

  """The URL associated to the event."""
  url: String!
}

enum EventStatus {
  """A cancelled event"""
  CANCELLED

  """A confirmed event"""
  CONFIRMED

  """An event without status"""
  NONE

  """A tentative event"""
  TENTATIVE
}

"""This class represents a mail alarm."""
type MailAlarm implements Node {
  id: ID! @extractFromObjectDisplayName

  """An absolute alarm date."""
  triggerDate: String!

  """
  The interval in minutes between the event and the alarm: (positive for alarm that trigger after the event date or negative for alarms that trigger before).
  """
  triggerInterval: Int!
}

type MailAlarmConnection implements Connection {
  byId(id: ID!): MailAlarm
  edges: [MailAlarmEdge!]!
  pageInfo: PageInfo!
}

type MailAlarmEdge implements Edge {
  cursor: String!
  node: MailAlarm!
}

interface MailAlarmInterface implements Node {
  id: ID! @extractFromObjectDisplayName

  """An absolute alarm date."""
  triggerDate: String!

  """
  The interval in minutes between the event and the alarm: (positive for alarm that trigger after the event date or negative for alarms that trigger before).
  """
  triggerInterval: Int!
}

interface Node {
  id: ID! @extractFromObjectDisplayName
}

"""
This class represents an 'open file' alarm. Starting with OS X 10.14, it is not possible to create new open file alarms or view URLs for existing open file alarms. Trying to save or modify an open file alarm will result in a save error. Editing other aspects of events or reminders that have existing open file alarms is allowed as long as the alarm isn't modified.
"""
type OpenFileAlarm implements Node {
  """The (POSIX) path to be opened by the alarm"""
  filepath: String!
  id: ID! @extractFromObjectDisplayName

  """An absolute alarm date."""
  triggerDate: String!

  """
  The interval in minutes between the event and the alarm: (positive for alarm that trigger after the event date or negative for alarms that trigger before).
  """
  triggerInterval: Int!
}

type OpenFileAlarmConnection implements Connection {
  byId(id: ID!): OpenFileAlarm
  edges: [OpenFileAlarmEdge!]!
  pageInfo: PageInfo!
}

type OpenFileAlarmEdge implements Edge {
  cursor: String!
  node: OpenFileAlarm!
}

interface OpenFileAlarmInterface implements Node {
  """The (POSIX) path to be opened by the alarm"""
  filepath: String!
  id: ID! @extractFromObjectDisplayName

  """An absolute alarm date."""
  triggerDate: String!

  """
  The interval in minutes between the event and the alarm: (positive for alarm that trigger after the event date or negative for alarms that trigger before).
  """
  triggerInterval: Int!
}

type PageInfo {
  endCursor: String!
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String!
}

enum ParticipationStatus {
  """Invitation has been accepted"""
  ACCEPTED

  """Invitation has been declined"""
  DECLINED

  """Invitation has been tentatively accepted"""
  TENTATIVE

  """No anwser yet"""
  UNKNOWN
}

type Query {
  application: Application!
}

"""This class represents a sound alarm."""
type SoundAlarm implements Node {
  id: ID! @extractFromObjectDisplayName

  """The (POSIX) path to the sound file to be used for the alarm"""
  soundFile: String!

  """The system sound name to be used for the alarm"""
  soundName: String!

  """An absolute alarm date."""
  triggerDate: String!

  """
  The interval in minutes between the event and the alarm: (positive for alarm that trigger after the event date or negative for alarms that trigger before).
  """
  triggerInterval: Int!
}

type SoundAlarmConnection implements Connection {
  byId(id: ID!): SoundAlarm
  edges: [SoundAlarmEdge!]!
  pageInfo: PageInfo!
}

type SoundAlarmEdge implements Edge {
  cursor: String!
  node: SoundAlarm!
}

interface SoundAlarmInterface implements Node {
  id: ID! @extractFromObjectDisplayName

  """The (POSIX) path to the sound file to be used for the alarm"""
  soundFile: String!

  """The system sound name to be used for the alarm"""
  soundName: String!

  """An absolute alarm date."""
  triggerDate: String!

  """
  The interval in minutes between the event and the alarm: (positive for alarm that trigger after the event date or negative for alarms that trigger before).
  """
  triggerInterval: Int!
}

"""A window."""
type Window implements Node {
  """Does the window have a close button?"""
  closeable: Boolean!

  """The document whose contents are displayed in the window."""
  document: Document!

  """The unique identifier of the window."""
  id: ID! @extractFromObjectDisplayName

  """The index of the window, ordered front to back."""
  index: Int!

  """Does the window have a minimize button?"""
  miniaturizable: Boolean!

  """Is the window minimized right now?"""
  miniaturized: Boolean!

  """The title of the window."""
  name: String!

  """Can the window be resized?"""
  resizable: Boolean!

  """Is the window visible right now?"""
  visible: Boolean!

  """Does the window have a zoom button?"""
  zoomable: Boolean!

  """Is the window zoomed right now?"""
  zoomed: Boolean!
}

type WindowConnection implements Connection {
  byId(id: ID!): Window
  edges: [WindowEdge!]!
  pageInfo: PageInfo!
}

type WindowEdge implements Edge {
  cursor: String!
  node: Window!
}

interface WindowInterface implements Node {
  """Does the window have a close button?"""
  closeable: Boolean!

  """The document whose contents are displayed in the window."""
  document: Document!

  """The unique identifier of the window."""
  id: ID! @extractFromObjectDisplayName

  """The index of the window, ordered front to back."""
  index: Int!

  """Does the window have a minimize button?"""
  miniaturizable: Boolean!

  """Is the window minimized right now?"""
  miniaturized: Boolean!

  """The title of the window."""
  name: String!

  """Can the window be resized?"""
  resizable: Boolean!

  """Is the window visible right now?"""
  visible: Boolean!

  """Does the window have a zoom button?"""
  zoomable: Boolean!

  """Is the window zoomed right now?"""
  zoomed: Boolean!
}
`;

exports[`build - Finder: finder.graphql 1`] = `
directive @extractFromObjectDisplayName on FIELD_DEFINITION

directive @recordType on OBJECT

"""An alias file (created with “Make Alias”)"""
type AliasFile implements FileInterface & ItemInterface & Node {
  """the comment of the item, displayed in the “Get Info” window"""
  comment: String!

  """the container of the item"""
  container: Node!

  """the date on which the item was created"""
  creationDate: String!

  """a description of the item"""
  description: String!

  """the disk on which the item is stored"""
  disk: Node!

  """the user-visible name of the item"""
  displayedName: String!
  everyonesPrivileges: Priv!

  """Is the item's extension hidden from the user?"""
  extensionHidden: Boolean!

  """the user or group that has special access to the container"""
  group: String!
  groupPrivileges: Priv!

  """the icon bitmap of the item"""
  icon: IconFamily!
  id: ID! @extractFromObjectDisplayName

  """the index in the front-to-back ordering within its container"""
  index: Int!

  """the information window for the item"""
  informationWindow: Node!

  """the kind of the item"""
  kind: String!

  """the label of the item"""
  labelIndex: Int!

  """Is the file locked?"""
  locked: Boolean!

  """the date on which the item was last modified"""
  modificationDate: String!

  """the name of the item"""
  name: String!

  """the name extension of the item (such as “txt”)"""
  nameExtension: String!

  """the original item pointed to by the alias"""
  originalItem: Node!

  """the user that owns the container"""
  owner: String!
  ownerPrivileges: Priv!

  """
  the version of the product (visible at the top of the “Get Info” window)
  """
  productVersion: String!

  """Is the file a stationery pad?"""
  stationery: Boolean!

  """the URL of the item"""
  url: String!

  """
  the version of the file (visible at the bottom of the “Get Info” window)
  """
  version: String!
}

type AliasFileConnection implements Connection {
  byId(id: ID!): AliasFile
  edges: [AliasFileEdge!]!
  pageInfo: PageInfo!
}

type AliasFileEdge implements Edge {
  cursor: String!
  node: AliasFile!
}

interface AliasFileInterface implements Node {
  """the comment of the item, displayed in the “Get Info” window"""
  comment: String!

  """the container of the item"""
  container: Node!

  """the date on which the item was created"""
  creationDate: String!

  """a description of the item"""
  description: String!

  """the disk on which the item is stored"""
  disk: Node!

  """the user-visible name of the item"""
  displayedName: String!
  everyonesPrivileges: Priv!

  """Is the item's extension hidden from the user?"""
  extensionHidden: Boolean!

  """the user or group that has special access to the container"""
  group: String!
  groupPrivileges: Priv!

  """the icon bitmap of the item"""
  icon: IconFamily!
  id: ID! @extractFromObjectDisplayName

  """the index in the front-to-back ordering within its container"""
  index: Int!

  """the information window for the item"""
  informationWindow: Node!

  """the kind of the item"""
  kind: String!

  """the label of the item"""
  labelIndex: Int!

  """Is the file locked?"""
  locked: Boolean!

  """the date on which the item was last modified"""
  modificationDate: String!

  """the name of the item"""
  name: String!

  """the name extension of the item (such as “txt”)"""
  nameExtension: String!

  """the original item pointed to by the alias"""
  originalItem: Node!

  """the user that owns the container"""
  owner: String!
  ownerPrivileges: Priv!

  """
  the version of the product (visible at the top of the “Get Info” window)
  """
  productVersion: String!

  """Is the file a stationery pad?"""
  stationery: Boolean!

  """the URL of the item"""
  url: String!

  """
  the version of the file (visible at the bottom of the “Get Info” window)
  """
  version: String!
}

"""
A list of aliases. Use ‘as alias list’ when a list of aliases is needed (instead of a list of file system item references).
"""
type AliasList implements Node {
  id: ID! @extractFromObjectDisplayName
}

type AliasListConnection implements Connection {
  byId(id: ID!): AliasList
  edges: [AliasListEdge!]!
  pageInfo: PageInfo!
}

type AliasListEdge implements Edge {
  cursor: String!
  node: AliasList!
}

interface AliasListInterface implements Node {
  id: ID! @extractFromObjectDisplayName
}

"""The Finder"""
type Application implements Node {
  aliasFiles(after: ID, first: Int, whose: Condition): AliasFileConnection!
  applicationFiles(after: ID, first: Int, whose: Condition): ApplicationFileConnection!

  """(NOT AVAILABLE YET) the Finder’s clipboard window"""
  clipboard: Node!
  clippingWindows(after: ID, first: Int, whose: Condition): ClippingWindowConnection!
  clippings(after: ID, first: Int, whose: Condition): ClippingConnection!

  """the computer location (as in Go > Computer)"""
  computerContainer: ComputerObject!
  containers(after: ID, first: Int, whose: Condition): ContainerConnection!

  """the desktop"""
  desktop: DesktopObject!

  """the desktop picture of the main monitor"""
  desktopPicture: File!
  disks(after: ID, first: Int, whose: Condition): DiskConnection!
  documentFiles(after: ID, first: Int, whose: Condition): DocumentFileConnection!
  files(after: ID, first: Int, whose: Condition): FileConnection!

  """Various preferences that apply to the Finder as a whole"""
  finderPreferences: Preferences!
  finderWindows(after: ID, first: Int, whose: Condition): FinderWindowConnection!
  folders(after: ID, first: Int, whose: Condition): FolderConnection!

  """Is the Finder the frontmost process?"""
  frontmost: Boolean!

  """the home directory"""
  home: Folder!
  id: ID! @extractFromObjectDisplayName

  """
  the container in which a new folder would appear if “New Folder” was selected
  """
  insertionLocation: Node!
  internetLocationFiles(after: ID, first: Int, whose: Condition): InternetLocationFileConnection!
  items(after: ID, first: Int, whose: Condition): ItemConnection!

  """the Finder’s name"""
  name: String!
  packages(after: ID, first: Int, whose: Condition): PackageConnection!

  """the version of the System software running on this computer"""
  productVersion: String!

  """the selection in the frontmost Finder window"""
  selection: Node!

  """the startup disk"""
  startupDisk: Disk!

  """the trash"""
  trash: TrashObject!

  """the version of the Finder"""
  version: String!

  """Is the Finder’s layer visible?"""
  visible: Boolean!
  windows(after: ID, first: Int, whose: Condition): WindowConnection!
}

type ApplicationConnection implements Connection {
  byId(id: ID!): Application
  edges: [ApplicationEdge!]!
  pageInfo: PageInfo!
}

type ApplicationEdge implements Edge {
  cursor: String!
  node: Application!
}

"""An application's file on disk"""
type ApplicationFile implements FileInterface & ItemInterface & Node {
  """
  Is the application high-level event aware? (OBSOLETE: always returns true)
  """
  acceptsHighLevelEvents: Boolean!

  """the comment of the item, displayed in the “Get Info” window"""
  comment: String!

  """the container of the item"""
  container: Node!

  """the date on which the item was created"""
  creationDate: String!

  """a description of the item"""
  description: String!

  """the disk on which the item is stored"""
  disk: Node!

  """the user-visible name of the item"""
  displayedName: String!
  everyonesPrivileges: Priv!

  """Is the item's extension hidden from the user?"""
  extensionHidden: Boolean!

  """the user or group that has special access to the container"""
  group: String!
  groupPrivileges: Priv!

  """
  Does the process have a scripting terminology, i.e., can it be scripted?
  """
  hasScriptingTerminology: Boolean!

  """the icon bitmap of the item"""
  icon: IconFamily!

  """the bundle identifier or creator type of the application"""
  id: ID! @extractFromObjectDisplayName

  """the index in the front-to-back ordering within its container"""
  index: Int!

  """the information window for the item"""
  informationWindow: Node!

  """the kind of the item"""
  kind: String!

  """the label of the item"""
  labelIndex: Int!

  """Is the file locked?"""
  locked: Boolean!

  """
  (AVAILABLE IN 10.1 TO 10.4) the smallest memory size with which the application can be launched
  """
  minimumSize: Int!

  """the date on which the item was last modified"""
  modificationDate: String!

  """the name of the item"""
  name: String!

  """the name extension of the item (such as “txt”)"""
  nameExtension: String!

  """
  (AVAILABLE IN 10.1 TO 10.4) Should the application launch in the Classic environment?
  """
  opensInClassic: Boolean!

  """the user that owns the container"""
  owner: String!
  ownerPrivileges: Priv!

  """
  (AVAILABLE IN 10.1 TO 10.4) the memory size with which the application will be launched
  """
  preferredSize: Int!

  """
  the version of the product (visible at the top of the “Get Info” window)
  """
  productVersion: String!

  """Is the file a stationery pad?"""
  stationery: Boolean!

  """
  (AVAILABLE IN 10.1 TO 10.4) the memory size with which the developer recommends the application be launched
  """
  suggestedSize: Int!

  """the URL of the item"""
  url: String!

  """
  the version of the file (visible at the bottom of the “Get Info” window)
  """
  version: String!
}

type ApplicationFileConnection implements Connection {
  byId(id: ID!): ApplicationFile
  edges: [ApplicationFileEdge!]!
  pageInfo: PageInfo!
}

type ApplicationFileEdge implements Edge {
  cursor: String!
  node: ApplicationFile!
}

interface ApplicationFileInterface implements Node {
  """
  Is the application high-level event aware? (OBSOLETE: always returns true)
  """
  acceptsHighLevelEvents: Boolean!

  """the comment of the item, displayed in the “Get Info” window"""
  comment: String!

  """the container of the item"""
  container: Node!

  """the date on which the item was created"""
  creationDate: String!

  """a description of the item"""
  description: String!

  """the disk on which the item is stored"""
  disk: Node!

  """the user-visible name of the item"""
  displayedName: String!
  everyonesPrivileges: Priv!

  """Is the item's extension hidden from the user?"""
  extensionHidden: Boolean!

  """the user or group that has special access to the container"""
  group: String!
  groupPrivileges: Priv!

  """
  Does the process have a scripting terminology, i.e., can it be scripted?
  """
  hasScriptingTerminology: Boolean!

  """the icon bitmap of the item"""
  icon: IconFamily!

  """the bundle identifier or creator type of the application"""
  id: ID! @extractFromObjectDisplayName

  """the index in the front-to-back ordering within its container"""
  index: Int!

  """the information window for the item"""
  informationWindow: Node!

  """the kind of the item"""
  kind: String!

  """the label of the item"""
  labelIndex: Int!

  """Is the file locked?"""
  locked: Boolean!

  """
  (AVAILABLE IN 10.1 TO 10.4) the smallest memory size with which the application can be launched
  """
  minimumSize: Int!

  """the date on which the item was last modified"""
  modificationDate: String!

  """the name of the item"""
  name: String!

  """the name extension of the item (such as “txt”)"""
  nameExtension: String!

  """
  (AVAILABLE IN 10.1 TO 10.4) Should the application launch in the Classic environment?
  """
  opensInClassic: Boolean!

  """the user that owns the container"""
  owner: String!
  ownerPrivileges: Priv!

  """
  (AVAILABLE IN 10.1 TO 10.4) the memory size with which the application will be launched
  """
  preferredSize: Int!

  """
  the version of the product (visible at the top of the “Get Info” window)
  """
  productVersion: String!

  """Is the file a stationery pad?"""
  stationery: Boolean!

  """
  (AVAILABLE IN 10.1 TO 10.4) the memory size with which the developer recommends the application be launched
  """
  suggestedSize: Int!

  """the URL of the item"""
  url: String!

  """
  the version of the file (visible at the bottom of the “Get Info” window)
  """
  version: String!
}

interface ApplicationInterface implements Node {
  aliasFiles(after: ID, first: Int, whose: Condition): AliasFileConnection!
  applicationFiles(after: ID, first: Int, whose: Condition): ApplicationFileConnection!

  """(NOT AVAILABLE YET) the Finder’s clipboard window"""
  clipboard: Node!
  clippingWindows(after: ID, first: Int, whose: Condition): ClippingWindowConnection!
  clippings(after: ID, first: Int, whose: Condition): ClippingConnection!

  """the computer location (as in Go > Computer)"""
  computerContainer: ComputerObject!
  containers(after: ID, first: Int, whose: Condition): ContainerConnection!

  """the desktop"""
  desktop: DesktopObject!
  disks(after: ID, first: Int, whose: Condition): DiskConnection!
  documentFiles(after: ID, first: Int, whose: Condition): DocumentFileConnection!
  files(after: ID, first: Int, whose: Condition): FileConnection!

  """Various preferences that apply to the Finder as a whole"""
  finderPreferences: Preferences!
  finderWindows(after: ID, first: Int, whose: Condition): FinderWindowConnection!
  folders(after: ID, first: Int, whose: Condition): FolderConnection!

  """Is the Finder the frontmost process?"""
  frontmost: Boolean!

  """the home directory"""
  home: Folder!
  id: ID! @extractFromObjectDisplayName

  """
  the container in which a new folder would appear if “New Folder” was selected
  """
  insertionLocation: Node!
  internetLocationFiles(after: ID, first: Int, whose: Condition): InternetLocationFileConnection!
  items(after: ID, first: Int, whose: Condition): ItemConnection!

  """the Finder’s name"""
  name: String!
  packages(after: ID, first: Int, whose: Condition): PackageConnection!

  """the version of the System software running on this computer"""
  productVersion: String!

  """the selection in the frontmost Finder window"""
  selection: Node!

  """the startup disk"""
  startupDisk: Disk!

  """the trash"""
  trash: TrashObject!

  """the version of the Finder"""
  version: String!

  """Is the Finder’s layer visible?"""
  visible: Boolean!
  windows(after: ID, first: Int, whose: Condition): WindowConnection!
}

"""A process launched from an application file"""
type ApplicationProcess implements Node & ProcessInterface {
  """
  Is the process high-level event aware (accepts open application, open document, print document, and quit)?
  """
  acceptsHighLevelEvents: Boolean!

  """Does the process accept remote events?"""
  acceptsRemoteEvents: Boolean!

  """the application file from which this process was launched"""
  applicationFile: ApplicationFile!

  """the file from which the process was launched"""
  file: Node!

  """Is the process the frontmost process?"""
  frontmost: Boolean!

  """
  Does the process have a scripting terminology, i.e., can it be scripted?
  """
  hasScriptingTerminology: Boolean!
  id: ID! @extractFromObjectDisplayName

  """the name of the process"""
  name: String!

  """the number of bytes currently used in the process' partition"""
  partitionSpaceUsed: Int!

  """the size of the partition with which the process was launched"""
  totalPartitionSize: Int!

  """Is the process' layer visible?"""
  visible: Boolean!
}

type ApplicationProcessConnection implements Connection {
  byId(id: ID!): ApplicationProcess
  edges: [ApplicationProcessEdge!]!
  pageInfo: PageInfo!
}

type ApplicationProcessEdge implements Edge {
  cursor: String!
  node: ApplicationProcess!
}

interface ApplicationProcessInterface implements Node {
  """
  Is the process high-level event aware (accepts open application, open document, print document, and quit)?
  """
  acceptsHighLevelEvents: Boolean!

  """Does the process accept remote events?"""
  acceptsRemoteEvents: Boolean!

  """the application file from which this process was launched"""
  applicationFile: ApplicationFile!

  """the file from which the process was launched"""
  file: Node!

  """Is the process the frontmost process?"""
  frontmost: Boolean!

  """
  Does the process have a scripting terminology, i.e., can it be scripted?
  """
  hasScriptingTerminology: Boolean!
  id: ID! @extractFromObjectDisplayName

  """the name of the process"""
  name: String!

  """the number of bytes currently used in the process' partition"""
  partitionSpaceUsed: Int!

  """the size of the partition with which the process was launched"""
  totalPartitionSize: Int!

  """Is the process' layer visible?"""
  visible: Boolean!
}

"""A clipping"""
type Clipping implements FileInterface & ItemInterface & Node {
  """(NOT AVAILABLE YET) the clipping window for this clipping"""
  clippingWindow: Node!

  """the comment of the item, displayed in the “Get Info” window"""
  comment: String!

  """the container of the item"""
  container: Node!

  """the date on which the item was created"""
  creationDate: String!

  """a description of the item"""
  description: String!

  """the disk on which the item is stored"""
  disk: Node!

  """the user-visible name of the item"""
  displayedName: String!
  everyonesPrivileges: Priv!

  """Is the item's extension hidden from the user?"""
  extensionHidden: Boolean!

  """the user or group that has special access to the container"""
  group: String!
  groupPrivileges: Priv!

  """the icon bitmap of the item"""
  icon: IconFamily!
  id: ID! @extractFromObjectDisplayName

  """the index in the front-to-back ordering within its container"""
  index: Int!

  """the information window for the item"""
  informationWindow: Node!

  """the kind of the item"""
  kind: String!

  """the label of the item"""
  labelIndex: Int!

  """Is the file locked?"""
  locked: Boolean!

  """the date on which the item was last modified"""
  modificationDate: String!

  """the name of the item"""
  name: String!

  """the name extension of the item (such as “txt”)"""
  nameExtension: String!

  """the user that owns the container"""
  owner: String!
  ownerPrivileges: Priv!

  """
  the version of the product (visible at the top of the “Get Info” window)
  """
  productVersion: String!

  """Is the file a stationery pad?"""
  stationery: Boolean!

  """the URL of the item"""
  url: String!

  """
  the version of the file (visible at the bottom of the “Get Info” window)
  """
  version: String!
}

type ClippingConnection implements Connection {
  byId(id: ID!): Clipping
  edges: [ClippingEdge!]!
  pageInfo: PageInfo!
}

type ClippingEdge implements Edge {
  cursor: String!
  node: Clipping!
}

interface ClippingInterface implements Node {
  """(NOT AVAILABLE YET) the clipping window for this clipping"""
  clippingWindow: Node!

  """the comment of the item, displayed in the “Get Info” window"""
  comment: String!

  """the container of the item"""
  container: Node!

  """the date on which the item was created"""
  creationDate: String!

  """a description of the item"""
  description: String!

  """the disk on which the item is stored"""
  disk: Node!

  """the user-visible name of the item"""
  displayedName: String!
  everyonesPrivileges: Priv!

  """Is the item's extension hidden from the user?"""
  extensionHidden: Boolean!

  """the user or group that has special access to the container"""
  group: String!
  groupPrivileges: Priv!

  """the icon bitmap of the item"""
  icon: IconFamily!
  id: ID! @extractFromObjectDisplayName

  """the index in the front-to-back ordering within its container"""
  index: Int!

  """the information window for the item"""
  informationWindow: Node!

  """the kind of the item"""
  kind: String!

  """the label of the item"""
  labelIndex: Int!

  """Is the file locked?"""
  locked: Boolean!

  """the date on which the item was last modified"""
  modificationDate: String!

  """the name of the item"""
  name: String!

  """the name extension of the item (such as “txt”)"""
  nameExtension: String!

  """the user that owns the container"""
  owner: String!
  ownerPrivileges: Priv!

  """
  the version of the product (visible at the top of the “Get Info” window)
  """
  productVersion: String!

  """Is the file a stationery pad?"""
  stationery: Boolean!

  """the URL of the item"""
  url: String!

  """
  the version of the file (visible at the bottom of the “Get Info” window)
  """
  version: String!
}

"""The window containing a clipping"""
type ClippingWindow implements Node & WindowInterface {
  """Does the window have a close box?"""
  closeable: Boolean!

  """Is the window collapsed"""
  collapsed: Boolean!

  """Does the window have a title bar?"""
  floating: Boolean!

  """the unique id for this window"""
  id: ID! @extractFromObjectDisplayName

  """the number of the window in the front-to-back layer ordering"""
  index: Int!

  """Is the window modal?"""
  modal: Boolean!

  """the name of the window"""
  name: String!

  """Is the window resizable?"""
  resizable: Boolean!

  """Does the window have a title bar?"""
  titled: Boolean!

  """Is the window visible (always true for open Finder windows)?"""
  visible: Boolean!

  """Is the window zoomable?"""
  zoomable: Boolean!

  """Is the window zoomed?"""
  zoomed: Boolean!
}

type ClippingWindowConnection implements Connection {
  byId(id: ID!): ClippingWindow
  edges: [ClippingWindowEdge!]!
  pageInfo: PageInfo!
}

type ClippingWindowEdge implements Edge {
  cursor: String!
  node: ClippingWindow!
}

interface ClippingWindowInterface implements Node {
  """Does the window have a close box?"""
  closeable: Boolean!

  """Is the window collapsed"""
  collapsed: Boolean!

  """Does the window have a title bar?"""
  floating: Boolean!

  """the unique id for this window"""
  id: ID! @extractFromObjectDisplayName

  """the number of the window in the front-to-back layer ordering"""
  index: Int!

  """Is the window modal?"""
  modal: Boolean!

  """the name of the window"""
  name: String!

  """Is the window resizable?"""
  resizable: Boolean!

  """Does the window have a title bar?"""
  titled: Boolean!

  """Is the window visible (always true for open Finder windows)?"""
  visible: Boolean!

  """Is the window zoomable?"""
  zoomable: Boolean!

  """Is the window zoomed?"""
  zoomed: Boolean!
}

"""a column of a list view"""
type Column implements Node {
  id: ID! @extractFromObjectDisplayName

  """the index in the front-to-back ordering within its container"""
  index: Int!

  """the maximum allowed width of this column"""
  maximumWidth: Int!

  """the minimum allowed width of this column"""
  minimumWidth: Int!

  """the column name"""
  name: Elsv!

  """The direction in which the window is sorted"""
  sortDirection: Sodr!

  """is this column visible"""
  visible: Boolean!

  """the width of this column"""
  width: Int!
}

type ColumnConnection implements Connection {
  byId(id: ID!): Column
  edges: [ColumnEdge!]!
  pageInfo: PageInfo!
}

type ColumnEdge implements Edge {
  cursor: String!
  node: Column!
}

interface ColumnInterface implements Node {
  id: ID! @extractFromObjectDisplayName

  """the index in the front-to-back ordering within its container"""
  index: Int!

  """the maximum allowed width of this column"""
  maximumWidth: Int!

  """the minimum allowed width of this column"""
  minimumWidth: Int!

  """the column name"""
  name: Elsv!

  """The direction in which the window is sorted"""
  sortDirection: Sodr!

  """is this column visible"""
  visible: Boolean!

  """the width of this column"""
  width: Int!
}

"""the column view options"""
type ColumnViewOptions implements Node {
  """discloses the preview pane of the preview column in column view"""
  disclosesPreviewPane: Boolean!
  id: ID! @extractFromObjectDisplayName

  """displays an icon next to the label in column view"""
  showsIcon: Boolean!

  """displays a preview of the item in column view"""
  showsIconPreview: Boolean!

  """displays the preview column in column view"""
  showsPreviewColumn: Boolean!

  """the size of the text displayed in the column view"""
  textSize: Int!
}

type ColumnViewOptionsConnection implements Connection {
  byId(id: ID!): ColumnViewOptions
  edges: [ColumnViewOptionsEdge!]!
  pageInfo: PageInfo!
}

type ColumnViewOptionsEdge implements Edge {
  cursor: String!
  node: ColumnViewOptions!
}

interface ColumnViewOptionsInterface implements Node {
  """discloses the preview pane of the preview column in column view"""
  disclosesPreviewPane: Boolean!
  id: ID! @extractFromObjectDisplayName

  """displays an icon next to the label in column view"""
  showsIcon: Boolean!

  """displays a preview of the item in column view"""
  showsIconPreview: Boolean!

  """displays the preview column in column view"""
  showsPreviewColumn: Boolean!

  """the size of the text displayed in the column view"""
  textSize: Int!
}

"""the Computer location (as in Go > Computer)"""
type ComputerObject implements ItemInterface & Node {
  """the comment of the item, displayed in the “Get Info” window"""
  comment: String!

  """the container of the item"""
  container: Node!

  """the date on which the item was created"""
  creationDate: String!

  """a description of the item"""
  description: String!

  """the disk on which the item is stored"""
  disk: Node!

  """the user-visible name of the item"""
  displayedName: String!
  everyonesPrivileges: Priv!

  """Is the item's extension hidden from the user?"""
  extensionHidden: Boolean!

  """the user or group that has special access to the container"""
  group: String!
  groupPrivileges: Priv!

  """the icon bitmap of the item"""
  icon: IconFamily!
  id: ID! @extractFromObjectDisplayName

  """the index in the front-to-back ordering within its container"""
  index: Int!

  """the information window for the item"""
  informationWindow: Node!

  """the kind of the item"""
  kind: String!

  """the label of the item"""
  labelIndex: Int!

  """Is the file locked?"""
  locked: Boolean!

  """the date on which the item was last modified"""
  modificationDate: String!

  """the name of the item"""
  name: String!

  """the name extension of the item (such as “txt”)"""
  nameExtension: String!

  """the user that owns the container"""
  owner: String!
  ownerPrivileges: Priv!

  """the URL of the item"""
  url: String!
}

type ComputerObjectConnection implements Connection {
  byId(id: ID!): ComputerObject
  edges: [ComputerObjectEdge!]!
  pageInfo: PageInfo!
}

type ComputerObjectEdge implements Edge {
  cursor: String!
  node: ComputerObject!
}

interface ComputerObjectInterface implements Node {
  """the comment of the item, displayed in the “Get Info” window"""
  comment: String!

  """the container of the item"""
  container: Node!

  """the date on which the item was created"""
  creationDate: String!

  """a description of the item"""
  description: String!

  """the disk on which the item is stored"""
  disk: Node!

  """the user-visible name of the item"""
  displayedName: String!
  everyonesPrivileges: Priv!

  """Is the item's extension hidden from the user?"""
  extensionHidden: Boolean!

  """the user or group that has special access to the container"""
  group: String!
  groupPrivileges: Priv!

  """the icon bitmap of the item"""
  icon: IconFamily!
  id: ID! @extractFromObjectDisplayName

  """the index in the front-to-back ordering within its container"""
  index: Int!

  """the information window for the item"""
  informationWindow: Node!

  """the kind of the item"""
  kind: String!

  """the label of the item"""
  labelIndex: Int!

  """Is the file locked?"""
  locked: Boolean!

  """the date on which the item was last modified"""
  modificationDate: String!

  """the name of the item"""
  name: String!

  """the name extension of the item (such as “txt”)"""
  nameExtension: String!

  """the user that owns the container"""
  owner: String!
  ownerPrivileges: Priv!

  """the URL of the item"""
  url: String!
}

input Condition {
  enabled: Boolean! = true
  field: String
  operands: [Condition!]
  operator: String! = "="
  value: String! = "true"
}

interface Connection {
  byId(id: ID!): Node
  edges: [Edge!]!
  pageInfo: PageInfo!
}

"""An item that contains other items"""
type Container implements ContainerInterface & ItemInterface & Node {
  aliasFiles(after: ID, first: Int, whose: Condition): AliasFileConnection!
  applicationFiles(after: ID, first: Int, whose: Condition): ApplicationFileConnection!
  clippings(after: ID, first: Int, whose: Condition): ClippingConnection!

  """the comment of the item, displayed in the “Get Info” window"""
  comment: String!

  """
  (NOT AVAILABLE YET) Are the container and all of its children opened as outlines? (can only be set for containers viewed as lists)
  """
  completelyExpanded: Boolean!

  """the container of the item"""
  container: Node!

  """the container window for this folder"""
  containerWindow: Node!
  containers(after: ID, first: Int, whose: Condition): ContainerConnection!

  """the date on which the item was created"""
  creationDate: String!

  """a description of the item"""
  description: String!

  """the disk on which the item is stored"""
  disk: Node!

  """the user-visible name of the item"""
  displayedName: String!
  documentFiles(after: ID, first: Int, whose: Condition): DocumentFileConnection!

  """
  the entire contents of the container, including the contents of its children
  """
  entireContents: Node!
  everyonesPrivileges: Priv!

  """
  (NOT AVAILABLE YET) Is the container capable of being expanded as an outline?
  """
  expandable: Boolean!

  """
  (NOT AVAILABLE YET) Is the container opened as an outline? (can only be set for containers viewed as lists)
  """
  expanded: Boolean!

  """Is the item's extension hidden from the user?"""
  extensionHidden: Boolean!
  files(after: ID, first: Int, whose: Condition): FileConnection!
  folders(after: ID, first: Int, whose: Condition): FolderConnection!

  """the user or group that has special access to the container"""
  group: String!
  groupPrivileges: Priv!

  """the icon bitmap of the item"""
  icon: IconFamily!
  id: ID! @extractFromObjectDisplayName

  """the index in the front-to-back ordering within its container"""
  index: Int!

  """the information window for the item"""
  informationWindow: Node!
  internetLocationFiles(after: ID, first: Int, whose: Condition): InternetLocationFileConnection!
  items(after: ID, first: Int, whose: Condition): ItemConnection!

  """the kind of the item"""
  kind: String!

  """the label of the item"""
  labelIndex: Int!

  """Is the file locked?"""
  locked: Boolean!

  """the date on which the item was last modified"""
  modificationDate: String!

  """the name of the item"""
  name: String!

  """the name extension of the item (such as “txt”)"""
  nameExtension: String!

  """the user that owns the container"""
  owner: String!
  ownerPrivileges: Priv!
  packages(after: ID, first: Int, whose: Condition): PackageConnection!

  """the URL of the item"""
  url: String!
}

type ContainerConnection implements Connection {
  byId(id: ID!): ContainerInterface
  edges: [ContainerEdge!]!
  pageInfo: PageInfo!
}

type ContainerEdge implements Edge {
  cursor: String!
  node: ContainerInterface!
}

interface ContainerInterface implements Node {
  aliasFiles(after: ID, first: Int, whose: Condition): AliasFileConnection!
  applicationFiles(after: ID, first: Int, whose: Condition): ApplicationFileConnection!
  clippings(after: ID, first: Int, whose: Condition): ClippingConnection!

  """the comment of the item, displayed in the “Get Info” window"""
  comment: String!

  """
  (NOT AVAILABLE YET) Are the container and all of its children opened as outlines? (can only be set for containers viewed as lists)
  """
  completelyExpanded: Boolean!

  """the container of the item"""
  container: Node!

  """the container window for this folder"""
  containerWindow: Node!
  containers(after: ID, first: Int, whose: Condition): ContainerConnection!

  """the date on which the item was created"""
  creationDate: String!

  """a description of the item"""
  description: String!

  """the disk on which the item is stored"""
  disk: Node!

  """the user-visible name of the item"""
  displayedName: String!
  documentFiles(after: ID, first: Int, whose: Condition): DocumentFileConnection!

  """
  the entire contents of the container, including the contents of its children
  """
  entireContents: Node!
  everyonesPrivileges: Priv!

  """
  (NOT AVAILABLE YET) Is the container capable of being expanded as an outline?
  """
  expandable: Boolean!

  """
  (NOT AVAILABLE YET) Is the container opened as an outline? (can only be set for containers viewed as lists)
  """
  expanded: Boolean!

  """Is the item's extension hidden from the user?"""
  extensionHidden: Boolean!
  files(after: ID, first: Int, whose: Condition): FileConnection!
  folders(after: ID, first: Int, whose: Condition): FolderConnection!

  """the user or group that has special access to the container"""
  group: String!
  groupPrivileges: Priv!

  """the icon bitmap of the item"""
  icon: IconFamily!
  id: ID! @extractFromObjectDisplayName

  """the index in the front-to-back ordering within its container"""
  index: Int!

  """the information window for the item"""
  informationWindow: Node!
  internetLocationFiles(after: ID, first: Int, whose: Condition): InternetLocationFileConnection!
  items(after: ID, first: Int, whose: Condition): ItemConnection!

  """the kind of the item"""
  kind: String!

  """the label of the item"""
  labelIndex: Int!

  """Is the file locked?"""
  locked: Boolean!

  """the date on which the item was last modified"""
  modificationDate: String!

  """the name of the item"""
  name: String!

  """the name extension of the item (such as “txt”)"""
  nameExtension: String!

  """the user that owns the container"""
  owner: String!
  ownerPrivileges: Priv!
  packages(after: ID, first: Int, whose: Condition): PackageConnection!

  """the URL of the item"""
  url: String!
}

"""A process launched from a desk accessory file"""
type DeskAccessoryProcess implements Node & ProcessInterface {
  """
  Is the process high-level event aware (accepts open application, open document, print document, and quit)?
  """
  acceptsHighLevelEvents: Boolean!

  """Does the process accept remote events?"""
  acceptsRemoteEvents: Boolean!

  """the desk accessory file from which this process was launched"""
  deskAccessoryFile: Node!

  """the file from which the process was launched"""
  file: Node!

  """Is the process the frontmost process?"""
  frontmost: Boolean!

  """
  Does the process have a scripting terminology, i.e., can it be scripted?
  """
  hasScriptingTerminology: Boolean!
  id: ID! @extractFromObjectDisplayName

  """the name of the process"""
  name: String!

  """the number of bytes currently used in the process' partition"""
  partitionSpaceUsed: Int!

  """the size of the partition with which the process was launched"""
  totalPartitionSize: Int!

  """Is the process' layer visible?"""
  visible: Boolean!
}

type DeskAccessoryProcessConnection implements Connection {
  byId(id: ID!): DeskAccessoryProcess
  edges: [DeskAccessoryProcessEdge!]!
  pageInfo: PageInfo!
}

type DeskAccessoryProcessEdge implements Edge {
  cursor: String!
  node: DeskAccessoryProcess!
}

interface DeskAccessoryProcessInterface implements Node {
  """
  Is the process high-level event aware (accepts open application, open document, print document, and quit)?
  """
  acceptsHighLevelEvents: Boolean!

  """Does the process accept remote events?"""
  acceptsRemoteEvents: Boolean!

  """the desk accessory file from which this process was launched"""
  deskAccessoryFile: Node!

  """the file from which the process was launched"""
  file: Node!

  """Is the process the frontmost process?"""
  frontmost: Boolean!

  """
  Does the process have a scripting terminology, i.e., can it be scripted?
  """
  hasScriptingTerminology: Boolean!
  id: ID! @extractFromObjectDisplayName

  """the name of the process"""
  name: String!

  """the number of bytes currently used in the process' partition"""
  partitionSpaceUsed: Int!

  """the size of the partition with which the process was launched"""
  totalPartitionSize: Int!

  """Is the process' layer visible?"""
  visible: Boolean!
}

"""Desktop-object is the class of the “desktop” object"""
type DesktopObject implements ContainerInterface & ItemInterface & Node {
  aliasFiles(after: ID, first: Int, whose: Condition): AliasFileConnection!
  applicationFiles(after: ID, first: Int, whose: Condition): ApplicationFileConnection!
  clippings(after: ID, first: Int, whose: Condition): ClippingConnection!

  """the comment of the item, displayed in the “Get Info” window"""
  comment: String!

  """
  (NOT AVAILABLE YET) Are the container and all of its children opened as outlines? (can only be set for containers viewed as lists)
  """
  completelyExpanded: Boolean!

  """the container of the item"""
  container: Node!

  """the container window for this folder"""
  containerWindow: Node!
  containers(after: ID, first: Int, whose: Condition): ContainerConnection!

  """the date on which the item was created"""
  creationDate: String!

  """a description of the item"""
  description: String!

  """the disk on which the item is stored"""
  disk: Node!
  disks(after: ID, first: Int, whose: Condition): DiskConnection!

  """the user-visible name of the item"""
  displayedName: String!
  documentFiles(after: ID, first: Int, whose: Condition): DocumentFileConnection!

  """
  the entire contents of the container, including the contents of its children
  """
  entireContents: Node!
  everyonesPrivileges: Priv!

  """
  (NOT AVAILABLE YET) Is the container capable of being expanded as an outline?
  """
  expandable: Boolean!

  """
  (NOT AVAILABLE YET) Is the container opened as an outline? (can only be set for containers viewed as lists)
  """
  expanded: Boolean!

  """Is the item's extension hidden from the user?"""
  extensionHidden: Boolean!
  files(after: ID, first: Int, whose: Condition): FileConnection!
  folders(after: ID, first: Int, whose: Condition): FolderConnection!

  """the user or group that has special access to the container"""
  group: String!
  groupPrivileges: Priv!

  """the icon bitmap of the item"""
  icon: IconFamily!
  id: ID! @extractFromObjectDisplayName

  """the index in the front-to-back ordering within its container"""
  index: Int!

  """the information window for the item"""
  informationWindow: Node!
  internetLocationFiles(after: ID, first: Int, whose: Condition): InternetLocationFileConnection!
  items(after: ID, first: Int, whose: Condition): ItemConnection!

  """the kind of the item"""
  kind: String!

  """the label of the item"""
  labelIndex: Int!

  """Is the file locked?"""
  locked: Boolean!

  """the date on which the item was last modified"""
  modificationDate: String!

  """the name of the item"""
  name: String!

  """the name extension of the item (such as “txt”)"""
  nameExtension: String!

  """the user that owns the container"""
  owner: String!
  ownerPrivileges: Priv!
  packages(after: ID, first: Int, whose: Condition): PackageConnection!

  """the URL of the item"""
  url: String!
}

type DesktopObjectConnection implements Connection {
  byId(id: ID!): DesktopObject
  edges: [DesktopObjectEdge!]!
  pageInfo: PageInfo!
}

type DesktopObjectEdge implements Edge {
  cursor: String!
  node: DesktopObject!
}

interface DesktopObjectInterface implements Node {
  aliasFiles(after: ID, first: Int, whose: Condition): AliasFileConnection!
  applicationFiles(after: ID, first: Int, whose: Condition): ApplicationFileConnection!
  clippings(after: ID, first: Int, whose: Condition): ClippingConnection!

  """the comment of the item, displayed in the “Get Info” window"""
  comment: String!

  """
  (NOT AVAILABLE YET) Are the container and all of its children opened as outlines? (can only be set for containers viewed as lists)
  """
  completelyExpanded: Boolean!

  """the container of the item"""
  container: Node!

  """the container window for this folder"""
  containerWindow: Node!
  containers(after: ID, first: Int, whose: Condition): ContainerConnection!

  """the date on which the item was created"""
  creationDate: String!

  """a description of the item"""
  description: String!

  """the disk on which the item is stored"""
  disk: Node!
  disks(after: ID, first: Int, whose: Condition): DiskConnection!

  """the user-visible name of the item"""
  displayedName: String!
  documentFiles(after: ID, first: Int, whose: Condition): DocumentFileConnection!

  """
  the entire contents of the container, including the contents of its children
  """
  entireContents: Node!
  everyonesPrivileges: Priv!

  """
  (NOT AVAILABLE YET) Is the container capable of being expanded as an outline?
  """
  expandable: Boolean!

  """
  (NOT AVAILABLE YET) Is the container opened as an outline? (can only be set for containers viewed as lists)
  """
  expanded: Boolean!

  """Is the item's extension hidden from the user?"""
  extensionHidden: Boolean!
  files(after: ID, first: Int, whose: Condition): FileConnection!
  folders(after: ID, first: Int, whose: Condition): FolderConnection!

  """the user or group that has special access to the container"""
  group: String!
  groupPrivileges: Priv!

  """the icon bitmap of the item"""
  icon: IconFamily!
  id: ID! @extractFromObjectDisplayName

  """the index in the front-to-back ordering within its container"""
  index: Int!

  """the information window for the item"""
  informationWindow: Node!
  internetLocationFiles(after: ID, first: Int, whose: Condition): InternetLocationFileConnection!
  items(after: ID, first: Int, whose: Condition): ItemConnection!

  """the kind of the item"""
  kind: String!

  """the label of the item"""
  labelIndex: Int!

  """Is the file locked?"""
  locked: Boolean!

  """the date on which the item was last modified"""
  modificationDate: String!

  """the name of the item"""
  name: String!

  """the name extension of the item (such as “txt”)"""
  nameExtension: String!

  """the user that owns the container"""
  owner: String!
  ownerPrivileges: Priv!
  packages(after: ID, first: Int, whose: Condition): PackageConnection!

  """the URL of the item"""
  url: String!
}

"""the desktop window"""
type DesktopWindow implements FinderWindowInterface & Node & WindowInterface {
  """Does the window have a close box?"""
  closeable: Boolean!

  """Is the window collapsed"""
  collapsed: Boolean!

  """the column view options for the container window"""
  columnViewOptions: ColumnViewOptions!

  """the current view for the container window"""
  currentView: Ecvw!

  """Does the window have a title bar?"""
  floating: Boolean!

  """the icon view options for the container window"""
  iconViewOptions: IconViewOptions!

  """the unique id for this window"""
  id: ID! @extractFromObjectDisplayName

  """the number of the window in the front-to-back layer ordering"""
  index: Int!

  """the list view options for the container window"""
  listViewOptions: ListViewOptions!

  """Is the window modal?"""
  modal: Boolean!

  """the name of the window"""
  name: String!

  """Is the window's path bar visible?"""
  pathbarVisible: Boolean!

  """Is the window resizable?"""
  resizable: Boolean!

  """the width of the sidebar for the container window"""
  sidebarWidth: Int!

  """Is the window's status bar visible?"""
  statusbarVisible: Boolean!

  """the container at which this file viewer is targeted"""
  target: Node!

  """Does the window have a title bar?"""
  titled: Boolean!

  """Is the window's toolbar visible?"""
  toolbarVisible: Boolean!

  """Is the window visible (always true for open Finder windows)?"""
  visible: Boolean!

  """Is the window zoomable?"""
  zoomable: Boolean!

  """Is the window zoomed?"""
  zoomed: Boolean!
}

type DesktopWindowConnection implements Connection {
  byId(id: ID!): DesktopWindow
  edges: [DesktopWindowEdge!]!
  pageInfo: PageInfo!
}

type DesktopWindowEdge implements Edge {
  cursor: String!
  node: DesktopWindow!
}

interface DesktopWindowInterface implements Node {
  """Does the window have a close box?"""
  closeable: Boolean!

  """Is the window collapsed"""
  collapsed: Boolean!

  """the column view options for the container window"""
  columnViewOptions: ColumnViewOptions!

  """the current view for the container window"""
  currentView: Ecvw!

  """Does the window have a title bar?"""
  floating: Boolean!

  """the icon view options for the container window"""
  iconViewOptions: IconViewOptions!

  """the unique id for this window"""
  id: ID! @extractFromObjectDisplayName

  """the number of the window in the front-to-back layer ordering"""
  index: Int!

  """the list view options for the container window"""
  listViewOptions: ListViewOptions!

  """Is the window modal?"""
  modal: Boolean!

  """the name of the window"""
  name: String!

  """Is the window's path bar visible?"""
  pathbarVisible: Boolean!

  """Is the window resizable?"""
  resizable: Boolean!

  """the width of the sidebar for the container window"""
  sidebarWidth: Int!

  """Is the window's status bar visible?"""
  statusbarVisible: Boolean!

  """the container at which this file viewer is targeted"""
  target: Node!

  """Does the window have a title bar?"""
  titled: Boolean!

  """Is the window's toolbar visible?"""
  toolbarVisible: Boolean!

  """Is the window visible (always true for open Finder windows)?"""
  visible: Boolean!

  """Is the window zoomable?"""
  zoomable: Boolean!

  """Is the window zoomed?"""
  zoomed: Boolean!
}

"""A disk"""
type Disk implements ContainerInterface & ItemInterface & Node {
  aliasFiles(after: ID, first: Int, whose: Condition): AliasFileConnection!
  applicationFiles(after: ID, first: Int, whose: Condition): ApplicationFileConnection!
  clippings(after: ID, first: Int, whose: Condition): ClippingConnection!

  """the comment of the item, displayed in the “Get Info” window"""
  comment: String!

  """
  (NOT AVAILABLE YET) Are the container and all of its children opened as outlines? (can only be set for containers viewed as lists)
  """
  completelyExpanded: Boolean!

  """the container of the item"""
  container: Node!

  """the container window for this folder"""
  containerWindow: Node!
  containers(after: ID, first: Int, whose: Condition): ContainerConnection!

  """the date on which the item was created"""
  creationDate: String!

  """a description of the item"""
  description: String!

  """the disk on which the item is stored"""
  disk: Node!

  """the user-visible name of the item"""
  displayedName: String!
  documentFiles(after: ID, first: Int, whose: Condition): DocumentFileConnection!

  """Can the media be ejected (floppies, CDs, and so on)?"""
  ejectable: Boolean!

  """
  the entire contents of the container, including the contents of its children
  """
  entireContents: Node!
  everyonesPrivileges: Priv!

  """
  (NOT AVAILABLE YET) Is the container capable of being expanded as an outline?
  """
  expandable: Boolean!

  """
  (NOT AVAILABLE YET) Is the container opened as an outline? (can only be set for containers viewed as lists)
  """
  expanded: Boolean!

  """Is the item's extension hidden from the user?"""
  extensionHidden: Boolean!
  files(after: ID, first: Int, whose: Condition): FileConnection!
  folders(after: ID, first: Int, whose: Condition): FolderConnection!

  """the filesystem format of this disk"""
  format: Edfm!

  """the user or group that has special access to the container"""
  group: String!
  groupPrivileges: Priv!

  """the icon bitmap of the item"""
  icon: IconFamily!

  """
  the unique id for this disk (unchanged while disk remains connected and Finder remains running)
  """
  id: ID! @extractFromObjectDisplayName

  """Ignore permissions on this disk?"""
  ignorePrivileges: Boolean!

  """the index in the front-to-back ordering within its container"""
  index: Int!

  """the information window for the item"""
  informationWindow: Node!
  internetLocationFiles(after: ID, first: Int, whose: Condition): InternetLocationFileConnection!
  items(after: ID, first: Int, whose: Condition): ItemConnection!

  """Does this disk do file system journaling?"""
  journalingEnabled: Boolean!

  """the kind of the item"""
  kind: String!

  """the label of the item"""
  labelIndex: Int!

  """Is the media a local volume (as opposed to a file server)?"""
  localVolume: Boolean!

  """Is the file locked?"""
  locked: Boolean!

  """the date on which the item was last modified"""
  modificationDate: String!

  """the name of the item"""
  name: String!

  """the name extension of the item (such as “txt”)"""
  nameExtension: String!

  """the user that owns the container"""
  owner: String!
  ownerPrivileges: Priv!
  packages(after: ID, first: Int, whose: Condition): PackageConnection!

  """Is this disk the boot disk?"""
  startup: Boolean!

  """the URL of the item"""
  url: String!
}

type DiskConnection implements Connection {
  byId(id: ID!): Disk
  edges: [DiskEdge!]!
  pageInfo: PageInfo!
}

type DiskEdge implements Edge {
  cursor: String!
  node: Disk!
}

interface DiskInterface implements Node {
  aliasFiles(after: ID, first: Int, whose: Condition): AliasFileConnection!
  applicationFiles(after: ID, first: Int, whose: Condition): ApplicationFileConnection!
  clippings(after: ID, first: Int, whose: Condition): ClippingConnection!

  """the comment of the item, displayed in the “Get Info” window"""
  comment: String!

  """
  (NOT AVAILABLE YET) Are the container and all of its children opened as outlines? (can only be set for containers viewed as lists)
  """
  completelyExpanded: Boolean!

  """the container of the item"""
  container: Node!

  """the container window for this folder"""
  containerWindow: Node!
  containers(after: ID, first: Int, whose: Condition): ContainerConnection!

  """the date on which the item was created"""
  creationDate: String!

  """a description of the item"""
  description: String!

  """the disk on which the item is stored"""
  disk: Node!

  """the user-visible name of the item"""
  displayedName: String!
  documentFiles(after: ID, first: Int, whose: Condition): DocumentFileConnection!

  """Can the media be ejected (floppies, CDs, and so on)?"""
  ejectable: Boolean!

  """
  the entire contents of the container, including the contents of its children
  """
  entireContents: Node!
  everyonesPrivileges: Priv!

  """
  (NOT AVAILABLE YET) Is the container capable of being expanded as an outline?
  """
  expandable: Boolean!

  """
  (NOT AVAILABLE YET) Is the container opened as an outline? (can only be set for containers viewed as lists)
  """
  expanded: Boolean!

  """Is the item's extension hidden from the user?"""
  extensionHidden: Boolean!
  files(after: ID, first: Int, whose: Condition): FileConnection!
  folders(after: ID, first: Int, whose: Condition): FolderConnection!

  """the filesystem format of this disk"""
  format: Edfm!

  """the user or group that has special access to the container"""
  group: String!
  groupPrivileges: Priv!

  """the icon bitmap of the item"""
  icon: IconFamily!

  """
  the unique id for this disk (unchanged while disk remains connected and Finder remains running)
  """
  id: ID! @extractFromObjectDisplayName

  """Ignore permissions on this disk?"""
  ignorePrivileges: Boolean!

  """the index in the front-to-back ordering within its container"""
  index: Int!

  """the information window for the item"""
  informationWindow: Node!
  internetLocationFiles(after: ID, first: Int, whose: Condition): InternetLocationFileConnection!
  items(after: ID, first: Int, whose: Condition): ItemConnection!

  """Does this disk do file system journaling?"""
  journalingEnabled: Boolean!

  """the kind of the item"""
  kind: String!

  """the label of the item"""
  labelIndex: Int!

  """Is the media a local volume (as opposed to a file server)?"""
  localVolume: Boolean!

  """Is the file locked?"""
  locked: Boolean!

  """the date on which the item was last modified"""
  modificationDate: String!

  """the name of the item"""
  name: String!

  """the name extension of the item (such as “txt”)"""
  nameExtension: String!

  """the user that owns the container"""
  owner: String!
  ownerPrivileges: Priv!
  packages(after: ID, first: Int, whose: Condition): PackageConnection!

  """Is this disk the boot disk?"""
  startup: Boolean!

  """the URL of the item"""
  url: String!
}

"""A document file"""
type DocumentFile implements FileInterface & ItemInterface & Node {
  """the comment of the item, displayed in the “Get Info” window"""
  comment: String!

  """the container of the item"""
  container: Node!

  """the date on which the item was created"""
  creationDate: String!

  """a description of the item"""
  description: String!

  """the disk on which the item is stored"""
  disk: Node!

  """the user-visible name of the item"""
  displayedName: String!
  everyonesPrivileges: Priv!

  """Is the item's extension hidden from the user?"""
  extensionHidden: Boolean!

  """the user or group that has special access to the container"""
  group: String!
  groupPrivileges: Priv!

  """the icon bitmap of the item"""
  icon: IconFamily!
  id: ID! @extractFromObjectDisplayName

  """the index in the front-to-back ordering within its container"""
  index: Int!

  """the information window for the item"""
  informationWindow: Node!

  """the kind of the item"""
  kind: String!

  """the label of the item"""
  labelIndex: Int!

  """Is the file locked?"""
  locked: Boolean!

  """the date on which the item was last modified"""
  modificationDate: String!

  """the name of the item"""
  name: String!

  """the name extension of the item (such as “txt”)"""
  nameExtension: String!

  """the user that owns the container"""
  owner: String!
  ownerPrivileges: Priv!

  """
  the version of the product (visible at the top of the “Get Info” window)
  """
  productVersion: String!

  """Is the file a stationery pad?"""
  stationery: Boolean!

  """the URL of the item"""
  url: String!

  """
  the version of the file (visible at the bottom of the “Get Info” window)
  """
  version: String!
}

type DocumentFileConnection implements Connection {
  byId(id: ID!): DocumentFile
  edges: [DocumentFileEdge!]!
  pageInfo: PageInfo!
}

type DocumentFileEdge implements Edge {
  cursor: String!
  node: DocumentFile!
}

interface DocumentFileInterface implements Node {
  """the comment of the item, displayed in the “Get Info” window"""
  comment: String!

  """the container of the item"""
  container: Node!

  """the date on which the item was created"""
  creationDate: String!

  """a description of the item"""
  description: String!

  """the disk on which the item is stored"""
  disk: Node!

  """the user-visible name of the item"""
  displayedName: String!
  everyonesPrivileges: Priv!

  """Is the item's extension hidden from the user?"""
  extensionHidden: Boolean!

  """the user or group that has special access to the container"""
  group: String!
  groupPrivileges: Priv!

  """the icon bitmap of the item"""
  icon: IconFamily!
  id: ID! @extractFromObjectDisplayName

  """the index in the front-to-back ordering within its container"""
  index: Int!

  """the information window for the item"""
  informationWindow: Node!

  """the kind of the item"""
  kind: String!

  """the label of the item"""
  labelIndex: Int!

  """Is the file locked?"""
  locked: Boolean!

  """the date on which the item was last modified"""
  modificationDate: String!

  """the name of the item"""
  name: String!

  """the name extension of the item (such as “txt”)"""
  nameExtension: String!

  """the user that owns the container"""
  owner: String!
  ownerPrivileges: Priv!

  """
  the version of the product (visible at the top of the “Get Info” window)
  """
  productVersion: String!

  """Is the file a stationery pad?"""
  stationery: Boolean!

  """the URL of the item"""
  url: String!

  """
  the version of the file (visible at the bottom of the “Get Info” window)
  """
  version: String!
}

enum Earr {
  ARRANGED_BY_CREATION_DATE
  ARRANGED_BY_KIND
  ARRANGED_BY_LABEL
  ARRANGED_BY_MODIFICATION_DATE
  ARRANGED_BY_NAME
  ARRANGED_BY_SIZE
  NOT_ARRANGED
  SNAP_TO_GRID
}

enum Ecvw {
  COLUMN_VIEW
  FLOW_VIEW
  GROUP_VIEW
  ICON_VIEW
  LIST_VIEW
}

enum Edfm {
  APFS_FORMAT
  APPLESHARE_FORMAT
  APPLE_PHOTO_FORMAT
  AUDIO_FORMAT
  EXFAT_FORMAT
  FTP_FORMAT
  HIGH_SIERRA_FORMAT
  ISO_9660_FORMAT
  MAC_OS_EXTENDED_FORMAT
  MAC_OS_FORMAT
  MSDOS_FORMAT
  NFS_FORMAT
  NTFS_FORMAT
  PACKET_WRITTEN_UDF_FORMAT
  PRODOS_FORMAT
  QUICKTAKE_FORMAT
  SMB_FORMAT
  UDF_FORMAT
  UFS_FORMAT
  UNKNOWN_FORMAT
  WEBDAV_FORMAT
  XSAN_FORMAT
}

interface Edge {
  cursor: String!
  node: Node!
}

enum Elsv {
  COMMENT_COLUMN
  CREATION_DATE_COLUMN
  KIND_COLUMN
  LABEL_COLUMN
  MODIFICATION_DATE_COLUMN
  NAME_COLUMN
  SIZE_COLUMN
  VERSION_COLUMN
}

enum Epos {
  BOTTOM
  RIGHT
}

"""A file"""
type File implements FileInterface & ItemInterface & Node {
  """the comment of the item, displayed in the “Get Info” window"""
  comment: String!

  """the container of the item"""
  container: Node!

  """the date on which the item was created"""
  creationDate: String!

  """a description of the item"""
  description: String!

  """the disk on which the item is stored"""
  disk: Node!

  """the user-visible name of the item"""
  displayedName: String!
  everyonesPrivileges: Priv!

  """Is the item's extension hidden from the user?"""
  extensionHidden: Boolean!

  """the user or group that has special access to the container"""
  group: String!
  groupPrivileges: Priv!

  """the icon bitmap of the item"""
  icon: IconFamily!
  id: ID! @extractFromObjectDisplayName

  """the index in the front-to-back ordering within its container"""
  index: Int!

  """the information window for the item"""
  informationWindow: Node!

  """the kind of the item"""
  kind: String!

  """the label of the item"""
  labelIndex: Int!

  """Is the file locked?"""
  locked: Boolean!

  """the date on which the item was last modified"""
  modificationDate: String!

  """the name of the item"""
  name: String!

  """the name extension of the item (such as “txt”)"""
  nameExtension: String!

  """the user that owns the container"""
  owner: String!
  ownerPrivileges: Priv!

  """
  the version of the product (visible at the top of the “Get Info” window)
  """
  productVersion: String!

  """Is the file a stationery pad?"""
  stationery: Boolean!

  """the URL of the item"""
  url: String!

  """
  the version of the file (visible at the bottom of the “Get Info” window)
  """
  version: String!
}

type FileConnection implements Connection {
  byId(id: ID!): FileInterface
  edges: [FileEdge!]!
  pageInfo: PageInfo!
}

type FileEdge implements Edge {
  cursor: String!
  node: FileInterface!
}

interface FileInterface implements Node {
  """the comment of the item, displayed in the “Get Info” window"""
  comment: String!

  """the container of the item"""
  container: Node!

  """the date on which the item was created"""
  creationDate: String!

  """a description of the item"""
  description: String!

  """the disk on which the item is stored"""
  disk: Node!

  """the user-visible name of the item"""
  displayedName: String!
  everyonesPrivileges: Priv!

  """Is the item's extension hidden from the user?"""
  extensionHidden: Boolean!

  """the user or group that has special access to the container"""
  group: String!
  groupPrivileges: Priv!

  """the icon bitmap of the item"""
  icon: IconFamily!
  id: ID! @extractFromObjectDisplayName

  """the index in the front-to-back ordering within its container"""
  index: Int!

  """the information window for the item"""
  informationWindow: Node!

  """the kind of the item"""
  kind: String!

  """the label of the item"""
  labelIndex: Int!

  """Is the file locked?"""
  locked: Boolean!

  """the date on which the item was last modified"""
  modificationDate: String!

  """the name of the item"""
  name: String!

  """the name extension of the item (such as “txt”)"""
  nameExtension: String!

  """the user that owns the container"""
  owner: String!
  ownerPrivileges: Priv!

  """
  the version of the product (visible at the top of the “Get Info” window)
  """
  productVersion: String!

  """Is the file a stationery pad?"""
  stationery: Boolean!

  """the URL of the item"""
  url: String!

  """
  the version of the file (visible at the bottom of the “Get Info” window)
  """
  version: String!
}

"""A file viewer window"""
type FinderWindow implements FinderWindowInterface & Node & WindowInterface {
  """Does the window have a close box?"""
  closeable: Boolean!

  """Is the window collapsed"""
  collapsed: Boolean!

  """the column view options for the container window"""
  columnViewOptions: ColumnViewOptions!

  """the current view for the container window"""
  currentView: Ecvw!

  """Does the window have a title bar?"""
  floating: Boolean!

  """the icon view options for the container window"""
  iconViewOptions: IconViewOptions!

  """the unique id for this window"""
  id: ID! @extractFromObjectDisplayName

  """the number of the window in the front-to-back layer ordering"""
  index: Int!

  """the list view options for the container window"""
  listViewOptions: ListViewOptions!

  """Is the window modal?"""
  modal: Boolean!

  """the name of the window"""
  name: String!

  """Is the window's path bar visible?"""
  pathbarVisible: Boolean!

  """Is the window resizable?"""
  resizable: Boolean!

  """the width of the sidebar for the container window"""
  sidebarWidth: Int!

  """Is the window's status bar visible?"""
  statusbarVisible: Boolean!

  """the container at which this file viewer is targeted"""
  target: Node!

  """Does the window have a title bar?"""
  titled: Boolean!

  """Is the window's toolbar visible?"""
  toolbarVisible: Boolean!

  """Is the window visible (always true for open Finder windows)?"""
  visible: Boolean!

  """Is the window zoomable?"""
  zoomable: Boolean!

  """Is the window zoomed?"""
  zoomed: Boolean!
}

type FinderWindowConnection implements Connection {
  byId(id: ID!): FinderWindowInterface
  edges: [FinderWindowEdge!]!
  pageInfo: PageInfo!
}

type FinderWindowEdge implements Edge {
  cursor: String!
  node: FinderWindowInterface!
}

interface FinderWindowInterface implements Node {
  """Does the window have a close box?"""
  closeable: Boolean!

  """Is the window collapsed"""
  collapsed: Boolean!

  """the column view options for the container window"""
  columnViewOptions: ColumnViewOptions!

  """the current view for the container window"""
  currentView: Ecvw!

  """Does the window have a title bar?"""
  floating: Boolean!

  """the icon view options for the container window"""
  iconViewOptions: IconViewOptions!

  """the unique id for this window"""
  id: ID! @extractFromObjectDisplayName

  """the number of the window in the front-to-back layer ordering"""
  index: Int!

  """the list view options for the container window"""
  listViewOptions: ListViewOptions!

  """Is the window modal?"""
  modal: Boolean!

  """the name of the window"""
  name: String!

  """Is the window's path bar visible?"""
  pathbarVisible: Boolean!

  """Is the window resizable?"""
  resizable: Boolean!

  """the width of the sidebar for the container window"""
  sidebarWidth: Int!

  """Is the window's status bar visible?"""
  statusbarVisible: Boolean!

  """the container at which this file viewer is targeted"""
  target: Node!

  """Does the window have a title bar?"""
  titled: Boolean!

  """Is the window's toolbar visible?"""
  toolbarVisible: Boolean!

  """Is the window visible (always true for open Finder windows)?"""
  visible: Boolean!

  """Is the window zoomable?"""
  zoomable: Boolean!

  """Is the window zoomed?"""
  zoomed: Boolean!
}

"""A folder"""
type Folder implements ContainerInterface & ItemInterface & Node {
  aliasFiles(after: ID, first: Int, whose: Condition): AliasFileConnection!
  applicationFiles(after: ID, first: Int, whose: Condition): ApplicationFileConnection!
  clippings(after: ID, first: Int, whose: Condition): ClippingConnection!

  """the comment of the item, displayed in the “Get Info” window"""
  comment: String!

  """
  (NOT AVAILABLE YET) Are the container and all of its children opened as outlines? (can only be set for containers viewed as lists)
  """
  completelyExpanded: Boolean!

  """the container of the item"""
  container: Node!

  """the container window for this folder"""
  containerWindow: Node!
  containers(after: ID, first: Int, whose: Condition): ContainerConnection!

  """the date on which the item was created"""
  creationDate: String!

  """a description of the item"""
  description: String!

  """the disk on which the item is stored"""
  disk: Node!

  """the user-visible name of the item"""
  displayedName: String!
  documentFiles(after: ID, first: Int, whose: Condition): DocumentFileConnection!

  """
  the entire contents of the container, including the contents of its children
  """
  entireContents: Node!
  everyonesPrivileges: Priv!

  """
  (NOT AVAILABLE YET) Is the container capable of being expanded as an outline?
  """
  expandable: Boolean!

  """
  (NOT AVAILABLE YET) Is the container opened as an outline? (can only be set for containers viewed as lists)
  """
  expanded: Boolean!

  """Is the item's extension hidden from the user?"""
  extensionHidden: Boolean!
  files(after: ID, first: Int, whose: Condition): FileConnection!
  folders(after: ID, first: Int, whose: Condition): FolderConnection!

  """the user or group that has special access to the container"""
  group: String!
  groupPrivileges: Priv!

  """the icon bitmap of the item"""
  icon: IconFamily!
  id: ID! @extractFromObjectDisplayName

  """the index in the front-to-back ordering within its container"""
  index: Int!

  """the information window for the item"""
  informationWindow: Node!
  internetLocationFiles(after: ID, first: Int, whose: Condition): InternetLocationFileConnection!
  items(after: ID, first: Int, whose: Condition): ItemConnection!

  """the kind of the item"""
  kind: String!

  """the label of the item"""
  labelIndex: Int!

  """Is the file locked?"""
  locked: Boolean!

  """the date on which the item was last modified"""
  modificationDate: String!

  """the name of the item"""
  name: String!

  """the name extension of the item (such as “txt”)"""
  nameExtension: String!

  """the user that owns the container"""
  owner: String!
  ownerPrivileges: Priv!
  packages(after: ID, first: Int, whose: Condition): PackageConnection!

  """the URL of the item"""
  url: String!
}

type FolderConnection implements Connection {
  byId(id: ID!): Folder
  edges: [FolderEdge!]!
  pageInfo: PageInfo!
}

type FolderEdge implements Edge {
  cursor: String!
  node: Folder!
}

interface FolderInterface implements Node {
  aliasFiles(after: ID, first: Int, whose: Condition): AliasFileConnection!
  applicationFiles(after: ID, first: Int, whose: Condition): ApplicationFileConnection!
  clippings(after: ID, first: Int, whose: Condition): ClippingConnection!

  """the comment of the item, displayed in the “Get Info” window"""
  comment: String!

  """
  (NOT AVAILABLE YET) Are the container and all of its children opened as outlines? (can only be set for containers viewed as lists)
  """
  completelyExpanded: Boolean!

  """the container of the item"""
  container: Node!

  """the container window for this folder"""
  containerWindow: Node!
  containers(after: ID, first: Int, whose: Condition): ContainerConnection!

  """the date on which the item was created"""
  creationDate: String!

  """a description of the item"""
  description: String!

  """the disk on which the item is stored"""
  disk: Node!

  """the user-visible name of the item"""
  displayedName: String!
  documentFiles(after: ID, first: Int, whose: Condition): DocumentFileConnection!

  """
  the entire contents of the container, including the contents of its children
  """
  entireContents: Node!
  everyonesPrivileges: Priv!

  """
  (NOT AVAILABLE YET) Is the container capable of being expanded as an outline?
  """
  expandable: Boolean!

  """
  (NOT AVAILABLE YET) Is the container opened as an outline? (can only be set for containers viewed as lists)
  """
  expanded: Boolean!

  """Is the item's extension hidden from the user?"""
  extensionHidden: Boolean!
  files(after: ID, first: Int, whose: Condition): FileConnection!
  folders(after: ID, first: Int, whose: Condition): FolderConnection!

  """the user or group that has special access to the container"""
  group: String!
  groupPrivileges: Priv!

  """the icon bitmap of the item"""
  icon: IconFamily!
  id: ID! @extractFromObjectDisplayName

  """the index in the front-to-back ordering within its container"""
  index: Int!

  """the information window for the item"""
  informationWindow: Node!
  internetLocationFiles(after: ID, first: Int, whose: Condition): InternetLocationFileConnection!
  items(after: ID, first: Int, whose: Condition): ItemConnection!

  """the kind of the item"""
  kind: String!

  """the label of the item"""
  labelIndex: Int!

  """Is the file locked?"""
  locked: Boolean!

  """the date on which the item was last modified"""
  modificationDate: String!

  """the name of the item"""
  name: String!

  """the name extension of the item (such as “txt”)"""
  nameExtension: String!

  """the user that owns the container"""
  owner: String!
  ownerPrivileges: Priv!
  packages(after: ID, first: Int, whose: Condition): PackageConnection!

  """the URL of the item"""
  url: String!
}

"""(NOT AVAILABLE YET) A family of icons"""
type IconFamily implements Node {
  id: ID! @extractFromObjectDisplayName
}

type IconFamilyConnection implements Connection {
  byId(id: ID!): IconFamily
  edges: [IconFamilyEdge!]!
  pageInfo: PageInfo!
}

type IconFamilyEdge implements Edge {
  cursor: String!
  node: IconFamily!
}

interface IconFamilyInterface implements Node {
  id: ID! @extractFromObjectDisplayName
}

"""the icon view options"""
type IconViewOptions implements Node {
  """the property by which to keep icons arranged"""
  arrangement: Earr!

  """the background picture of the icon view"""
  backgroundPicture: File!

  """the size of icons displayed in the icon view"""
  iconSize: Int!
  id: ID! @extractFromObjectDisplayName

  """the location of the label in reference to the icon"""
  labelPosition: Epos!

  """displays a preview of the item in icon view"""
  showsIconPreview: Boolean!

  """additional info about an item displayed in icon view"""
  showsItemInfo: Boolean!

  """the size of the text displayed in the icon view"""
  textSize: Int!
}

type IconViewOptionsConnection implements Connection {
  byId(id: ID!): IconViewOptions
  edges: [IconViewOptionsEdge!]!
  pageInfo: PageInfo!
}

type IconViewOptionsEdge implements Edge {
  cursor: String!
  node: IconViewOptions!
}

interface IconViewOptionsInterface implements Node {
  """the property by which to keep icons arranged"""
  arrangement: Earr!

  """the background picture of the icon view"""
  backgroundPicture: File!

  """the size of icons displayed in the icon view"""
  iconSize: Int!
  id: ID! @extractFromObjectDisplayName

  """the location of the label in reference to the icon"""
  labelPosition: Epos!

  """displays a preview of the item in icon view"""
  showsIconPreview: Boolean!

  """additional info about an item displayed in icon view"""
  showsItemInfo: Boolean!

  """the size of the text displayed in the icon view"""
  textSize: Int!
}

"""An inspector window (opened by “Show Info”)"""
type InformationWindow implements Node & WindowInterface {
  """Does the window have a close box?"""
  closeable: Boolean!

  """Is the window collapsed"""
  collapsed: Boolean!

  """the current panel in the information window"""
  currentPanel: Ipnl!

  """Does the window have a title bar?"""
  floating: Boolean!

  """the unique id for this window"""
  id: ID! @extractFromObjectDisplayName

  """the number of the window in the front-to-back layer ordering"""
  index: Int!

  """the item from which this window was opened"""
  item: Node!

  """Is the window modal?"""
  modal: Boolean!

  """the name of the window"""
  name: String!

  """Is the window resizable?"""
  resizable: Boolean!

  """Does the window have a title bar?"""
  titled: Boolean!

  """Is the window visible (always true for open Finder windows)?"""
  visible: Boolean!

  """Is the window zoomable?"""
  zoomable: Boolean!

  """Is the window zoomed?"""
  zoomed: Boolean!
}

type InformationWindowConnection implements Connection {
  byId(id: ID!): InformationWindow
  edges: [InformationWindowEdge!]!
  pageInfo: PageInfo!
}

type InformationWindowEdge implements Edge {
  cursor: String!
  node: InformationWindow!
}

interface InformationWindowInterface implements Node {
  """Does the window have a close box?"""
  closeable: Boolean!

  """Is the window collapsed"""
  collapsed: Boolean!

  """the current panel in the information window"""
  currentPanel: Ipnl!

  """Does the window have a title bar?"""
  floating: Boolean!

  """the unique id for this window"""
  id: ID! @extractFromObjectDisplayName

  """the number of the window in the front-to-back layer ordering"""
  index: Int!

  """the item from which this window was opened"""
  item: Node!

  """Is the window modal?"""
  modal: Boolean!

  """the name of the window"""
  name: String!

  """Is the window resizable?"""
  resizable: Boolean!

  """Does the window have a title bar?"""
  titled: Boolean!

  """Is the window visible (always true for open Finder windows)?"""
  visible: Boolean!

  """Is the window zoomable?"""
  zoomable: Boolean!

  """Is the window zoomed?"""
  zoomed: Boolean!
}

"""A file containing an internet location"""
type InternetLocationFile implements FileInterface & ItemInterface & Node {
  """the comment of the item, displayed in the “Get Info” window"""
  comment: String!

  """the container of the item"""
  container: Node!

  """the date on which the item was created"""
  creationDate: String!

  """a description of the item"""
  description: String!

  """the disk on which the item is stored"""
  disk: Node!

  """the user-visible name of the item"""
  displayedName: String!
  everyonesPrivileges: Priv!

  """Is the item's extension hidden from the user?"""
  extensionHidden: Boolean!

  """the user or group that has special access to the container"""
  group: String!
  groupPrivileges: Priv!

  """the icon bitmap of the item"""
  icon: IconFamily!
  id: ID! @extractFromObjectDisplayName

  """the index in the front-to-back ordering within its container"""
  index: Int!

  """the information window for the item"""
  informationWindow: Node!

  """the kind of the item"""
  kind: String!

  """the label of the item"""
  labelIndex: Int!

  """the internet location"""
  location: String!

  """Is the file locked?"""
  locked: Boolean!

  """the date on which the item was last modified"""
  modificationDate: String!

  """the name of the item"""
  name: String!

  """the name extension of the item (such as “txt”)"""
  nameExtension: String!

  """the user that owns the container"""
  owner: String!
  ownerPrivileges: Priv!

  """
  the version of the product (visible at the top of the “Get Info” window)
  """
  productVersion: String!

  """Is the file a stationery pad?"""
  stationery: Boolean!

  """the URL of the item"""
  url: String!

  """
  the version of the file (visible at the bottom of the “Get Info” window)
  """
  version: String!
}

type InternetLocationFileConnection implements Connection {
  byId(id: ID!): InternetLocationFile
  edges: [InternetLocationFileEdge!]!
  pageInfo: PageInfo!
}

type InternetLocationFileEdge implements Edge {
  cursor: String!
  node: InternetLocationFile!
}

interface InternetLocationFileInterface implements Node {
  """the comment of the item, displayed in the “Get Info” window"""
  comment: String!

  """the container of the item"""
  container: Node!

  """the date on which the item was created"""
  creationDate: String!

  """a description of the item"""
  description: String!

  """the disk on which the item is stored"""
  disk: Node!

  """the user-visible name of the item"""
  displayedName: String!
  everyonesPrivileges: Priv!

  """Is the item's extension hidden from the user?"""
  extensionHidden: Boolean!

  """the user or group that has special access to the container"""
  group: String!
  groupPrivileges: Priv!

  """the icon bitmap of the item"""
  icon: IconFamily!
  id: ID! @extractFromObjectDisplayName

  """the index in the front-to-back ordering within its container"""
  index: Int!

  """the information window for the item"""
  informationWindow: Node!

  """the kind of the item"""
  kind: String!

  """the label of the item"""
  labelIndex: Int!

  """the internet location"""
  location: String!

  """Is the file locked?"""
  locked: Boolean!

  """the date on which the item was last modified"""
  modificationDate: String!

  """the name of the item"""
  name: String!

  """the name extension of the item (such as “txt”)"""
  nameExtension: String!

  """the user that owns the container"""
  owner: String!
  ownerPrivileges: Priv!

  """
  the version of the product (visible at the top of the “Get Info” window)
  """
  productVersion: String!

  """Is the file a stationery pad?"""
  stationery: Boolean!

  """the URL of the item"""
  url: String!

  """
  the version of the file (visible at the bottom of the “Get Info” window)
  """
  version: String!
}

enum Ipnl {
  APPLICATION_PANEL
  BURNING_PANEL
  COMMENTS_PANEL
  CONTENT_INDEX_PANEL
  GENERAL_INFORMATION_PANEL
  LANGUAGES_PANEL
  MEMORY_PANEL
  MORE_INFO_PANEL
  NAME__AND__EXTENSION_PANEL
  PLUGINS_PANEL
  PREVIEW_PANEL
  SHARING_PANEL
  SIMPLE_HEADER_PANEL
}

"""An item"""
type Item implements ItemInterface & Node {
  """the comment of the item, displayed in the “Get Info” window"""
  comment: String!

  """the container of the item"""
  container: Node!

  """the date on which the item was created"""
  creationDate: String!

  """a description of the item"""
  description: String!

  """the disk on which the item is stored"""
  disk: Node!

  """the user-visible name of the item"""
  displayedName: String!
  everyonesPrivileges: Priv!

  """Is the item's extension hidden from the user?"""
  extensionHidden: Boolean!

  """the user or group that has special access to the container"""
  group: String!
  groupPrivileges: Priv!

  """the icon bitmap of the item"""
  icon: IconFamily!
  id: ID! @extractFromObjectDisplayName

  """the index in the front-to-back ordering within its container"""
  index: Int!

  """the information window for the item"""
  informationWindow: Node!

  """the kind of the item"""
  kind: String!

  """the label of the item"""
  labelIndex: Int!

  """Is the file locked?"""
  locked: Boolean!

  """the date on which the item was last modified"""
  modificationDate: String!

  """the name of the item"""
  name: String!

  """the name extension of the item (such as “txt”)"""
  nameExtension: String!

  """the user that owns the container"""
  owner: String!
  ownerPrivileges: Priv!

  """the URL of the item"""
  url: String!
}

type ItemConnection implements Connection {
  byId(id: ID!): ItemInterface
  edges: [ItemEdge!]!
  pageInfo: PageInfo!
}

type ItemEdge implements Edge {
  cursor: String!
  node: ItemInterface!
}

interface ItemInterface implements Node {
  """the comment of the item, displayed in the “Get Info” window"""
  comment: String!

  """the container of the item"""
  container: Node!

  """the date on which the item was created"""
  creationDate: String!

  """a description of the item"""
  description: String!

  """the disk on which the item is stored"""
  disk: Node!

  """the user-visible name of the item"""
  displayedName: String!
  everyonesPrivileges: Priv!

  """Is the item's extension hidden from the user?"""
  extensionHidden: Boolean!

  """the user or group that has special access to the container"""
  group: String!
  groupPrivileges: Priv!

  """the icon bitmap of the item"""
  icon: IconFamily!
  id: ID! @extractFromObjectDisplayName

  """the index in the front-to-back ordering within its container"""
  index: Int!

  """the information window for the item"""
  informationWindow: Node!

  """the kind of the item"""
  kind: String!

  """the label of the item"""
  labelIndex: Int!

  """Is the file locked?"""
  locked: Boolean!

  """the date on which the item was last modified"""
  modificationDate: String!

  """the name of the item"""
  name: String!

  """the name extension of the item (such as “txt”)"""
  nameExtension: String!

  """the user that owns the container"""
  owner: String!
  ownerPrivileges: Priv!

  """the URL of the item"""
  url: String!
}

"""(NOT AVAILABLE YET) A Finder label (name and color)"""
type Label implements Node {
  id: ID! @extractFromObjectDisplayName

  """the index in the front-to-back ordering within its container"""
  index: Int!

  """the name associated with the label"""
  name: String!
}

type LabelConnection implements Connection {
  byId(id: ID!): Label
  edges: [LabelEdge!]!
  pageInfo: PageInfo!
}

type LabelEdge implements Edge {
  cursor: String!
  node: Label!
}

interface LabelInterface implements Node {
  id: ID! @extractFromObjectDisplayName

  """the index in the front-to-back ordering within its container"""
  index: Int!

  """the name associated with the label"""
  name: String!
}

"""the list view options"""
type ListViewOptions implements Node {
  """Are folder sizes calculated and displayed in the window?"""
  calculatesFolderSizes: Boolean!
  columns(after: ID, first: Int, whose: Condition): ColumnConnection!

  """the size of icons displayed in the list view"""
  iconSize: Lvic!
  id: ID! @extractFromObjectDisplayName

  """displays a preview of the item in list view"""
  showsIconPreview: Boolean!

  """the column that the list view is sorted on"""
  sortColumn: Column!

  """the size of the text displayed in the list view"""
  textSize: Int!

  """Are relative dates (e.g., today, yesterday) shown in the list view?"""
  usesRelativeDates: Boolean!
}

type ListViewOptionsConnection implements Connection {
  byId(id: ID!): ListViewOptions
  edges: [ListViewOptionsEdge!]!
  pageInfo: PageInfo!
}

type ListViewOptionsEdge implements Edge {
  cursor: String!
  node: ListViewOptions!
}

interface ListViewOptionsInterface implements Node {
  """Are folder sizes calculated and displayed in the window?"""
  calculatesFolderSizes: Boolean!
  columns(after: ID, first: Int, whose: Condition): ColumnConnection!

  """the size of icons displayed in the list view"""
  iconSize: Lvic!
  id: ID! @extractFromObjectDisplayName

  """displays a preview of the item in list view"""
  showsIconPreview: Boolean!

  """the column that the list view is sorted on"""
  sortColumn: Column!

  """the size of the text displayed in the list view"""
  textSize: Int!

  """Are relative dates (e.g., today, yesterday) shown in the list view?"""
  usesRelativeDates: Boolean!
}

enum Lvic {
  LARGE_ICON
  SMALL_ICON
}

interface Node {
  id: ID! @extractFromObjectDisplayName
}

"""A package"""
type Package implements ItemInterface & Node {
  """the comment of the item, displayed in the “Get Info” window"""
  comment: String!

  """the container of the item"""
  container: Node!

  """the date on which the item was created"""
  creationDate: String!

  """a description of the item"""
  description: String!

  """the disk on which the item is stored"""
  disk: Node!

  """the user-visible name of the item"""
  displayedName: String!
  everyonesPrivileges: Priv!

  """Is the item's extension hidden from the user?"""
  extensionHidden: Boolean!

  """the user or group that has special access to the container"""
  group: String!
  groupPrivileges: Priv!

  """the icon bitmap of the item"""
  icon: IconFamily!
  id: ID! @extractFromObjectDisplayName

  """the index in the front-to-back ordering within its container"""
  index: Int!

  """the information window for the item"""
  informationWindow: Node!

  """the kind of the item"""
  kind: String!

  """the label of the item"""
  labelIndex: Int!

  """Is the file locked?"""
  locked: Boolean!

  """the date on which the item was last modified"""
  modificationDate: String!

  """the name of the item"""
  name: String!

  """the name extension of the item (such as “txt”)"""
  nameExtension: String!

  """the user that owns the container"""
  owner: String!
  ownerPrivileges: Priv!

  """the URL of the item"""
  url: String!
}

type PackageConnection implements Connection {
  byId(id: ID!): Package
  edges: [PackageEdge!]!
  pageInfo: PageInfo!
}

type PackageEdge implements Edge {
  cursor: String!
  node: Package!
}

interface PackageInterface implements Node {
  """the comment of the item, displayed in the “Get Info” window"""
  comment: String!

  """the container of the item"""
  container: Node!

  """the date on which the item was created"""
  creationDate: String!

  """a description of the item"""
  description: String!

  """the disk on which the item is stored"""
  disk: Node!

  """the user-visible name of the item"""
  displayedName: String!
  everyonesPrivileges: Priv!

  """Is the item's extension hidden from the user?"""
  extensionHidden: Boolean!

  """the user or group that has special access to the container"""
  group: String!
  groupPrivileges: Priv!

  """the icon bitmap of the item"""
  icon: IconFamily!
  id: ID! @extractFromObjectDisplayName

  """the index in the front-to-back ordering within its container"""
  index: Int!

  """the information window for the item"""
  informationWindow: Node!

  """the kind of the item"""
  kind: String!

  """the label of the item"""
  labelIndex: Int!

  """Is the file locked?"""
  locked: Boolean!

  """the date on which the item was last modified"""
  modificationDate: String!

  """the name of the item"""
  name: String!

  """the name extension of the item (such as “txt”)"""
  nameExtension: String!

  """the user that owns the container"""
  owner: String!
  ownerPrivileges: Priv!

  """the URL of the item"""
  url: String!
}

type PageInfo {
  endCursor: String!
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String!
}

enum Pple {
  ADVANCED_PREFERENCES_PANEL
  GENERAL_PREFERENCES_PANEL
  LABEL_PREFERENCES_PANEL
  SIDEBAR_PREFERENCES_PANEL
}

"""The Finder Preferences"""
type Preferences implements Node {
  """Show name extensions, even for items whose “extension hidden” is true?"""
  allNameExtensionsShowing: Boolean!

  """the column view options for all windows"""
  columnViewOptions: ColumnViewOptions!

  """
  the delay before springing open a container in seconds (from 0.167 to 1.169)
  """
  delayBeforeSpringing: Float!

  """Connected servers appear on the desktop?"""
  desktopShowsConnectedServers: Boolean!

  """External hard disks appear on the desktop?"""
  desktopShowsExternalHardDisks: Boolean!

  """Hard disks appear on the desktop?"""
  desktopShowsHardDisks: Boolean!

  """CDs, DVDs, and iPods appear on the desktop?"""
  desktopShowsRemovableMedia: Boolean!

  """Folders open into new tabs?"""
  foldersOpenInNewTabs: Boolean!

  """Folders open into new windows?"""
  foldersOpenInNewWindows: Boolean!

  """Spring open folders after the specified delay?"""
  foldersSpringOpen: Boolean!

  """the default icon view options"""
  iconViewOptions: IconViewOptions!
  id: ID! @extractFromObjectDisplayName

  """the default list view options"""
  listViewOptions: ListViewOptions!

  """target location for a newly-opened Finder window"""
  newWindowTarget: Node!

  """Open new windows in column view?"""
  newWindowsOpenInColumnView: Boolean!

  """the window that would open if Finder preferences was opened"""
  window: PreferencesWindow!
}

type PreferencesConnection implements Connection {
  byId(id: ID!): Preferences
  edges: [PreferencesEdge!]!
  pageInfo: PageInfo!
}

type PreferencesEdge implements Edge {
  cursor: String!
  node: Preferences!
}

interface PreferencesInterface implements Node {
  """Show name extensions, even for items whose “extension hidden” is true?"""
  allNameExtensionsShowing: Boolean!

  """the column view options for all windows"""
  columnViewOptions: ColumnViewOptions!

  """
  the delay before springing open a container in seconds (from 0.167 to 1.169)
  """
  delayBeforeSpringing: Float!

  """Connected servers appear on the desktop?"""
  desktopShowsConnectedServers: Boolean!

  """External hard disks appear on the desktop?"""
  desktopShowsExternalHardDisks: Boolean!

  """Hard disks appear on the desktop?"""
  desktopShowsHardDisks: Boolean!

  """CDs, DVDs, and iPods appear on the desktop?"""
  desktopShowsRemovableMedia: Boolean!

  """Folders open into new tabs?"""
  foldersOpenInNewTabs: Boolean!

  """Folders open into new windows?"""
  foldersOpenInNewWindows: Boolean!

  """Spring open folders after the specified delay?"""
  foldersSpringOpen: Boolean!

  """the default icon view options"""
  iconViewOptions: IconViewOptions!
  id: ID! @extractFromObjectDisplayName

  """the default list view options"""
  listViewOptions: ListViewOptions!

  """target location for a newly-opened Finder window"""
  newWindowTarget: Node!

  """Open new windows in column view?"""
  newWindowsOpenInColumnView: Boolean!

  """the window that would open if Finder preferences was opened"""
  window: PreferencesWindow!
}

"""The Finder Preferences window"""
type PreferencesWindow implements Node & WindowInterface {
  """Does the window have a close box?"""
  closeable: Boolean!

  """Is the window collapsed"""
  collapsed: Boolean!

  """The current panel in the Finder preferences window"""
  currentPanel: Pple!

  """Does the window have a title bar?"""
  floating: Boolean!

  """the unique id for this window"""
  id: ID! @extractFromObjectDisplayName

  """the number of the window in the front-to-back layer ordering"""
  index: Int!

  """Is the window modal?"""
  modal: Boolean!

  """the name of the window"""
  name: String!

  """Is the window resizable?"""
  resizable: Boolean!

  """Does the window have a title bar?"""
  titled: Boolean!

  """Is the window visible (always true for open Finder windows)?"""
  visible: Boolean!

  """Is the window zoomable?"""
  zoomable: Boolean!

  """Is the window zoomed?"""
  zoomed: Boolean!
}

type PreferencesWindowConnection implements Connection {
  byId(id: ID!): PreferencesWindow
  edges: [PreferencesWindowEdge!]!
  pageInfo: PageInfo!
}

type PreferencesWindowEdge implements Edge {
  cursor: String!
  node: PreferencesWindow!
}

interface PreferencesWindowInterface implements Node {
  """Does the window have a close box?"""
  closeable: Boolean!

  """Is the window collapsed"""
  collapsed: Boolean!

  """The current panel in the Finder preferences window"""
  currentPanel: Pple!

  """Does the window have a title bar?"""
  floating: Boolean!

  """the unique id for this window"""
  id: ID! @extractFromObjectDisplayName

  """the number of the window in the front-to-back layer ordering"""
  index: Int!

  """Is the window modal?"""
  modal: Boolean!

  """the name of the window"""
  name: String!

  """Is the window resizable?"""
  resizable: Boolean!

  """Does the window have a title bar?"""
  titled: Boolean!

  """Is the window visible (always true for open Finder windows)?"""
  visible: Boolean!

  """Is the window zoomable?"""
  zoomable: Boolean!

  """Is the window zoomed?"""
  zoomed: Boolean!
}

enum Priv {
  NONE
  READ_ONLY
  READ_WRITE
  WRITE_ONLY
}

"""A process running on this computer"""
type Process implements Node & ProcessInterface {
  """
  Is the process high-level event aware (accepts open application, open document, print document, and quit)?
  """
  acceptsHighLevelEvents: Boolean!

  """Does the process accept remote events?"""
  acceptsRemoteEvents: Boolean!

  """the file from which the process was launched"""
  file: Node!

  """Is the process the frontmost process?"""
  frontmost: Boolean!

  """
  Does the process have a scripting terminology, i.e., can it be scripted?
  """
  hasScriptingTerminology: Boolean!
  id: ID! @extractFromObjectDisplayName

  """the name of the process"""
  name: String!

  """the number of bytes currently used in the process' partition"""
  partitionSpaceUsed: Int!

  """the size of the partition with which the process was launched"""
  totalPartitionSize: Int!

  """Is the process' layer visible?"""
  visible: Boolean!
}

type ProcessConnection implements Connection {
  byId(id: ID!): ProcessInterface
  edges: [ProcessEdge!]!
  pageInfo: PageInfo!
}

type ProcessEdge implements Edge {
  cursor: String!
  node: ProcessInterface!
}

interface ProcessInterface implements Node {
  """
  Is the process high-level event aware (accepts open application, open document, print document, and quit)?
  """
  acceptsHighLevelEvents: Boolean!

  """Does the process accept remote events?"""
  acceptsRemoteEvents: Boolean!

  """the file from which the process was launched"""
  file: Node!

  """Is the process the frontmost process?"""
  frontmost: Boolean!

  """
  Does the process have a scripting terminology, i.e., can it be scripted?
  """
  hasScriptingTerminology: Boolean!
  id: ID! @extractFromObjectDisplayName

  """the name of the process"""
  name: String!

  """the number of bytes currently used in the process' partition"""
  partitionSpaceUsed: Int!

  """the size of the partition with which the process was launched"""
  totalPartitionSize: Int!

  """Is the process' layer visible?"""
  visible: Boolean!
}

type Query {
  application: Application!
}

enum Sodr {
  NORMAL
  REVERSED
}

"""Trash-object is the class of the “trash” object"""
type TrashObject implements ContainerInterface & ItemInterface & Node {
  aliasFiles(after: ID, first: Int, whose: Condition): AliasFileConnection!
  applicationFiles(after: ID, first: Int, whose: Condition): ApplicationFileConnection!
  clippings(after: ID, first: Int, whose: Condition): ClippingConnection!

  """the comment of the item, displayed in the “Get Info” window"""
  comment: String!

  """
  (NOT AVAILABLE YET) Are the container and all of its children opened as outlines? (can only be set for containers viewed as lists)
  """
  completelyExpanded: Boolean!

  """the container of the item"""
  container: Node!

  """the container window for this folder"""
  containerWindow: Node!
  containers(after: ID, first: Int, whose: Condition): ContainerConnection!

  """the date on which the item was created"""
  creationDate: String!

  """a description of the item"""
  description: String!

  """the disk on which the item is stored"""
  disk: Node!

  """the user-visible name of the item"""
  displayedName: String!
  documentFiles(after: ID, first: Int, whose: Condition): DocumentFileConnection!

  """
  the entire contents of the container, including the contents of its children
  """
  entireContents: Node!
  everyonesPrivileges: Priv!

  """
  (NOT AVAILABLE YET) Is the container capable of being expanded as an outline?
  """
  expandable: Boolean!

  """
  (NOT AVAILABLE YET) Is the container opened as an outline? (can only be set for containers viewed as lists)
  """
  expanded: Boolean!

  """Is the item's extension hidden from the user?"""
  extensionHidden: Boolean!
  files(after: ID, first: Int, whose: Condition): FileConnection!
  folders(after: ID, first: Int, whose: Condition): FolderConnection!

  """the user or group that has special access to the container"""
  group: String!
  groupPrivileges: Priv!

  """the icon bitmap of the item"""
  icon: IconFamily!
  id: ID! @extractFromObjectDisplayName

  """the index in the front-to-back ordering within its container"""
  index: Int!

  """the information window for the item"""
  informationWindow: Node!
  internetLocationFiles(after: ID, first: Int, whose: Condition): InternetLocationFileConnection!
  items(after: ID, first: Int, whose: Condition): ItemConnection!

  """the kind of the item"""
  kind: String!

  """the label of the item"""
  labelIndex: Int!

  """Is the file locked?"""
  locked: Boolean!

  """the date on which the item was last modified"""
  modificationDate: String!

  """the name of the item"""
  name: String!

  """the name extension of the item (such as “txt”)"""
  nameExtension: String!

  """the user that owns the container"""
  owner: String!
  ownerPrivileges: Priv!
  packages(after: ID, first: Int, whose: Condition): PackageConnection!

  """the URL of the item"""
  url: String!

  """Display a dialog when emptying the trash?"""
  warnsBeforeEmptying: Boolean!
}

type TrashObjectConnection implements Connection {
  byId(id: ID!): TrashObject
  edges: [TrashObjectEdge!]!
  pageInfo: PageInfo!
}

type TrashObjectEdge implements Edge {
  cursor: String!
  node: TrashObject!
}

interface TrashObjectInterface implements Node {
  aliasFiles(after: ID, first: Int, whose: Condition): AliasFileConnection!
  applicationFiles(after: ID, first: Int, whose: Condition): ApplicationFileConnection!
  clippings(after: ID, first: Int, whose: Condition): ClippingConnection!

  """the comment of the item, displayed in the “Get Info” window"""
  comment: String!

  """
  (NOT AVAILABLE YET) Are the container and all of its children opened as outlines? (can only be set for containers viewed as lists)
  """
  completelyExpanded: Boolean!

  """the container of the item"""
  container: Node!

  """the container window for this folder"""
  containerWindow: Node!
  containers(after: ID, first: Int, whose: Condition): ContainerConnection!

  """the date on which the item was created"""
  creationDate: String!

  """a description of the item"""
  description: String!

  """the disk on which the item is stored"""
  disk: Node!

  """the user-visible name of the item"""
  displayedName: String!
  documentFiles(after: ID, first: Int, whose: Condition): DocumentFileConnection!

  """
  the entire contents of the container, including the contents of its children
  """
  entireContents: Node!
  everyonesPrivileges: Priv!

  """
  (NOT AVAILABLE YET) Is the container capable of being expanded as an outline?
  """
  expandable: Boolean!

  """
  (NOT AVAILABLE YET) Is the container opened as an outline? (can only be set for containers viewed as lists)
  """
  expanded: Boolean!

  """Is the item's extension hidden from the user?"""
  extensionHidden: Boolean!
  files(after: ID, first: Int, whose: Condition): FileConnection!
  folders(after: ID, first: Int, whose: Condition): FolderConnection!

  """the user or group that has special access to the container"""
  group: String!
  groupPrivileges: Priv!

  """the icon bitmap of the item"""
  icon: IconFamily!
  id: ID! @extractFromObjectDisplayName

  """the index in the front-to-back ordering within its container"""
  index: Int!

  """the information window for the item"""
  informationWindow: Node!
  internetLocationFiles(after: ID, first: Int, whose: Condition): InternetLocationFileConnection!
  items(after: ID, first: Int, whose: Condition): ItemConnection!

  """the kind of the item"""
  kind: String!

  """the label of the item"""
  labelIndex: Int!

  """Is the file locked?"""
  locked: Boolean!

  """the date on which the item was last modified"""
  modificationDate: String!

  """the name of the item"""
  name: String!

  """the name extension of the item (such as “txt”)"""
  nameExtension: String!

  """the user that owns the container"""
  owner: String!
  ownerPrivileges: Priv!
  packages(after: ID, first: Int, whose: Condition): PackageConnection!

  """the URL of the item"""
  url: String!

  """Display a dialog when emptying the trash?"""
  warnsBeforeEmptying: Boolean!
}

"""A window"""
type Window implements Node & WindowInterface {
  """Does the window have a close box?"""
  closeable: Boolean!

  """Is the window collapsed"""
  collapsed: Boolean!

  """Does the window have a title bar?"""
  floating: Boolean!

  """the unique id for this window"""
  id: ID! @extractFromObjectDisplayName

  """the number of the window in the front-to-back layer ordering"""
  index: Int!

  """Is the window modal?"""
  modal: Boolean!

  """the name of the window"""
  name: String!

  """Is the window resizable?"""
  resizable: Boolean!

  """Does the window have a title bar?"""
  titled: Boolean!

  """Is the window visible (always true for open Finder windows)?"""
  visible: Boolean!

  """Is the window zoomable?"""
  zoomable: Boolean!

  """Is the window zoomed?"""
  zoomed: Boolean!
}

type WindowConnection implements Connection {
  byId(id: ID!): WindowInterface
  edges: [WindowEdge!]!
  pageInfo: PageInfo!
}

type WindowEdge implements Edge {
  cursor: String!
  node: WindowInterface!
}

interface WindowInterface implements Node {
  """Does the window have a close box?"""
  closeable: Boolean!

  """Is the window collapsed"""
  collapsed: Boolean!

  """Does the window have a title bar?"""
  floating: Boolean!

  """the unique id for this window"""
  id: ID! @extractFromObjectDisplayName

  """the number of the window in the front-to-back layer ordering"""
  index: Int!

  """Is the window modal?"""
  modal: Boolean!

  """the name of the window"""
  name: String!

  """Is the window resizable?"""
  resizable: Boolean!

  """Does the window have a title bar?"""
  titled: Boolean!

  """Is the window visible (always true for open Finder windows)?"""
  visible: Boolean!

  """Is the window zoomable?"""
  zoomable: Boolean!

  """Is the window zoomed?"""
  zoomed: Boolean!
}
`;

exports[`build - OmniFocus: omnifocus.graphql 1`] = `
directive @extractFromObjectDisplayName on FIELD_DEFINITION

directive @recordType on OBJECT

"""The ancestor trees of this tree."""
type AncestorTree implements Node & TreeInterface {
  """The ancestor trees of this tree."""
  ancestorTrees(after: ID, first: Int, whose: Condition): AncestorTreeConnection!

  """
  All the descendant trees in the user-specified sort ordering, listing each tree, then its children and so forth.
  """
  descendantTrees(after: ID, first: Int, whose: Condition): DescendantTreeConnection!

  """This is true if the node is expanded."""
  expanded: Boolean!

  """
  The sibling trees of this tree after it in the user-specified sort ordering.
  """
  followingSiblings(after: ID, first: Int, whose: Condition): FollowingSiblingConnection!

  """The identifier of object being represented by this tree."""
  id: ID! @extractFromObjectDisplayName

  """The descendants of this tree that have no children themselves."""
  leafs(after: ID, first: Int, whose: Condition): LeafConnection!

  """The name of the object being represented by this tree."""
  name: String!

  """This is true if the node note is expanded."""
  noteExpanded: Boolean!

  """
  The sibling trees of this tree before it in the user-specified sort ordering.
  """
  precedingSiblings(after: ID, first: Int, whose: Condition): PrecedingSiblingConnection!

  """
  This is true if the node is selected.  Note that attempts to set this while the node is not visible (collapsed parent, etc.) will silently do nothing.
  """
  selected: Boolean!

  """The trees of this tree that are selected in the user interface."""
  selectedTrees(after: ID, first: Int, whose: Condition): SelectedTreeConnection!

  """
  The immediate child trees of this tree in the user-specified sort ordering.
  """
  trees(after: ID, first: Int, whose: Condition): TreeConnection!
}

type AncestorTreeConnection implements Connection {
  byId(id: ID!): AncestorTree
  edges: [AncestorTreeEdge!]!
  pageInfo: PageInfo!
}

type AncestorTreeEdge implements Edge {
  cursor: String!
  node: AncestorTree!
}

interface AncestorTreeInterface implements Node {
  """The ancestor trees of this tree."""
  ancestorTrees(after: ID, first: Int, whose: Condition): AncestorTreeConnection!

  """
  All the descendant trees in the user-specified sort ordering, listing each tree, then its children and so forth.
  """
  descendantTrees(after: ID, first: Int, whose: Condition): DescendantTreeConnection!

  """This is true if the node is expanded."""
  expanded: Boolean!

  """
  The sibling trees of this tree after it in the user-specified sort ordering.
  """
  followingSiblings(after: ID, first: Int, whose: Condition): FollowingSiblingConnection!

  """The identifier of object being represented by this tree."""
  id: ID! @extractFromObjectDisplayName

  """The descendants of this tree that have no children themselves."""
  leafs(after: ID, first: Int, whose: Condition): LeafConnection!

  """The name of the object being represented by this tree."""
  name: String!

  """This is true if the node note is expanded."""
  noteExpanded: Boolean!

  """
  The sibling trees of this tree before it in the user-specified sort ordering.
  """
  precedingSiblings(after: ID, first: Int, whose: Condition): PrecedingSiblingConnection!

  """
  This is true if the node is selected.  Note that attempts to set this while the node is not visible (collapsed parent, etc.) will silently do nothing.
  """
  selected: Boolean!

  """The trees of this tree that are selected in the user interface."""
  selectedTrees(after: ID, first: Int, whose: Condition): SelectedTreeConnection!

  """
  The immediate child trees of this tree in the user-specified sort ordering.
  """
  trees(after: ID, first: Int, whose: Condition): TreeConnection!
}

"""The application's top-level scripting object."""
type Application implements Node {
  """
  This is the build number of the application, for example 63.1 or 63.  Major and minor versions are separated by a dot.  So 63.10 comes after 63.1.
  """
  buildNumber: String!

  """
  The current time offset from a reference date. Useful for timing scripts.
  """
  currentTimeOffset: Float!

  """The user's default document."""
  defaultDocument: Document!
  documents(after: ID, first: Int, whose: Condition): DocumentConnection!

  """Is this the active application?"""
  frontmost: Boolean!
  id: ID! @extractFromObjectDisplayName

  """The name of the application."""
  name: String!

  """The names of all available perspectives in the default document."""
  perspectiveNames: [String!]!
  perspectives(after: ID, first: Int, whose: Condition): PerspectiveConnection!
  preferences(after: ID, first: Int, whose: Condition): PreferenceConnection!

  """The Quick Entry panel for the default document."""
  quickEntry: QuickEntryTree!

  """
  The date on from which the date collated smart groups are based.  When set, the reference date will be rounded to the first instant of the day of the specified date.
  """
  referenceDate: String!

  """The version number of the application."""
  version: String!
  windows(after: ID, first: Int, whose: Condition): WindowConnection!
}

type ApplicationConnection implements Connection {
  byId(id: ID!): Application
  edges: [ApplicationEdge!]!
  pageInfo: PageInfo!
}

type ApplicationEdge implements Edge {
  cursor: String!
  node: Application!
}

interface ApplicationInterface implements Node {
  documents(after: ID, first: Int, whose: Condition): DocumentConnection!

  """Is this the active application?"""
  frontmost: Boolean!
  id: ID! @extractFromObjectDisplayName

  """The name of the application."""
  name: String!

  """The version number of the application."""
  version: String!
  windows(after: ID, first: Int, whose: Condition): WindowConnection!
}

"""Represents an inline text attachment."""
type Attachment implements AttachmentInterface & Node {
  attachments(after: ID, first: Int, whose: Condition): AttachmentConnection!
  attributeRuns(after: ID, first: Int, whose: Condition): AttributeRunConnection!
  characters(after: ID, first: Int, whose: Condition): CharacterConnection!
  fileAttachments(after: ID, first: Int, whose: Condition): FileAttachmentConnection!

  """The name of the font of the first character."""
  font: String!
  id: ID! @extractFromObjectDisplayName
  paragraphs(after: ID, first: Int, whose: Condition): ParagraphConnection!

  """The size in points of the first character."""
  size: Int!

  """The style of the text."""
  style: Style!

  """The plain text contents of the rich text."""
  text: String!
  words(after: ID, first: Int, whose: Condition): WordConnection!
}

type AttachmentConnection implements Connection {
  byId(id: ID!): AttachmentInterface
  edges: [AttachmentEdge!]!
  pageInfo: PageInfo!
}

type AttachmentEdge implements Edge {
  cursor: String!
  node: AttachmentInterface!
}

interface AttachmentInterface implements Node {
  attachments(after: ID, first: Int, whose: Condition): AttachmentConnection!
  attributeRuns(after: ID, first: Int, whose: Condition): AttributeRunConnection!
  characters(after: ID, first: Int, whose: Condition): CharacterConnection!
  fileAttachments(after: ID, first: Int, whose: Condition): FileAttachmentConnection!

  """The name of the font of the first character."""
  font: String!
  id: ID! @extractFromObjectDisplayName
  paragraphs(after: ID, first: Int, whose: Condition): ParagraphConnection!

  """The size in points of the first character."""
  size: Int!

  """The style of the text."""
  style: Style!

  """The plain text contents of the rich text."""
  text: String!
  words(after: ID, first: Int, whose: Condition): WordConnection!
}

"""An attribute of a style."""
type Attribute implements Node {
  """
  The style responsible for the effective value in this attributes's style.  This processes the local values, inherited styles and cascade chain.
  """
  definingStyle: Style!

  """
  If true, the containing style defines a local value for this attribute.
  """
  hasLocalValue: Boolean!
  id: ID! @extractFromObjectDisplayName

  """The name of the attribute."""
  name: String!

  """The style to which the attribute refers."""
  style: Style!
}

type AttributeConnection implements Connection {
  byId(id: ID!): Attribute
  edges: [AttributeEdge!]!
  pageInfo: PageInfo!
}

type AttributeEdge implements Edge {
  cursor: String!
  node: Attribute!
}

interface AttributeInterface implements Node {
  """
  The style responsible for the effective value in this attributes's style.  This processes the local values, inherited styles and cascade chain.
  """
  definingStyle: Style!

  """
  If true, the containing style defines a local value for this attribute.
  """
  hasLocalValue: Boolean!
  id: ID! @extractFromObjectDisplayName

  """The name of the attribute."""
  name: String!

  """The style to which the attribute refers."""
  style: Style!
}

"""
This subdivides the text into chunks that all have the same attributes.
"""
type AttributeRun implements Node {
  attachments(after: ID, first: Int, whose: Condition): AttachmentConnection!
  attributeRuns(after: ID, first: Int, whose: Condition): AttributeRunConnection!
  characters(after: ID, first: Int, whose: Condition): CharacterConnection!
  fileAttachments(after: ID, first: Int, whose: Condition): FileAttachmentConnection!

  """The name of the font of the first character."""
  font: String!
  id: ID! @extractFromObjectDisplayName
  paragraphs(after: ID, first: Int, whose: Condition): ParagraphConnection!

  """The size in points of the first character."""
  size: Int!

  """The style of the text."""
  style: Style!

  """The plain text contents of the rich text."""
  text: String!
  words(after: ID, first: Int, whose: Condition): WordConnection!
}

type AttributeRunConnection implements Connection {
  byId(id: ID!): AttributeRun
  edges: [AttributeRunEdge!]!
  pageInfo: PageInfo!
}

type AttributeRunEdge implements Edge {
  cursor: String!
  node: AttributeRun!
}

interface AttributeRunInterface implements Node {
  attachments(after: ID, first: Int, whose: Condition): AttachmentConnection!
  attributeRuns(after: ID, first: Int, whose: Condition): AttributeRunConnection!
  characters(after: ID, first: Int, whose: Condition): CharacterConnection!
  fileAttachments(after: ID, first: Int, whose: Condition): FileAttachmentConnection!

  """The name of the font of the first character."""
  font: String!
  id: ID! @extractFromObjectDisplayName
  paragraphs(after: ID, first: Int, whose: Condition): ParagraphConnection!

  """The size in points of the first character."""
  size: Int!

  """The style of the text."""
  style: Style!

  """The plain text contents of the rich text."""
  text: String!
  words(after: ID, first: Int, whose: Condition): WordConnection!
}

"""
A task that is available for action.  This is simply a filter on the existing tasks and should be considred a read-only element.  These cannot be created directly; instead create a normal task.
"""
type AvailableTask implements Node & TaskInterface {
  """
  True if the task has a task that must be completed prior to it being actionable.
  """
  blocked: Boolean!

  """
  True if the task is completed. Use the "mark complete" and "mark incomplete" commands to change a task's status.
  """
  completed: Boolean!

  """If true, complete when children are completed."""
  completedByChildren: Boolean!

  """
  The task's date of completion. This can only be modified on a completed task to backdate the completion date.
  """
  completionDate: String

  """
  The task's project, up however many levels of parent tasks.  Inbox tasks aren't considered contained by their provisionalliy assigned container, so if the task is actually an inbox task, this will be missing value.
  """
  containingProject: Project

  """
  When the task was created.  This can only be set when the object is still in the inserted state.  For objects created in the document, it can be passed with the creation properties.  For objects in a quick entry tree, it can be set until the quick entry panel is saved.
  """
  creationDate: String!

  """When the task should become available for action."""
  deferDate: String

  """
  True if the task is dropped. Use the "mark dropped" and "mark incomplete" commands to change a task's status.
  """
  dropped: Boolean!

  """
  The date the task was dropped. This can only be modified on a dropped task to backdate the dropped date.
  """
  droppedDate: String

  """When the task must be finished."""
  dueDate: String

  """
  When the task should become available for action (including inherited).
  """
  effectiveDeferDate: String

  """When the task must be finished (including inherited)."""
  effectiveDueDate: String

  """
  True if the task is completed, or any of it's containing tasks or project are completed.
  """
  effectivelyCompleted: Boolean!

  """
  True if the task is dropped, or any of it's containing tasks or project are dropped.
  """
  effectivelyDropped: Boolean!

  """
  The estimated time, in whole minutes, that this task will take to finish.
  """
  estimatedMinutes: Int

  """True if flagged"""
  flagged: Boolean!
  flattenedTasks(after: ID, first: Int, whose: Condition): FlattenedTaskConnection!

  """The identifier of the task."""
  id: ID! @extractFromObjectDisplayName

  """
  Returns true if the task itself is an inbox task or if the task is contained by an inbox task.
  """
  inInbox: Boolean!

  """When the task was last modified."""
  modificationDate: String!

  """The name of the task."""
  name: String!

  """If the task is the next task of its containing project, next is true."""
  next: Boolean!

  """
  The next defer date if this task repeats on a fixed schedule and it has a defer date.
  """
  nextDeferDate: String

  """
  The next due date if this task repeats on a fixed schedule and it has a due date.
  """
  nextDueDate: String

  """The note of the task."""
  note: RichText!

  """The number of available direct children of this task."""
  numberOfAvailableTasks: Int!

  """The number of completed direct children of this task."""
  numberOfCompletedTasks: Int!

  """The number of direct children of this task."""
  numberOfTasks: Int!

  """
  The task holding this task.  If this is missing value, then this is a top level task -- either the root of a project or an inbox item.
  """
  parentTask: Task

  """
  The task's first tag. Setting this will remove the current first tag on the task, if any and move or add the new tag as the first tag on the task. Setting this to missing value will remove the current first tag and leave any other remaining tags.
  """
  primaryTag: Tag

  """
  The repetition interval of the task, or missing value if it does not repeat. This property is deprecated in favor of “repetition rule” and is here only for backwards compatibility with existing scripts.
  """
  repetition: RepetitionInterval

  """
  The repetition rule for this task, or missing value if it does not repeat.
  """
  repetitionRule: RepetitionRule

  """If true, any children are sequentially dependent."""
  sequential: Boolean!

  """
  When set, the due date and defer date properties will use floating time zones. (Note: if a Task has no due or defer dates assigned, this property will revert to the database’s default setting.)
  """
  shouldUseFloatingTimeZone: Boolean!

  """The tags assigned to this task."""
  tags(after: ID, first: Int, whose: Condition): TagConnection!

  """The tasks having this task as their container."""
  tasks(after: ID, first: Int, whose: Condition): TaskConnection!
}

type AvailableTaskConnection implements Connection {
  byId(id: ID!): AvailableTask
  edges: [AvailableTaskEdge!]!
  pageInfo: PageInfo!
}

type AvailableTaskEdge implements Edge {
  cursor: String!
  node: AvailableTask!
}

interface AvailableTaskInterface implements Node {
  """
  True if the task has a task that must be completed prior to it being actionable.
  """
  blocked: Boolean!

  """
  True if the task is completed. Use the "mark complete" and "mark incomplete" commands to change a task's status.
  """
  completed: Boolean!

  """If true, complete when children are completed."""
  completedByChildren: Boolean!

  """
  The task's date of completion. This can only be modified on a completed task to backdate the completion date.
  """
  completionDate: String

  """
  The task's project, up however many levels of parent tasks.  Inbox tasks aren't considered contained by their provisionalliy assigned container, so if the task is actually an inbox task, this will be missing value.
  """
  containingProject: Project

  """
  When the task was created.  This can only be set when the object is still in the inserted state.  For objects created in the document, it can be passed with the creation properties.  For objects in a quick entry tree, it can be set until the quick entry panel is saved.
  """
  creationDate: String!

  """When the task should become available for action."""
  deferDate: String

  """
  True if the task is dropped. Use the "mark dropped" and "mark incomplete" commands to change a task's status.
  """
  dropped: Boolean!

  """
  The date the task was dropped. This can only be modified on a dropped task to backdate the dropped date.
  """
  droppedDate: String

  """When the task must be finished."""
  dueDate: String

  """
  When the task should become available for action (including inherited).
  """
  effectiveDeferDate: String

  """When the task must be finished (including inherited)."""
  effectiveDueDate: String

  """
  True if the task is completed, or any of it's containing tasks or project are completed.
  """
  effectivelyCompleted: Boolean!

  """
  True if the task is dropped, or any of it's containing tasks or project are dropped.
  """
  effectivelyDropped: Boolean!

  """
  The estimated time, in whole minutes, that this task will take to finish.
  """
  estimatedMinutes: Int

  """True if flagged"""
  flagged: Boolean!
  flattenedTasks(after: ID, first: Int, whose: Condition): FlattenedTaskConnection!

  """The identifier of the task."""
  id: ID! @extractFromObjectDisplayName

  """
  Returns true if the task itself is an inbox task or if the task is contained by an inbox task.
  """
  inInbox: Boolean!

  """When the task was last modified."""
  modificationDate: String!

  """The name of the task."""
  name: String!

  """If the task is the next task of its containing project, next is true."""
  next: Boolean!

  """
  The next defer date if this task repeats on a fixed schedule and it has a defer date.
  """
  nextDeferDate: String

  """
  The next due date if this task repeats on a fixed schedule and it has a due date.
  """
  nextDueDate: String

  """The note of the task."""
  note: RichText!

  """The number of available direct children of this task."""
  numberOfAvailableTasks: Int!

  """The number of completed direct children of this task."""
  numberOfCompletedTasks: Int!

  """The number of direct children of this task."""
  numberOfTasks: Int!

  """
  The task holding this task.  If this is missing value, then this is a top level task -- either the root of a project or an inbox item.
  """
  parentTask: Task

  """
  The task's first tag. Setting this will remove the current first tag on the task, if any and move or add the new tag as the first tag on the task. Setting this to missing value will remove the current first tag and leave any other remaining tags.
  """
  primaryTag: Tag

  """
  The repetition interval of the task, or missing value if it does not repeat. This property is deprecated in favor of “repetition rule” and is here only for backwards compatibility with existing scripts.
  """
  repetition: RepetitionInterval

  """
  The repetition rule for this task, or missing value if it does not repeat.
  """
  repetitionRule: RepetitionRule

  """If true, any children are sequentially dependent."""
  sequential: Boolean!

  """
  When set, the due date and defer date properties will use floating time zones. (Note: if a Task has no due or defer dates assigned, this property will revert to the database’s default setting.)
  """
  shouldUseFloatingTimeZone: Boolean!

  """The tags assigned to this task."""
  tags(after: ID, first: Int, whose: Condition): TagConnection!

  """The tasks having this task as their container."""
  tasks(after: ID, first: Int, whose: Condition): TaskConnection!
}

"""A built-in perspective."""
type BuiltinPerspective implements Node & PerspectiveInterface {
  """The identifier of the perspective."""
  id: ID! @extractFromObjectDisplayName

  """The name of the perspective."""
  name: String!
}

type BuiltinPerspectiveConnection implements Connection {
  byId(id: ID!): BuiltinPerspective
  edges: [BuiltinPerspectiveEdge!]!
  pageInfo: PageInfo!
}

type BuiltinPerspectiveEdge implements Edge {
  cursor: String!
  node: BuiltinPerspective!
}

interface BuiltinPerspectiveInterface implements Node {
  """The identifier of the perspective."""
  id: ID! @extractFromObjectDisplayName

  """The name of the perspective."""
  name: String!
}

"""This subdivides the text into characters."""
type Character implements Node {
  attachments(after: ID, first: Int, whose: Condition): AttachmentConnection!
  attributeRuns(after: ID, first: Int, whose: Condition): AttributeRunConnection!
  characters(after: ID, first: Int, whose: Condition): CharacterConnection!
  fileAttachments(after: ID, first: Int, whose: Condition): FileAttachmentConnection!

  """The name of the font of the first character."""
  font: String!
  id: ID! @extractFromObjectDisplayName
  paragraphs(after: ID, first: Int, whose: Condition): ParagraphConnection!

  """The size in points of the first character."""
  size: Int!

  """The style of the text."""
  style: Style!

  """The plain text contents of the rich text."""
  text: String!
  words(after: ID, first: Int, whose: Condition): WordConnection!
}

type CharacterConnection implements Connection {
  byId(id: ID!): Character
  edges: [CharacterEdge!]!
  pageInfo: PageInfo!
}

type CharacterEdge implements Edge {
  cursor: String!
  node: Character!
}

interface CharacterInterface implements Node {
  attachments(after: ID, first: Int, whose: Condition): AttachmentConnection!
  attributeRuns(after: ID, first: Int, whose: Condition): AttributeRunConnection!
  characters(after: ID, first: Int, whose: Condition): CharacterConnection!
  fileAttachments(after: ID, first: Int, whose: Condition): FileAttachmentConnection!

  """The name of the font of the first character."""
  font: String!
  id: ID! @extractFromObjectDisplayName
  paragraphs(after: ID, first: Int, whose: Condition): ParagraphConnection!

  """The size in points of the first character."""
  size: Int!

  """The style of the text."""
  style: Style!

  """The plain text contents of the rich text."""
  text: String!
  words(after: ID, first: Int, whose: Condition): WordConnection!
}

input Condition {
  enabled: Boolean! = true
  field: String
  operands: [Condition!]
  operator: String! = "="
  value: String! = "true"
}

interface Connection {
  byId(id: ID!): Node
  edges: [Edge!]!
  pageInfo: PageInfo!
}

"""The tree of objects in the main window content."""
type ContentTree implements Node & TreeInterface {
  """The ancestor trees of this tree."""
  ancestorTrees(after: ID, first: Int, whose: Condition): AncestorTreeConnection!

  """
  The list of possible identifiers that can be set as the selected grouping identifier.
  """
  availableGroupingIdentifiers: [String!]!

  """
  The list of possible identifiers that can be set as the selected sorting identifier.
  """
  availableSortingIdentifiers: [String!]!

  """
  The list of possible identifiers that can be set as the selected task duration filter identifier.
  """
  availableTaskDurationFilterIdentifiers: [String!]!

  """
  The list of possible identifiers that can be set as the selected task flagged filter identifier.
  """
  availableTaskFlaggedFilterIdentifiers: [String!]!

  """
  The list of possible identifiers that can be set as the selected task state filter identifier.
  """
  availableTaskStateFilterIdentifiers: [String!]!

  """
  All the descendant trees in the user-specified sort ordering, listing each tree, then its children and so forth.
  """
  descendantTrees(after: ID, first: Int, whose: Condition): DescendantTreeConnection!

  """This is true if the node is expanded."""
  expanded: Boolean!

  """
  The sibling trees of this tree after it in the user-specified sort ordering.
  """
  followingSiblings(after: ID, first: Int, whose: Condition): FollowingSiblingConnection!

  """The identifier of object being represented by this tree."""
  id: ID! @extractFromObjectDisplayName

  """The descendants of this tree that have no children themselves."""
  leafs(after: ID, first: Int, whose: Condition): LeafConnection!

  """The name of the object being represented by this tree."""
  name: String!

  """This is true if the node note is expanded."""
  noteExpanded: Boolean!

  """
  The sibling trees of this tree before it in the user-specified sort ordering.
  """
  precedingSiblings(after: ID, first: Int, whose: Condition): PrecedingSiblingConnection!

  """
  This is true if the node is selected.  Note that attempts to set this while the node is not visible (collapsed parent, etc.) will silently do nothing.
  """
  selected: Boolean!

  """
  The currently selected grouping identifier, controlling how the results shown in the content area are grouped.
  """
  selectedGroupingIdentifier: String!

  """
  The currently selected sorting identifier, controlling how the results shown in the content area are ordered.
  """
  selectedSortingIdentifier: String!

  """The currently selected task duration filter identifier."""
  selectedTaskDurationFilterIdentifier: String!

  """The currently selected task flagged filter identifier."""
  selectedTaskFlaggedFilterIdentifier: String!

  """The currently selected task state filter identifier."""
  selectedTaskStateFilterIdentifier: String!

  """The trees of this tree that are selected in the user interface."""
  selectedTrees(after: ID, first: Int, whose: Condition): SelectedTreeConnection!

  """
  The immediate child trees of this tree in the user-specified sort ordering.
  """
  trees(after: ID, first: Int, whose: Condition): TreeConnection!
}

type ContentTreeConnection implements Connection {
  byId(id: ID!): ContentTree
  edges: [ContentTreeEdge!]!
  pageInfo: PageInfo!
}

type ContentTreeEdge implements Edge {
  cursor: String!
  node: ContentTree!
}

interface ContentTreeInterface implements Node {
  """The ancestor trees of this tree."""
  ancestorTrees(after: ID, first: Int, whose: Condition): AncestorTreeConnection!

  """
  The list of possible identifiers that can be set as the selected grouping identifier.
  """
  availableGroupingIdentifiers: [String!]!

  """
  The list of possible identifiers that can be set as the selected sorting identifier.
  """
  availableSortingIdentifiers: [String!]!

  """
  The list of possible identifiers that can be set as the selected task duration filter identifier.
  """
  availableTaskDurationFilterIdentifiers: [String!]!

  """
  The list of possible identifiers that can be set as the selected task flagged filter identifier.
  """
  availableTaskFlaggedFilterIdentifiers: [String!]!

  """
  The list of possible identifiers that can be set as the selected task state filter identifier.
  """
  availableTaskStateFilterIdentifiers: [String!]!

  """
  All the descendant trees in the user-specified sort ordering, listing each tree, then its children and so forth.
  """
  descendantTrees(after: ID, first: Int, whose: Condition): DescendantTreeConnection!

  """This is true if the node is expanded."""
  expanded: Boolean!

  """
  The sibling trees of this tree after it in the user-specified sort ordering.
  """
  followingSiblings(after: ID, first: Int, whose: Condition): FollowingSiblingConnection!

  """The identifier of object being represented by this tree."""
  id: ID! @extractFromObjectDisplayName

  """The descendants of this tree that have no children themselves."""
  leafs(after: ID, first: Int, whose: Condition): LeafConnection!

  """The name of the object being represented by this tree."""
  name: String!

  """This is true if the node note is expanded."""
  noteExpanded: Boolean!

  """
  The sibling trees of this tree before it in the user-specified sort ordering.
  """
  precedingSiblings(after: ID, first: Int, whose: Condition): PrecedingSiblingConnection!

  """
  This is true if the node is selected.  Note that attempts to set this while the node is not visible (collapsed parent, etc.) will silently do nothing.
  """
  selected: Boolean!

  """
  The currently selected grouping identifier, controlling how the results shown in the content area are grouped.
  """
  selectedGroupingIdentifier: String!

  """
  The currently selected sorting identifier, controlling how the results shown in the content area are ordered.
  """
  selectedSortingIdentifier: String!

  """The currently selected task duration filter identifier."""
  selectedTaskDurationFilterIdentifier: String!

  """The currently selected task flagged filter identifier."""
  selectedTaskFlaggedFilterIdentifier: String!

  """The currently selected task state filter identifier."""
  selectedTaskStateFilterIdentifier: String!

  """The trees of this tree that are selected in the user interface."""
  selectedTrees(after: ID, first: Int, whose: Condition): SelectedTreeConnection!

  """
  The immediate child trees of this tree in the user-specified sort ordering.
  """
  trees(after: ID, first: Int, whose: Condition): TreeConnection!
}

"""A user created perspective."""
type CustomPerspective implements Node & PerspectiveInterface {
  """The identifier of the perspective."""
  id: ID! @extractFromObjectDisplayName

  """The name of the perspective."""
  name: String!
}

type CustomPerspectiveConnection implements Connection {
  byId(id: ID!): CustomPerspective
  edges: [CustomPerspectiveEdge!]!
  pageInfo: PageInfo!
}

type CustomPerspectiveEdge implements Edge {
  cursor: String!
  node: CustomPerspective!
}

interface CustomPerspectiveInterface implements Node {
  """The identifier of the perspective."""
  id: ID! @extractFromObjectDisplayName

  """The name of the perspective."""
  name: String!
}

"""
Deprecated. Where you would look up a "context" by name, id, or index before, you can now use the term "tag". Where you would get or set the "context" property of a task before, you can now use "primary tag". You may also use the "add", "remove", and "move" commands to manage multiple ordered tags on a task now.
"""
type DeprecatedContext implements Node & TagInterface {
  """
  If false, tasks associated with this tag will be skipped when determining the next action for a project.
  """
  allowsNextAction: Boolean!

  """
  A count of the number of unblocked and incomplete tasks of this tag and all its active descendent tags.
  """
  availableTaskCount: Int!
  availableTasks(after: ID, first: Int, whose: Condition): AvailableTaskConnection!

  """The containing tag."""
  container: Tag!

  """Deprecated; use tags."""
  deprecatedContexts(after: ID, first: Int, whose: Condition): DeprecatedContextConnection!

  """
  Set if the tag is currently hidden or any of its container tags are hidden.
  """
  effectivelyHidden: Boolean!
  flattenedTags(after: ID, first: Int, whose: Condition): FlattenedTagConnection!

  """Set if the tag is currently hidden."""
  hidden: Boolean!

  """The identifier of the tag."""
  id: ID! @extractFromObjectDisplayName

  """The physical location associated with the tag."""
  location: LocationInformation

  """The name of the tag."""
  name: String!

  """The note of the tag."""
  note: RichText!

  """
  A count of the number of incomplete tasks of this tag and all its active descendent tags.
  """
  remainingTaskCount: Int!
  remainingTasks(after: ID, first: Int, whose: Condition): RemainingTaskConnection!

  """The tags having this tag as their container."""
  tags(after: ID, first: Int, whose: Condition): TagConnection!

  """The tasks having this tag."""
  tasks(after: ID, first: Int, whose: Condition): TaskConnection!
}

type DeprecatedContextConnection implements Connection {
  byId(id: ID!): DeprecatedContext
  edges: [DeprecatedContextEdge!]!
  pageInfo: PageInfo!
}

type DeprecatedContextEdge implements Edge {
  cursor: String!
  node: DeprecatedContext!
}

interface DeprecatedContextInterface implements Node {
  """
  If false, tasks associated with this tag will be skipped when determining the next action for a project.
  """
  allowsNextAction: Boolean!

  """
  A count of the number of unblocked and incomplete tasks of this tag and all its active descendent tags.
  """
  availableTaskCount: Int!
  availableTasks(after: ID, first: Int, whose: Condition): AvailableTaskConnection!

  """The containing tag."""
  container: Tag!

  """Deprecated; use tags."""
  deprecatedContexts(after: ID, first: Int, whose: Condition): DeprecatedContextConnection!

  """
  Set if the tag is currently hidden or any of its container tags are hidden.
  """
  effectivelyHidden: Boolean!
  flattenedTags(after: ID, first: Int, whose: Condition): FlattenedTagConnection!

  """Set if the tag is currently hidden."""
  hidden: Boolean!

  """The identifier of the tag."""
  id: ID! @extractFromObjectDisplayName

  """The physical location associated with the tag."""
  location: LocationInformation

  """The name of the tag."""
  name: String!

  """The note of the tag."""
  note: RichText!

  """
  A count of the number of incomplete tasks of this tag and all its active descendent tags.
  """
  remainingTaskCount: Int!
  remainingTasks(after: ID, first: Int, whose: Condition): RemainingTaskConnection!

  """The tags having this tag as their container."""
  tags(after: ID, first: Int, whose: Condition): TagConnection!

  """The tasks having this tag."""
  tasks(after: ID, first: Int, whose: Condition): TaskConnection!
}

"""
All the descendant trees in the user-specified sort ordering, listing each tree, then its children and so forth.
"""
type DescendantTree implements Node & TreeInterface {
  """The ancestor trees of this tree."""
  ancestorTrees(after: ID, first: Int, whose: Condition): AncestorTreeConnection!

  """
  All the descendant trees in the user-specified sort ordering, listing each tree, then its children and so forth.
  """
  descendantTrees(after: ID, first: Int, whose: Condition): DescendantTreeConnection!

  """This is true if the node is expanded."""
  expanded: Boolean!

  """
  The sibling trees of this tree after it in the user-specified sort ordering.
  """
  followingSiblings(after: ID, first: Int, whose: Condition): FollowingSiblingConnection!

  """The identifier of object being represented by this tree."""
  id: ID! @extractFromObjectDisplayName

  """The descendants of this tree that have no children themselves."""
  leafs(after: ID, first: Int, whose: Condition): LeafConnection!

  """The name of the object being represented by this tree."""
  name: String!

  """This is true if the node note is expanded."""
  noteExpanded: Boolean!

  """
  The sibling trees of this tree before it in the user-specified sort ordering.
  """
  precedingSiblings(after: ID, first: Int, whose: Condition): PrecedingSiblingConnection!

  """
  This is true if the node is selected.  Note that attempts to set this while the node is not visible (collapsed parent, etc.) will silently do nothing.
  """
  selected: Boolean!

  """The trees of this tree that are selected in the user interface."""
  selectedTrees(after: ID, first: Int, whose: Condition): SelectedTreeConnection!

  """
  The immediate child trees of this tree in the user-specified sort ordering.
  """
  trees(after: ID, first: Int, whose: Condition): TreeConnection!
}

type DescendantTreeConnection implements Connection {
  byId(id: ID!): DescendantTree
  edges: [DescendantTreeEdge!]!
  pageInfo: PageInfo!
}

type DescendantTreeEdge implements Edge {
  cursor: String!
  node: DescendantTree!
}

interface DescendantTreeInterface implements Node {
  """The ancestor trees of this tree."""
  ancestorTrees(after: ID, first: Int, whose: Condition): AncestorTreeConnection!

  """
  All the descendant trees in the user-specified sort ordering, listing each tree, then its children and so forth.
  """
  descendantTrees(after: ID, first: Int, whose: Condition): DescendantTreeConnection!

  """This is true if the node is expanded."""
  expanded: Boolean!

  """
  The sibling trees of this tree after it in the user-specified sort ordering.
  """
  followingSiblings(after: ID, first: Int, whose: Condition): FollowingSiblingConnection!

  """The identifier of object being represented by this tree."""
  id: ID! @extractFromObjectDisplayName

  """The descendants of this tree that have no children themselves."""
  leafs(after: ID, first: Int, whose: Condition): LeafConnection!

  """The name of the object being represented by this tree."""
  name: String!

  """This is true if the node note is expanded."""
  noteExpanded: Boolean!

  """
  The sibling trees of this tree before it in the user-specified sort ordering.
  """
  precedingSiblings(after: ID, first: Int, whose: Condition): PrecedingSiblingConnection!

  """
  This is true if the node is selected.  Note that attempts to set this while the node is not visible (collapsed parent, etc.) will silently do nothing.
  """
  selected: Boolean!

  """The trees of this tree that are selected in the user interface."""
  selectedTrees(after: ID, first: Int, whose: Condition): SelectedTreeConnection!

  """
  The immediate child trees of this tree in the user-specified sort ordering.
  """
  trees(after: ID, first: Int, whose: Condition): TreeConnection!
}

"""A document."""
type Document implements Node {
  """Whether the document can redo the most recently undone command."""
  canRedo: Boolean!

  """Whether the document can undo the most recent command."""
  canUndo: Boolean!

  """
  Whether the document will write compressed transactions to disk; defaults to true.
  """
  compressesTransactions: Boolean!

  """Deprecated; use tags."""
  deprecatedContexts(after: ID, first: Int, whose: Condition): DeprecatedContextConnection!

  """If set, automatic cleanup of inbox items won't happen."""
  disableAutomaticInboxCleanup: Boolean!

  """The windows of this document."""
  documentWindows(after: ID, first: Int, whose: Condition): DocumentWindowConnection!
  flattenedFolders(after: ID, first: Int, whose: Condition): FlattenedFolderConnection!
  flattenedProjects(after: ID, first: Int, whose: Condition): FlattenedProjectConnection!
  flattenedTags(after: ID, first: Int, whose: Condition): FlattenedTagConnection!
  flattenedTasks(after: ID, first: Int, whose: Condition): FlattenedTaskConnection!

  """
  The subset of the sections that are folders; folders having this folder as their container.
  """
  folders(after: ID, first: Int, whose: Condition): FolderConnection!
  id: ID! @extractFromObjectDisplayName
  inboxTasks(after: ID, first: Int, whose: Condition): InboxTaskConnection!

  """
  Whether the document will write computed summary information when writing transactions.
  """
  includesSummaries: Boolean!

  """Date of the last sync."""
  lastSyncDate: String!

  """Error message (if any) for the last sync."""
  lastSyncError: String!

  """Has it been modified since the last save?"""
  modified: Boolean!

  """Its name."""
  name: String!

  """The document's path on disk."""
  path: String!

  """The names of all available perspectives in this document."""
  perspectiveNames: [String!]!
  perspectives(after: ID, first: Int, whose: Condition): PerspectiveConnection!

  """
  The subset of the sections that are projects; projects having this folder as their container.
  """
  projects(after: ID, first: Int, whose: Condition): ProjectConnection!

  """The Quick Entry panel for the document."""
  quickEntry: QuickEntryTree!

  """The projects and folders contained by no folder."""
  sections(after: ID, first: Int, whose: Condition): SectionConnection!
  settings(after: ID, first: Int, whose: Condition): SettingConnection!

  """True if the document is currently syncing, false otherwise."""
  syncing: Boolean!

  """The top-level tags of the document."""
  tags(after: ID, first: Int, whose: Condition): TagConnection!
  tasks(after: ID, first: Int, whose: Condition): TaskConnection!

  """Whether the document will autosave."""
  willAutosave: Boolean!
}

type DocumentConnection implements Connection {
  byId(id: ID!): Document
  edges: [DocumentEdge!]!
  pageInfo: PageInfo!
}

type DocumentEdge implements Edge {
  cursor: String!
  node: Document!
}

interface DocumentInterface implements Node {
  id: ID! @extractFromObjectDisplayName

  """Has it been modified since the last save?"""
  modified: Boolean!

  """Its name."""
  name: String!
}

"""A window of an OmniFocus document."""
type DocumentWindow implements Node & WindowInterface {
  """Does the window have a close button?"""
  closeable: Boolean!

  """The tree of objects in the main window content."""
  content: ContentTree!

  """The document whose contents are displayed in the window."""
  document: Document!

  """The unique identifier of the window."""
  id: ID! @extractFromObjectDisplayName

  """The index of the window, ordered front to back."""
  index: Int!

  """Does the window have a minimize button?"""
  miniaturizable: Boolean!

  """Is the window minimized right now?"""
  miniaturized: Boolean!

  """The title of the window."""
  name: String!

  """The name of a perspective."""
  perspectiveName: String!

  """Can the window be resized?"""
  resizable: Boolean!

  """
  The search term in the toolbar.  If there is no search toolbar item, this will return missing value instead of an empty string and setting it will cause an error.
  """
  searchTerm: String!

  """Is the window visible right now?"""
  visible: Boolean!

  """Does the window have a zoom button?"""
  zoomable: Boolean!

  """Is the window zoomed right now?"""
  zoomed: Boolean!
}

type DocumentWindowConnection implements Connection {
  byId(id: ID!): DocumentWindow
  edges: [DocumentWindowEdge!]!
  pageInfo: PageInfo!
}

type DocumentWindowEdge implements Edge {
  cursor: String!
  node: DocumentWindow!
}

interface DocumentWindowInterface implements Node {
  """Does the window have a close button?"""
  closeable: Boolean!

  """The tree of objects in the main window content."""
  content: ContentTree!

  """The document whose contents are displayed in the window."""
  document: Document!

  """The unique identifier of the window."""
  id: ID! @extractFromObjectDisplayName

  """The index of the window, ordered front to back."""
  index: Int!

  """Does the window have a minimize button?"""
  miniaturizable: Boolean!

  """Is the window minimized right now?"""
  miniaturized: Boolean!

  """The title of the window."""
  name: String!

  """The name of a perspective."""
  perspectiveName: String!

  """Can the window be resized?"""
  resizable: Boolean!

  """
  The search term in the toolbar.  If there is no search toolbar item, this will return missing value instead of an empty string and setting it will cause an error.
  """
  searchTerm: String!

  """Is the window visible right now?"""
  visible: Boolean!

  """Does the window have a zoom button?"""
  zoomable: Boolean!

  """Is the window zoomed right now?"""
  zoomed: Boolean!
}

interface Edge {
  cursor: String!
  node: Node!
}

"""A text attachment refering to a plain file."""
type FileAttachment implements AttachmentInterface & Node {
  attachments(after: ID, first: Int, whose: Condition): AttachmentConnection!
  attributeRuns(after: ID, first: Int, whose: Condition): AttributeRunConnection!
  characters(after: ID, first: Int, whose: Condition): CharacterConnection!

  """
  If true, the attached file will reside inside the document on the next save.
  """
  embedded: Boolean!
  fileAttachments(after: ID, first: Int, whose: Condition): FileAttachmentConnection!

  """The name of the font of the first character."""
  font: String!
  id: ID! @extractFromObjectDisplayName
  paragraphs(after: ID, first: Int, whose: Condition): ParagraphConnection!

  """The size in points of the first character."""
  size: Int!

  """The style of the text."""
  style: Style!

  """The plain text contents of the rich text."""
  text: String!
  words(after: ID, first: Int, whose: Condition): WordConnection!
}

type FileAttachmentConnection implements Connection {
  byId(id: ID!): FileAttachment
  edges: [FileAttachmentEdge!]!
  pageInfo: PageInfo!
}

type FileAttachmentEdge implements Edge {
  cursor: String!
  node: FileAttachment!
}

interface FileAttachmentInterface implements Node {
  attachments(after: ID, first: Int, whose: Condition): AttachmentConnection!
  attributeRuns(after: ID, first: Int, whose: Condition): AttributeRunConnection!
  characters(after: ID, first: Int, whose: Condition): CharacterConnection!

  """
  If true, the attached file will reside inside the document on the next save.
  """
  embedded: Boolean!
  fileAttachments(after: ID, first: Int, whose: Condition): FileAttachmentConnection!

  """The name of the font of the first character."""
  font: String!
  id: ID! @extractFromObjectDisplayName
  paragraphs(after: ID, first: Int, whose: Condition): ParagraphConnection!

  """The size in points of the first character."""
  size: Int!

  """The style of the text."""
  style: Style!

  """The plain text contents of the rich text."""
  text: String!
  words(after: ID, first: Int, whose: Condition): WordConnection!
}

"""A flattened list of folders in a document."""
type FlattenedFolder implements FolderInterface & Node & SectionInterface {
  """When the folder was created."""
  creationDate: String!

  """
  Set if the folder is currently hidden or any of its container folders are hidden.
  """
  effectivelyHidden: Boolean!
  flattenedFolders(after: ID, first: Int, whose: Condition): FlattenedFolderConnection!
  flattenedProjects(after: ID, first: Int, whose: Condition): FlattenedProjectConnection!

  """
  The subset of the sections that are folders; folders having this folder as their container.
  """
  folders(after: ID, first: Int, whose: Condition): FolderConnection!

  """Set if the folder is currently hidden."""
  hidden: Boolean!

  """The identifier of the folder."""
  id: ID! @extractFromObjectDisplayName

  """When the folder was last modified."""
  modificationDate: String!

  """The name of the folder."""
  name: String!

  """The note of the folder."""
  note: RichText!

  """
  The subset of the sections that are projects; projects having this folder as their container.
  """
  projects(after: ID, first: Int, whose: Condition): ProjectConnection!

  """The projects and folders having this folder as their container."""
  sections(after: ID, first: Int, whose: Condition): SectionConnection!
}

type FlattenedFolderConnection implements Connection {
  byId(id: ID!): FlattenedFolder
  edges: [FlattenedFolderEdge!]!
  pageInfo: PageInfo!
}

type FlattenedFolderEdge implements Edge {
  cursor: String!
  node: FlattenedFolder!
}

interface FlattenedFolderInterface implements Node {
  """When the folder was created."""
  creationDate: String!

  """
  Set if the folder is currently hidden or any of its container folders are hidden.
  """
  effectivelyHidden: Boolean!
  flattenedFolders(after: ID, first: Int, whose: Condition): FlattenedFolderConnection!
  flattenedProjects(after: ID, first: Int, whose: Condition): FlattenedProjectConnection!

  """
  The subset of the sections that are folders; folders having this folder as their container.
  """
  folders(after: ID, first: Int, whose: Condition): FolderConnection!

  """Set if the folder is currently hidden."""
  hidden: Boolean!

  """The identifier of the folder."""
  id: ID! @extractFromObjectDisplayName

  """When the folder was last modified."""
  modificationDate: String!

  """The name of the folder."""
  name: String!

  """The note of the folder."""
  note: RichText!

  """
  The subset of the sections that are projects; projects having this folder as their container.
  """
  projects(after: ID, first: Int, whose: Condition): ProjectConnection!

  """The projects and folders having this folder as their container."""
  sections(after: ID, first: Int, whose: Condition): SectionConnection!
}

"""A flattened list of projects under a folder or document."""
type FlattenedProject implements Node & ProjectInterface & SectionInterface {
  """
  True if the project has a project that must be completed prior to it being actionable.
  """
  blocked: Boolean!

  """
  True if the project is completed. Use the "mark complete" and "mark incomplete" commands to change a project's status.
  """
  completed: Boolean!

  """If true, complete when children are completed."""
  completedByChildren: Boolean!

  """
  The project's date of completion. This can only be modified on a completed project to backdate the completion date.
  """
  completionDate: String

  """
  When the project was created.  This can only be set when the object is still in the inserted state.  For objects created in the document, it can be passed with the creation properties.  For objects in a quick entry tree, it can be set until the quick entry panel is saved.
  """
  creationDate: String!

  """
  True if the project is the default holder of sington actions.  Only one project can have this flag set; setting it on a project will clear it on any other project having it.  Setting this to true will set 'singleton action holder' to true if not already so set.
  """
  defaultSingletonActionHolder: Boolean!

  """When the project should become available for action."""
  deferDate: String

  """
  True if the project is dropped. Use the "mark dropped" and "mark incomplete" commands to change a project's status.
  """
  dropped: Boolean!

  """
  The date the project was dropped. This can only be modified on a dropped project to backdate the dropped date.
  """
  droppedDate: String

  """When the project must be finished."""
  dueDate: String

  """
  When the project should become available for action (including inherited).
  """
  effectiveDeferDate: String

  """When the project must be finished (including inherited)."""
  effectiveDueDate: String

  """The effective status of the project."""
  effectiveStatus: ProjectStatus!

  """True if the project is completed"""
  effectivelyCompleted: Boolean!

  """True if the project is dropped"""
  effectivelyDropped: Boolean!

  """
  The estimated time, in whole minutes, that this project will take to finish.
  """
  estimatedMinutes: Int

  """True if flagged"""
  flagged: Boolean!

  """
  The folder of the project, or missing value if it is contained directly by the document.
  """
  folder: Folder

  """The identifier of the project."""
  id: ID! @extractFromObjectDisplayName

  """When the project was last reviewed."""
  lastReviewDate: String!

  """When the project was last modified."""
  modificationDate: String!

  """The name of the project."""
  name: String!

  """
  The next defer date if this project repeats on a fixed schedule and it has a defer date.
  """
  nextDeferDate: String

  """
  The next due date if this project repeats on a fixed schedule and it has a due date.
  """
  nextDueDate: String

  """
  When the project should next be reviewed. Setting this to missing value will set the review date based off the last review date and review interval.
  """
  nextReviewDate: String

  """The next actionable child of this project."""
  nextTask: Task

  """The note of the project."""
  note: RichText!

  """The number of available direct children of this project."""
  numberOfAvailableTasks: Int!

  """The number of completed direct children of this project."""
  numberOfCompletedTasks: Int!

  """The number of direct children of this project."""
  numberOfTasks: Int!

  """
  The project's first tag. Setting this will remove the current first tag on the project, if any and move or add the new tag as the first tag on the project. Setting this to missing value will remove the current first tag and leave any other remaining tags.
  """
  primaryTag: Tag

  """
  The repetition interval of the project, or missing value if it does not repeat. This property is deprecated in favor of “repetition rule” and is here only for backwards compatibility with existing scripts.
  """
  repetition: RepetitionInterval

  """
  The repetition rule for this project, or missing value if it does not repeat.
  """
  repetitionRule: RepetitionRule

  """The review interval for the project."""
  reviewInterval: RepetitionInterval!

  """
  The root task of this project, holding the project's name, note, dates and child tasks.
  """
  rootTask: Task!

  """If true, any children are sequentially dependent."""
  sequential: Boolean!

  """
  When set, the due date and defer date properties will use floating time zones. (Note: if a Task has no due or defer dates assigned, this property will revert to the database’s default setting.)
  """
  shouldUseFloatingTimeZone: Boolean!

  """True if the project contains singleton actions."""
  singletonActionHolder: Boolean!

  """The status of the project."""
  status: ProjectStatus!
}

type FlattenedProjectConnection implements Connection {
  byId(id: ID!): FlattenedProject
  edges: [FlattenedProjectEdge!]!
  pageInfo: PageInfo!
}

type FlattenedProjectEdge implements Edge {
  cursor: String!
  node: FlattenedProject!
}

interface FlattenedProjectInterface implements Node {
  """
  True if the project has a project that must be completed prior to it being actionable.
  """
  blocked: Boolean!

  """
  True if the project is completed. Use the "mark complete" and "mark incomplete" commands to change a project's status.
  """
  completed: Boolean!

  """If true, complete when children are completed."""
  completedByChildren: Boolean!

  """
  The project's date of completion. This can only be modified on a completed project to backdate the completion date.
  """
  completionDate: String

  """
  When the project was created.  This can only be set when the object is still in the inserted state.  For objects created in the document, it can be passed with the creation properties.  For objects in a quick entry tree, it can be set until the quick entry panel is saved.
  """
  creationDate: String!

  """
  True if the project is the default holder of sington actions.  Only one project can have this flag set; setting it on a project will clear it on any other project having it.  Setting this to true will set 'singleton action holder' to true if not already so set.
  """
  defaultSingletonActionHolder: Boolean!

  """When the project should become available for action."""
  deferDate: String

  """
  True if the project is dropped. Use the "mark dropped" and "mark incomplete" commands to change a project's status.
  """
  dropped: Boolean!

  """
  The date the project was dropped. This can only be modified on a dropped project to backdate the dropped date.
  """
  droppedDate: String

  """When the project must be finished."""
  dueDate: String

  """
  When the project should become available for action (including inherited).
  """
  effectiveDeferDate: String

  """When the project must be finished (including inherited)."""
  effectiveDueDate: String

  """The effective status of the project."""
  effectiveStatus: ProjectStatus!

  """True if the project is completed"""
  effectivelyCompleted: Boolean!

  """True if the project is dropped"""
  effectivelyDropped: Boolean!

  """
  The estimated time, in whole minutes, that this project will take to finish.
  """
  estimatedMinutes: Int

  """True if flagged"""
  flagged: Boolean!

  """
  The folder of the project, or missing value if it is contained directly by the document.
  """
  folder: Folder

  """The identifier of the project."""
  id: ID! @extractFromObjectDisplayName

  """When the project was last reviewed."""
  lastReviewDate: String!

  """When the project was last modified."""
  modificationDate: String!

  """The name of the project."""
  name: String!

  """
  The next defer date if this project repeats on a fixed schedule and it has a defer date.
  """
  nextDeferDate: String

  """
  The next due date if this project repeats on a fixed schedule and it has a due date.
  """
  nextDueDate: String

  """
  When the project should next be reviewed. Setting this to missing value will set the review date based off the last review date and review interval.
  """
  nextReviewDate: String

  """The next actionable child of this project."""
  nextTask: Task

  """The note of the project."""
  note: RichText!

  """The number of available direct children of this project."""
  numberOfAvailableTasks: Int!

  """The number of completed direct children of this project."""
  numberOfCompletedTasks: Int!

  """The number of direct children of this project."""
  numberOfTasks: Int!

  """
  The project's first tag. Setting this will remove the current first tag on the project, if any and move or add the new tag as the first tag on the project. Setting this to missing value will remove the current first tag and leave any other remaining tags.
  """
  primaryTag: Tag

  """
  The repetition interval of the project, or missing value if it does not repeat. This property is deprecated in favor of “repetition rule” and is here only for backwards compatibility with existing scripts.
  """
  repetition: RepetitionInterval

  """
  The repetition rule for this project, or missing value if it does not repeat.
  """
  repetitionRule: RepetitionRule

  """The review interval for the project."""
  reviewInterval: RepetitionInterval!

  """
  The root task of this project, holding the project's name, note, dates and child tasks.
  """
  rootTask: Task!

  """If true, any children are sequentially dependent."""
  sequential: Boolean!

  """
  When set, the due date and defer date properties will use floating time zones. (Note: if a Task has no due or defer dates assigned, this property will revert to the database’s default setting.)
  """
  shouldUseFloatingTimeZone: Boolean!

  """True if the project contains singleton actions."""
  singletonActionHolder: Boolean!

  """The status of the project."""
  status: ProjectStatus!
}

"""A flattened list of tags in a document."""
type FlattenedTag implements Node & TagInterface {
  """
  If false, tasks associated with this tag will be skipped when determining the next action for a project.
  """
  allowsNextAction: Boolean!

  """
  A count of the number of unblocked and incomplete tasks of this tag and all its active descendent tags.
  """
  availableTaskCount: Int!
  availableTasks(after: ID, first: Int, whose: Condition): AvailableTaskConnection!

  """The containing tag."""
  container: Tag!

  """Deprecated; use tags."""
  deprecatedContexts(after: ID, first: Int, whose: Condition): DeprecatedContextConnection!

  """
  Set if the tag is currently hidden or any of its container tags are hidden.
  """
  effectivelyHidden: Boolean!
  flattenedTags(after: ID, first: Int, whose: Condition): FlattenedTagConnection!

  """Set if the tag is currently hidden."""
  hidden: Boolean!

  """The identifier of the tag."""
  id: ID! @extractFromObjectDisplayName

  """The physical location associated with the tag."""
  location: LocationInformation

  """The name of the tag."""
  name: String!

  """The note of the tag."""
  note: RichText!

  """
  A count of the number of incomplete tasks of this tag and all its active descendent tags.
  """
  remainingTaskCount: Int!
  remainingTasks(after: ID, first: Int, whose: Condition): RemainingTaskConnection!

  """The tags having this tag as their container."""
  tags(after: ID, first: Int, whose: Condition): TagConnection!

  """The tasks having this tag."""
  tasks(after: ID, first: Int, whose: Condition): TaskConnection!
}

type FlattenedTagConnection implements Connection {
  byId(id: ID!): FlattenedTag
  edges: [FlattenedTagEdge!]!
  pageInfo: PageInfo!
}

type FlattenedTagEdge implements Edge {
  cursor: String!
  node: FlattenedTag!
}

interface FlattenedTagInterface implements Node {
  """
  If false, tasks associated with this tag will be skipped when determining the next action for a project.
  """
  allowsNextAction: Boolean!

  """
  A count of the number of unblocked and incomplete tasks of this tag and all its active descendent tags.
  """
  availableTaskCount: Int!
  availableTasks(after: ID, first: Int, whose: Condition): AvailableTaskConnection!

  """The containing tag."""
  container: Tag!

  """Deprecated; use tags."""
  deprecatedContexts(after: ID, first: Int, whose: Condition): DeprecatedContextConnection!

  """
  Set if the tag is currently hidden or any of its container tags are hidden.
  """
  effectivelyHidden: Boolean!
  flattenedTags(after: ID, first: Int, whose: Condition): FlattenedTagConnection!

  """Set if the tag is currently hidden."""
  hidden: Boolean!

  """The identifier of the tag."""
  id: ID! @extractFromObjectDisplayName

  """The physical location associated with the tag."""
  location: LocationInformation

  """The name of the tag."""
  name: String!

  """The note of the tag."""
  note: RichText!

  """
  A count of the number of incomplete tasks of this tag and all its active descendent tags.
  """
  remainingTaskCount: Int!
  remainingTasks(after: ID, first: Int, whose: Condition): RemainingTaskConnection!

  """The tags having this tag as their container."""
  tags(after: ID, first: Int, whose: Condition): TagConnection!

  """The tasks having this tag."""
  tasks(after: ID, first: Int, whose: Condition): TaskConnection!
}

"""A flattened list of tasks under a task or document."""
type FlattenedTask implements Node & TaskInterface {
  """
  True if the task has a task that must be completed prior to it being actionable.
  """
  blocked: Boolean!

  """
  True if the task is completed. Use the "mark complete" and "mark incomplete" commands to change a task's status.
  """
  completed: Boolean!

  """If true, complete when children are completed."""
  completedByChildren: Boolean!

  """
  The task's date of completion. This can only be modified on a completed task to backdate the completion date.
  """
  completionDate: String

  """
  The task's project, up however many levels of parent tasks.  Inbox tasks aren't considered contained by their provisionalliy assigned container, so if the task is actually an inbox task, this will be missing value.
  """
  containingProject: Project

  """
  When the task was created.  This can only be set when the object is still in the inserted state.  For objects created in the document, it can be passed with the creation properties.  For objects in a quick entry tree, it can be set until the quick entry panel is saved.
  """
  creationDate: String!

  """When the task should become available for action."""
  deferDate: String

  """
  True if the task is dropped. Use the "mark dropped" and "mark incomplete" commands to change a task's status.
  """
  dropped: Boolean!

  """
  The date the task was dropped. This can only be modified on a dropped task to backdate the dropped date.
  """
  droppedDate: String

  """When the task must be finished."""
  dueDate: String

  """
  When the task should become available for action (including inherited).
  """
  effectiveDeferDate: String

  """When the task must be finished (including inherited)."""
  effectiveDueDate: String

  """
  True if the task is completed, or any of it's containing tasks or project are completed.
  """
  effectivelyCompleted: Boolean!

  """
  True if the task is dropped, or any of it's containing tasks or project are dropped.
  """
  effectivelyDropped: Boolean!

  """
  The estimated time, in whole minutes, that this task will take to finish.
  """
  estimatedMinutes: Int

  """True if flagged"""
  flagged: Boolean!
  flattenedTasks(after: ID, first: Int, whose: Condition): FlattenedTaskConnection!

  """The identifier of the task."""
  id: ID! @extractFromObjectDisplayName

  """
  Returns true if the task itself is an inbox task or if the task is contained by an inbox task.
  """
  inInbox: Boolean!

  """When the task was last modified."""
  modificationDate: String!

  """The name of the task."""
  name: String!

  """If the task is the next task of its containing project, next is true."""
  next: Boolean!

  """
  The next defer date if this task repeats on a fixed schedule and it has a defer date.
  """
  nextDeferDate: String

  """
  The next due date if this task repeats on a fixed schedule and it has a due date.
  """
  nextDueDate: String

  """The note of the task."""
  note: RichText!

  """The number of available direct children of this task."""
  numberOfAvailableTasks: Int!

  """The number of completed direct children of this task."""
  numberOfCompletedTasks: Int!

  """The number of direct children of this task."""
  numberOfTasks: Int!

  """
  The task holding this task.  If this is missing value, then this is a top level task -- either the root of a project or an inbox item.
  """
  parentTask: Task

  """
  The task's first tag. Setting this will remove the current first tag on the task, if any and move or add the new tag as the first tag on the task. Setting this to missing value will remove the current first tag and leave any other remaining tags.
  """
  primaryTag: Tag

  """
  The repetition interval of the task, or missing value if it does not repeat. This property is deprecated in favor of “repetition rule” and is here only for backwards compatibility with existing scripts.
  """
  repetition: RepetitionInterval

  """
  The repetition rule for this task, or missing value if it does not repeat.
  """
  repetitionRule: RepetitionRule

  """If true, any children are sequentially dependent."""
  sequential: Boolean!

  """
  When set, the due date and defer date properties will use floating time zones. (Note: if a Task has no due or defer dates assigned, this property will revert to the database’s default setting.)
  """
  shouldUseFloatingTimeZone: Boolean!

  """The tags assigned to this task."""
  tags(after: ID, first: Int, whose: Condition): TagConnection!

  """The tasks having this task as their container."""
  tasks(after: ID, first: Int, whose: Condition): TaskConnection!
}

type FlattenedTaskConnection implements Connection {
  byId(id: ID!): FlattenedTask
  edges: [FlattenedTaskEdge!]!
  pageInfo: PageInfo!
}

type FlattenedTaskEdge implements Edge {
  cursor: String!
  node: FlattenedTask!
}

interface FlattenedTaskInterface implements Node {
  """
  True if the task has a task that must be completed prior to it being actionable.
  """
  blocked: Boolean!

  """
  True if the task is completed. Use the "mark complete" and "mark incomplete" commands to change a task's status.
  """
  completed: Boolean!

  """If true, complete when children are completed."""
  completedByChildren: Boolean!

  """
  The task's date of completion. This can only be modified on a completed task to backdate the completion date.
  """
  completionDate: String

  """
  The task's project, up however many levels of parent tasks.  Inbox tasks aren't considered contained by their provisionalliy assigned container, so if the task is actually an inbox task, this will be missing value.
  """
  containingProject: Project

  """
  When the task was created.  This can only be set when the object is still in the inserted state.  For objects created in the document, it can be passed with the creation properties.  For objects in a quick entry tree, it can be set until the quick entry panel is saved.
  """
  creationDate: String!

  """When the task should become available for action."""
  deferDate: String

  """
  True if the task is dropped. Use the "mark dropped" and "mark incomplete" commands to change a task's status.
  """
  dropped: Boolean!

  """
  The date the task was dropped. This can only be modified on a dropped task to backdate the dropped date.
  """
  droppedDate: String

  """When the task must be finished."""
  dueDate: String

  """
  When the task should become available for action (including inherited).
  """
  effectiveDeferDate: String

  """When the task must be finished (including inherited)."""
  effectiveDueDate: String

  """
  True if the task is completed, or any of it's containing tasks or project are completed.
  """
  effectivelyCompleted: Boolean!

  """
  True if the task is dropped, or any of it's containing tasks or project are dropped.
  """
  effectivelyDropped: Boolean!

  """
  The estimated time, in whole minutes, that this task will take to finish.
  """
  estimatedMinutes: Int

  """True if flagged"""
  flagged: Boolean!
  flattenedTasks(after: ID, first: Int, whose: Condition): FlattenedTaskConnection!

  """The identifier of the task."""
  id: ID! @extractFromObjectDisplayName

  """
  Returns true if the task itself is an inbox task or if the task is contained by an inbox task.
  """
  inInbox: Boolean!

  """When the task was last modified."""
  modificationDate: String!

  """The name of the task."""
  name: String!

  """If the task is the next task of its containing project, next is true."""
  next: Boolean!

  """
  The next defer date if this task repeats on a fixed schedule and it has a defer date.
  """
  nextDeferDate: String

  """
  The next due date if this task repeats on a fixed schedule and it has a due date.
  """
  nextDueDate: String

  """The note of the task."""
  note: RichText!

  """The number of available direct children of this task."""
  numberOfAvailableTasks: Int!

  """The number of completed direct children of this task."""
  numberOfCompletedTasks: Int!

  """The number of direct children of this task."""
  numberOfTasks: Int!

  """
  The task holding this task.  If this is missing value, then this is a top level task -- either the root of a project or an inbox item.
  """
  parentTask: Task

  """
  The task's first tag. Setting this will remove the current first tag on the task, if any and move or add the new tag as the first tag on the task. Setting this to missing value will remove the current first tag and leave any other remaining tags.
  """
  primaryTag: Tag

  """
  The repetition interval of the task, or missing value if it does not repeat. This property is deprecated in favor of “repetition rule” and is here only for backwards compatibility with existing scripts.
  """
  repetition: RepetitionInterval

  """
  The repetition rule for this task, or missing value if it does not repeat.
  """
  repetitionRule: RepetitionRule

  """If true, any children are sequentially dependent."""
  sequential: Boolean!

  """
  When set, the due date and defer date properties will use floating time zones. (Note: if a Task has no due or defer dates assigned, this property will revert to the database’s default setting.)
  """
  shouldUseFloatingTimeZone: Boolean!

  """The tags assigned to this task."""
  tags(after: ID, first: Int, whose: Condition): TagConnection!

  """The tasks having this task as their container."""
  tasks(after: ID, first: Int, whose: Condition): TaskConnection!
}

"""The current focus of a document window."""
type FocusSections implements Node {
  id: ID! @extractFromObjectDisplayName
}

type FocusSectionsConnection implements Connection {
  byId(id: ID!): FocusSections
  edges: [FocusSectionsEdge!]!
  pageInfo: PageInfo!
}

type FocusSectionsEdge implements Edge {
  cursor: String!
  node: FocusSections!
}

interface FocusSectionsInterface implements Node {
  id: ID! @extractFromObjectDisplayName
}

"""
A group of projects and sub-folders representing an area of responsibility.
"""
type Folder implements FolderInterface & Node & SectionInterface {
  """When the folder was created."""
  creationDate: String!

  """
  Set if the folder is currently hidden or any of its container folders are hidden.
  """
  effectivelyHidden: Boolean!
  flattenedFolders(after: ID, first: Int, whose: Condition): FlattenedFolderConnection!
  flattenedProjects(after: ID, first: Int, whose: Condition): FlattenedProjectConnection!

  """
  The subset of the sections that are folders; folders having this folder as their container.
  """
  folders(after: ID, first: Int, whose: Condition): FolderConnection!

  """Set if the folder is currently hidden."""
  hidden: Boolean!

  """The identifier of the folder."""
  id: ID! @extractFromObjectDisplayName

  """When the folder was last modified."""
  modificationDate: String!

  """The name of the folder."""
  name: String!

  """The note of the folder."""
  note: RichText!

  """
  The subset of the sections that are projects; projects having this folder as their container.
  """
  projects(after: ID, first: Int, whose: Condition): ProjectConnection!

  """The projects and folders having this folder as their container."""
  sections(after: ID, first: Int, whose: Condition): SectionConnection!
}

type FolderConnection implements Connection {
  byId(id: ID!): FolderInterface
  edges: [FolderEdge!]!
  pageInfo: PageInfo!
}

type FolderEdge implements Edge {
  cursor: String!
  node: FolderInterface!
}

interface FolderInterface implements Node {
  """When the folder was created."""
  creationDate: String!

  """
  Set if the folder is currently hidden or any of its container folders are hidden.
  """
  effectivelyHidden: Boolean!
  flattenedFolders(after: ID, first: Int, whose: Condition): FlattenedFolderConnection!
  flattenedProjects(after: ID, first: Int, whose: Condition): FlattenedProjectConnection!

  """
  The subset of the sections that are folders; folders having this folder as their container.
  """
  folders(after: ID, first: Int, whose: Condition): FolderConnection!

  """Set if the folder is currently hidden."""
  hidden: Boolean!

  """The identifier of the folder."""
  id: ID! @extractFromObjectDisplayName

  """When the folder was last modified."""
  modificationDate: String!

  """The name of the folder."""
  name: String!

  """The note of the folder."""
  note: RichText!

  """
  The subset of the sections that are projects; projects having this folder as their container.
  """
  projects(after: ID, first: Int, whose: Condition): ProjectConnection!

  """The projects and folders having this folder as their container."""
  sections(after: ID, first: Int, whose: Condition): SectionConnection!
}

"""
The sibling trees of this tree after it in the user-specified sort ordering.
"""
type FollowingSibling implements Node & TreeInterface {
  """The ancestor trees of this tree."""
  ancestorTrees(after: ID, first: Int, whose: Condition): AncestorTreeConnection!

  """
  All the descendant trees in the user-specified sort ordering, listing each tree, then its children and so forth.
  """
  descendantTrees(after: ID, first: Int, whose: Condition): DescendantTreeConnection!

  """This is true if the node is expanded."""
  expanded: Boolean!

  """
  The sibling trees of this tree after it in the user-specified sort ordering.
  """
  followingSiblings(after: ID, first: Int, whose: Condition): FollowingSiblingConnection!

  """The identifier of object being represented by this tree."""
  id: ID! @extractFromObjectDisplayName

  """The descendants of this tree that have no children themselves."""
  leafs(after: ID, first: Int, whose: Condition): LeafConnection!

  """The name of the object being represented by this tree."""
  name: String!

  """This is true if the node note is expanded."""
  noteExpanded: Boolean!

  """
  The sibling trees of this tree before it in the user-specified sort ordering.
  """
  precedingSiblings(after: ID, first: Int, whose: Condition): PrecedingSiblingConnection!

  """
  This is true if the node is selected.  Note that attempts to set this while the node is not visible (collapsed parent, etc.) will silently do nothing.
  """
  selected: Boolean!

  """The trees of this tree that are selected in the user interface."""
  selectedTrees(after: ID, first: Int, whose: Condition): SelectedTreeConnection!

  """
  The immediate child trees of this tree in the user-specified sort ordering.
  """
  trees(after: ID, first: Int, whose: Condition): TreeConnection!
}

type FollowingSiblingConnection implements Connection {
  byId(id: ID!): FollowingSibling
  edges: [FollowingSiblingEdge!]!
  pageInfo: PageInfo!
}

type FollowingSiblingEdge implements Edge {
  cursor: String!
  node: FollowingSibling!
}

interface FollowingSiblingInterface implements Node {
  """The ancestor trees of this tree."""
  ancestorTrees(after: ID, first: Int, whose: Condition): AncestorTreeConnection!

  """
  All the descendant trees in the user-specified sort ordering, listing each tree, then its children and so forth.
  """
  descendantTrees(after: ID, first: Int, whose: Condition): DescendantTreeConnection!

  """This is true if the node is expanded."""
  expanded: Boolean!

  """
  The sibling trees of this tree after it in the user-specified sort ordering.
  """
  followingSiblings(after: ID, first: Int, whose: Condition): FollowingSiblingConnection!

  """The identifier of object being represented by this tree."""
  id: ID! @extractFromObjectDisplayName

  """The descendants of this tree that have no children themselves."""
  leafs(after: ID, first: Int, whose: Condition): LeafConnection!

  """The name of the object being represented by this tree."""
  name: String!

  """This is true if the node note is expanded."""
  noteExpanded: Boolean!

  """
  The sibling trees of this tree before it in the user-specified sort ordering.
  """
  precedingSiblings(after: ID, first: Int, whose: Condition): PrecedingSiblingConnection!

  """
  This is true if the node is selected.  Note that attempts to set this while the node is not visible (collapsed parent, etc.) will silently do nothing.
  """
  selected: Boolean!

  """The trees of this tree that are selected in the user interface."""
  selectedTrees(after: ID, first: Int, whose: Condition): SelectedTreeConnection!

  """
  The immediate child trees of this tree in the user-specified sort ordering.
  """
  trees(after: ID, first: Int, whose: Condition): TreeConnection!
}

"""A day in the forecast sidebar tree."""
type ForecastDay implements Node {
  """
  The count shown in the sidebar for this forecast day, or zero if there is no count shown.
  """
  badgeCount: Int!

  """
  True if the forecast day has no content at all. Note that some content will not cause a badge to be shown in the sidebar, and some content is controlled by user preferences.
  """
  empty: Boolean!

  """The identifier of the task."""
  id: ID! @extractFromObjectDisplayName

  """A display name for the forecast day."""
  name: String!
}

type ForecastDayConnection implements Connection {
  byId(id: ID!): ForecastDay
  edges: [ForecastDayEdge!]!
  pageInfo: PageInfo!
}

type ForecastDayEdge implements Edge {
  cursor: String!
  node: ForecastDay!
}

interface ForecastDayInterface implements Node {
  """
  The count shown in the sidebar for this forecast day, or zero if there is no count shown.
  """
  badgeCount: Int!

  """
  True if the forecast day has no content at all. Note that some content will not cause a badge to be shown in the sidebar, and some content is controlled by user preferences.
  """
  empty: Boolean!

  """The identifier of the task."""
  id: ID! @extractFromObjectDisplayName

  """A display name for the forecast day."""
  name: String!
}

"""
The sidebar tree used when the window's sidebar tab property is set to forecast tab.
"""
type ForecastSidebarTree implements Node & SidebarTreeInterface & TreeInterface {
  """The ancestor trees of this tree."""
  ancestorTrees(after: ID, first: Int, whose: Condition): AncestorTreeConnection!

  """
  The list of possible smart group identifiers that can be set as the selected smart group identifier.
  """
  availableSmartGroupIdentifiers: [String!]!

  """
  All the descendant trees in the user-specified sort ordering, listing each tree, then its children and so forth.
  """
  descendantTrees(after: ID, first: Int, whose: Condition): DescendantTreeConnection!

  """This is true if the node is expanded."""
  expanded: Boolean!

  """
  The sibling trees of this tree after it in the user-specified sort ordering.
  """
  followingSiblings(after: ID, first: Int, whose: Condition): FollowingSiblingConnection!
  forecastDays(after: ID, first: Int, whose: Condition): ForecastDayConnection!

  """The identifier of object being represented by this tree."""
  id: ID! @extractFromObjectDisplayName

  """The descendants of this tree that have no children themselves."""
  leafs(after: ID, first: Int, whose: Condition): LeafConnection!

  """The name of the object being represented by this tree."""
  name: String!

  """This is true if the node note is expanded."""
  noteExpanded: Boolean!

  """
  The sibling trees of this tree before it in the user-specified sort ordering.
  """
  precedingSiblings(after: ID, first: Int, whose: Condition): PrecedingSiblingConnection!

  """
  This is true if the node is selected.  Note that attempts to set this while the node is not visible (collapsed parent, etc.) will silently do nothing.
  """
  selected: Boolean!

  """The currently selected smart group identifier."""
  selectedSmartGroupIdentifier: String

  """The trees of this tree that are selected in the user interface."""
  selectedTrees(after: ID, first: Int, whose: Condition): SelectedTreeConnection!

  """
  The immediate child trees of this tree in the user-specified sort ordering.
  """
  trees(after: ID, first: Int, whose: Condition): TreeConnection!
}

type ForecastSidebarTreeConnection implements Connection {
  byId(id: ID!): ForecastSidebarTree
  edges: [ForecastSidebarTreeEdge!]!
  pageInfo: PageInfo!
}

type ForecastSidebarTreeEdge implements Edge {
  cursor: String!
  node: ForecastSidebarTree!
}

interface ForecastSidebarTreeInterface implements Node {
  """The ancestor trees of this tree."""
  ancestorTrees(after: ID, first: Int, whose: Condition): AncestorTreeConnection!

  """
  The list of possible smart group identifiers that can be set as the selected smart group identifier.
  """
  availableSmartGroupIdentifiers: [String!]!

  """
  All the descendant trees in the user-specified sort ordering, listing each tree, then its children and so forth.
  """
  descendantTrees(after: ID, first: Int, whose: Condition): DescendantTreeConnection!

  """This is true if the node is expanded."""
  expanded: Boolean!

  """
  The sibling trees of this tree after it in the user-specified sort ordering.
  """
  followingSiblings(after: ID, first: Int, whose: Condition): FollowingSiblingConnection!
  forecastDays(after: ID, first: Int, whose: Condition): ForecastDayConnection!

  """The identifier of object being represented by this tree."""
  id: ID! @extractFromObjectDisplayName

  """The descendants of this tree that have no children themselves."""
  leafs(after: ID, first: Int, whose: Condition): LeafConnection!

  """The name of the object being represented by this tree."""
  name: String!

  """This is true if the node note is expanded."""
  noteExpanded: Boolean!

  """
  The sibling trees of this tree before it in the user-specified sort ordering.
  """
  precedingSiblings(after: ID, first: Int, whose: Condition): PrecedingSiblingConnection!

  """
  This is true if the node is selected.  Note that attempts to set this while the node is not visible (collapsed parent, etc.) will silently do nothing.
  """
  selected: Boolean!

  """The currently selected smart group identifier."""
  selectedSmartGroupIdentifier: String

  """The trees of this tree that are selected in the user interface."""
  selectedTrees(after: ID, first: Int, whose: Condition): SelectedTreeConnection!

  """
  The immediate child trees of this tree in the user-specified sort ordering.
  """
  trees(after: ID, first: Int, whose: Condition): TreeConnection!
}

"""A task that is in the document's inbox"""
type InboxTask implements Node & TaskInterface {
  """
  True if the task has a task that must be completed prior to it being actionable.
  """
  blocked: Boolean!

  """
  True if the task is completed. Use the "mark complete" and "mark incomplete" commands to change a task's status.
  """
  completed: Boolean!

  """If true, complete when children are completed."""
  completedByChildren: Boolean!

  """
  The task's date of completion. This can only be modified on a completed task to backdate the completion date.
  """
  completionDate: String

  """
  The task's project, up however many levels of parent tasks.  Inbox tasks aren't considered contained by their provisionalliy assigned container, so if the task is actually an inbox task, this will be missing value.
  """
  containingProject: Project

  """
  When the task was created.  This can only be set when the object is still in the inserted state.  For objects created in the document, it can be passed with the creation properties.  For objects in a quick entry tree, it can be set until the quick entry panel is saved.
  """
  creationDate: String!

  """When the task should become available for action."""
  deferDate: String

  """
  True if the task is dropped. Use the "mark dropped" and "mark incomplete" commands to change a task's status.
  """
  dropped: Boolean!

  """
  The date the task was dropped. This can only be modified on a dropped task to backdate the dropped date.
  """
  droppedDate: String

  """When the task must be finished."""
  dueDate: String

  """
  When the task should become available for action (including inherited).
  """
  effectiveDeferDate: String

  """When the task must be finished (including inherited)."""
  effectiveDueDate: String

  """
  True if the task is completed, or any of it's containing tasks or project are completed.
  """
  effectivelyCompleted: Boolean!

  """
  True if the task is dropped, or any of it's containing tasks or project are dropped.
  """
  effectivelyDropped: Boolean!

  """
  The estimated time, in whole minutes, that this task will take to finish.
  """
  estimatedMinutes: Int

  """True if flagged"""
  flagged: Boolean!
  flattenedTasks(after: ID, first: Int, whose: Condition): FlattenedTaskConnection!

  """The identifier of the task."""
  id: ID! @extractFromObjectDisplayName

  """
  Returns true if the task itself is an inbox task or if the task is contained by an inbox task.
  """
  inInbox: Boolean!

  """When the task was last modified."""
  modificationDate: String!

  """The name of the task."""
  name: String!

  """If the task is the next task of its containing project, next is true."""
  next: Boolean!

  """
  The next defer date if this task repeats on a fixed schedule and it has a defer date.
  """
  nextDeferDate: String

  """
  The next due date if this task repeats on a fixed schedule and it has a due date.
  """
  nextDueDate: String

  """The note of the task."""
  note: RichText!

  """The number of available direct children of this task."""
  numberOfAvailableTasks: Int!

  """The number of completed direct children of this task."""
  numberOfCompletedTasks: Int!

  """The number of direct children of this task."""
  numberOfTasks: Int!

  """
  The task holding this task.  If this is missing value, then this is a top level task -- either the root of a project or an inbox item.
  """
  parentTask: Task

  """
  The task's first tag. Setting this will remove the current first tag on the task, if any and move or add the new tag as the first tag on the task. Setting this to missing value will remove the current first tag and leave any other remaining tags.
  """
  primaryTag: Tag

  """
  The repetition interval of the task, or missing value if it does not repeat. This property is deprecated in favor of “repetition rule” and is here only for backwards compatibility with existing scripts.
  """
  repetition: RepetitionInterval

  """
  The repetition rule for this task, or missing value if it does not repeat.
  """
  repetitionRule: RepetitionRule

  """If true, any children are sequentially dependent."""
  sequential: Boolean!

  """
  When set, the due date and defer date properties will use floating time zones. (Note: if a Task has no due or defer dates assigned, this property will revert to the database’s default setting.)
  """
  shouldUseFloatingTimeZone: Boolean!

  """The tags assigned to this task."""
  tags(after: ID, first: Int, whose: Condition): TagConnection!

  """The tasks having this task as their container."""
  tasks(after: ID, first: Int, whose: Condition): TaskConnection!
}

type InboxTaskConnection implements Connection {
  byId(id: ID!): InboxTask
  edges: [InboxTaskEdge!]!
  pageInfo: PageInfo!
}

type InboxTaskEdge implements Edge {
  cursor: String!
  node: InboxTask!
}

interface InboxTaskInterface implements Node {
  """
  True if the task has a task that must be completed prior to it being actionable.
  """
  blocked: Boolean!

  """
  True if the task is completed. Use the "mark complete" and "mark incomplete" commands to change a task's status.
  """
  completed: Boolean!

  """If true, complete when children are completed."""
  completedByChildren: Boolean!

  """
  The task's date of completion. This can only be modified on a completed task to backdate the completion date.
  """
  completionDate: String

  """
  The task's project, up however many levels of parent tasks.  Inbox tasks aren't considered contained by their provisionalliy assigned container, so if the task is actually an inbox task, this will be missing value.
  """
  containingProject: Project

  """
  When the task was created.  This can only be set when the object is still in the inserted state.  For objects created in the document, it can be passed with the creation properties.  For objects in a quick entry tree, it can be set until the quick entry panel is saved.
  """
  creationDate: String!

  """When the task should become available for action."""
  deferDate: String

  """
  True if the task is dropped. Use the "mark dropped" and "mark incomplete" commands to change a task's status.
  """
  dropped: Boolean!

  """
  The date the task was dropped. This can only be modified on a dropped task to backdate the dropped date.
  """
  droppedDate: String

  """When the task must be finished."""
  dueDate: String

  """
  When the task should become available for action (including inherited).
  """
  effectiveDeferDate: String

  """When the task must be finished (including inherited)."""
  effectiveDueDate: String

  """
  True if the task is completed, or any of it's containing tasks or project are completed.
  """
  effectivelyCompleted: Boolean!

  """
  True if the task is dropped, or any of it's containing tasks or project are dropped.
  """
  effectivelyDropped: Boolean!

  """
  The estimated time, in whole minutes, that this task will take to finish.
  """
  estimatedMinutes: Int

  """True if flagged"""
  flagged: Boolean!
  flattenedTasks(after: ID, first: Int, whose: Condition): FlattenedTaskConnection!

  """The identifier of the task."""
  id: ID! @extractFromObjectDisplayName

  """
  Returns true if the task itself is an inbox task or if the task is contained by an inbox task.
  """
  inInbox: Boolean!

  """When the task was last modified."""
  modificationDate: String!

  """The name of the task."""
  name: String!

  """If the task is the next task of its containing project, next is true."""
  next: Boolean!

  """
  The next defer date if this task repeats on a fixed schedule and it has a defer date.
  """
  nextDeferDate: String

  """
  The next due date if this task repeats on a fixed schedule and it has a due date.
  """
  nextDueDate: String

  """The note of the task."""
  note: RichText!

  """The number of available direct children of this task."""
  numberOfAvailableTasks: Int!

  """The number of completed direct children of this task."""
  numberOfCompletedTasks: Int!

  """The number of direct children of this task."""
  numberOfTasks: Int!

  """
  The task holding this task.  If this is missing value, then this is a top level task -- either the root of a project or an inbox item.
  """
  parentTask: Task

  """
  The task's first tag. Setting this will remove the current first tag on the task, if any and move or add the new tag as the first tag on the task. Setting this to missing value will remove the current first tag and leave any other remaining tags.
  """
  primaryTag: Tag

  """
  The repetition interval of the task, or missing value if it does not repeat. This property is deprecated in favor of “repetition rule” and is here only for backwards compatibility with existing scripts.
  """
  repetition: RepetitionInterval

  """
  The repetition rule for this task, or missing value if it does not repeat.
  """
  repetitionRule: RepetitionRule

  """If true, any children are sequentially dependent."""
  sequential: Boolean!

  """
  When set, the due date and defer date properties will use floating time zones. (Note: if a Task has no due or defer dates assigned, this property will revert to the database’s default setting.)
  """
  shouldUseFloatingTimeZone: Boolean!

  """The tags assigned to this task."""
  tags(after: ID, first: Int, whose: Condition): TagConnection!

  """The tasks having this task as their container."""
  tasks(after: ID, first: Int, whose: Condition): TaskConnection!
}

"""The tree in the sidebar representing the Inbox."""
type InboxTree implements Node & TreeInterface {
  """The ancestor trees of this tree."""
  ancestorTrees(after: ID, first: Int, whose: Condition): AncestorTreeConnection!

  """
  All the descendant trees in the user-specified sort ordering, listing each tree, then its children and so forth.
  """
  descendantTrees(after: ID, first: Int, whose: Condition): DescendantTreeConnection!

  """This is true if the node is expanded."""
  expanded: Boolean!

  """
  The sibling trees of this tree after it in the user-specified sort ordering.
  """
  followingSiblings(after: ID, first: Int, whose: Condition): FollowingSiblingConnection!

  """The identifier of object being represented by this tree."""
  id: ID! @extractFromObjectDisplayName

  """The descendants of this tree that have no children themselves."""
  leafs(after: ID, first: Int, whose: Condition): LeafConnection!

  """The name of the object being represented by this tree."""
  name: String!

  """This is true if the node note is expanded."""
  noteExpanded: Boolean!

  """
  The sibling trees of this tree before it in the user-specified sort ordering.
  """
  precedingSiblings(after: ID, first: Int, whose: Condition): PrecedingSiblingConnection!

  """
  This is true if the node is selected.  Note that attempts to set this while the node is not visible (collapsed parent, etc.) will silently do nothing.
  """
  selected: Boolean!

  """The trees of this tree that are selected in the user interface."""
  selectedTrees(after: ID, first: Int, whose: Condition): SelectedTreeConnection!

  """
  The immediate child trees of this tree in the user-specified sort ordering.
  """
  trees(after: ID, first: Int, whose: Condition): TreeConnection!
}

type InboxTreeConnection implements Connection {
  byId(id: ID!): InboxTree
  edges: [InboxTreeEdge!]!
  pageInfo: PageInfo!
}

type InboxTreeEdge implements Edge {
  cursor: String!
  node: InboxTree!
}

interface InboxTreeInterface implements Node {
  """The ancestor trees of this tree."""
  ancestorTrees(after: ID, first: Int, whose: Condition): AncestorTreeConnection!

  """
  All the descendant trees in the user-specified sort ordering, listing each tree, then its children and so forth.
  """
  descendantTrees(after: ID, first: Int, whose: Condition): DescendantTreeConnection!

  """This is true if the node is expanded."""
  expanded: Boolean!

  """
  The sibling trees of this tree after it in the user-specified sort ordering.
  """
  followingSiblings(after: ID, first: Int, whose: Condition): FollowingSiblingConnection!

  """The identifier of object being represented by this tree."""
  id: ID! @extractFromObjectDisplayName

  """The descendants of this tree that have no children themselves."""
  leafs(after: ID, first: Int, whose: Condition): LeafConnection!

  """The name of the object being represented by this tree."""
  name: String!

  """This is true if the node note is expanded."""
  noteExpanded: Boolean!

  """
  The sibling trees of this tree before it in the user-specified sort ordering.
  """
  precedingSiblings(after: ID, first: Int, whose: Condition): PrecedingSiblingConnection!

  """
  This is true if the node is selected.  Note that attempts to set this while the node is not visible (collapsed parent, etc.) will silently do nothing.
  """
  selected: Boolean!

  """The trees of this tree that are selected in the user interface."""
  selectedTrees(after: ID, first: Int, whose: Condition): SelectedTreeConnection!

  """
  The immediate child trees of this tree in the user-specified sort ordering.
  """
  trees(after: ID, first: Int, whose: Condition): TreeConnection!
}

enum IntervalUnit {
  """Days"""
  DAY

  """Hours"""
  HOUR

  """Minutes"""
  MINUTE

  """Months"""
  MONTH

  """Weeks"""
  WEEK

  """Years"""
  YEAR
}

"""The descendants of a tree that have no children themselves."""
type Leaf implements Node & TreeInterface {
  """The ancestor trees of this tree."""
  ancestorTrees(after: ID, first: Int, whose: Condition): AncestorTreeConnection!

  """
  All the descendant trees in the user-specified sort ordering, listing each tree, then its children and so forth.
  """
  descendantTrees(after: ID, first: Int, whose: Condition): DescendantTreeConnection!

  """This is true if the node is expanded."""
  expanded: Boolean!

  """
  The sibling trees of this tree after it in the user-specified sort ordering.
  """
  followingSiblings(after: ID, first: Int, whose: Condition): FollowingSiblingConnection!

  """The identifier of object being represented by this tree."""
  id: ID! @extractFromObjectDisplayName

  """The descendants of this tree that have no children themselves."""
  leafs(after: ID, first: Int, whose: Condition): LeafConnection!

  """The name of the object being represented by this tree."""
  name: String!

  """This is true if the node note is expanded."""
  noteExpanded: Boolean!

  """
  The sibling trees of this tree before it in the user-specified sort ordering.
  """
  precedingSiblings(after: ID, first: Int, whose: Condition): PrecedingSiblingConnection!

  """
  This is true if the node is selected.  Note that attempts to set this while the node is not visible (collapsed parent, etc.) will silently do nothing.
  """
  selected: Boolean!

  """The trees of this tree that are selected in the user interface."""
  selectedTrees(after: ID, first: Int, whose: Condition): SelectedTreeConnection!

  """
  The immediate child trees of this tree in the user-specified sort ordering.
  """
  trees(after: ID, first: Int, whose: Condition): TreeConnection!
}

type LeafConnection implements Connection {
  byId(id: ID!): Leaf
  edges: [LeafEdge!]!
  pageInfo: PageInfo!
}

type LeafEdge implements Edge {
  cursor: String!
  node: Leaf!
}

interface LeafInterface implements Node {
  """The ancestor trees of this tree."""
  ancestorTrees(after: ID, first: Int, whose: Condition): AncestorTreeConnection!

  """
  All the descendant trees in the user-specified sort ordering, listing each tree, then its children and so forth.
  """
  descendantTrees(after: ID, first: Int, whose: Condition): DescendantTreeConnection!

  """This is true if the node is expanded."""
  expanded: Boolean!

  """
  The sibling trees of this tree after it in the user-specified sort ordering.
  """
  followingSiblings(after: ID, first: Int, whose: Condition): FollowingSiblingConnection!

  """The identifier of object being represented by this tree."""
  id: ID! @extractFromObjectDisplayName

  """The descendants of this tree that have no children themselves."""
  leafs(after: ID, first: Int, whose: Condition): LeafConnection!

  """The name of the object being represented by this tree."""
  name: String!

  """This is true if the node note is expanded."""
  noteExpanded: Boolean!

  """
  The sibling trees of this tree before it in the user-specified sort ordering.
  """
  precedingSiblings(after: ID, first: Int, whose: Condition): PrecedingSiblingConnection!

  """
  This is true if the node is selected.  Note that attempts to set this while the node is not visible (collapsed parent, etc.) will silently do nothing.
  """
  selected: Boolean!

  """The trees of this tree that are selected in the user interface."""
  selectedTrees(after: ID, first: Int, whose: Condition): SelectedTreeConnection!

  """
  The immediate child trees of this tree in the user-specified sort ordering.
  """
  trees(after: ID, first: Int, whose: Condition): TreeConnection!
}

"""The tree in the sidebar representing the top level library of objects."""
type LibraryTree implements Node & TreeInterface {
  """The ancestor trees of this tree."""
  ancestorTrees(after: ID, first: Int, whose: Condition): AncestorTreeConnection!

  """
  All the descendant trees in the user-specified sort ordering, listing each tree, then its children and so forth.
  """
  descendantTrees(after: ID, first: Int, whose: Condition): DescendantTreeConnection!

  """This is true if the node is expanded."""
  expanded: Boolean!

  """
  The sibling trees of this tree after it in the user-specified sort ordering.
  """
  followingSiblings(after: ID, first: Int, whose: Condition): FollowingSiblingConnection!

  """The identifier of object being represented by this tree."""
  id: ID! @extractFromObjectDisplayName

  """The descendants of this tree that have no children themselves."""
  leafs(after: ID, first: Int, whose: Condition): LeafConnection!

  """The name of the object being represented by this tree."""
  name: String!

  """This is true if the node note is expanded."""
  noteExpanded: Boolean!

  """
  The sibling trees of this tree before it in the user-specified sort ordering.
  """
  precedingSiblings(after: ID, first: Int, whose: Condition): PrecedingSiblingConnection!

  """
  This is true if the node is selected.  Note that attempts to set this while the node is not visible (collapsed parent, etc.) will silently do nothing.
  """
  selected: Boolean!

  """The trees of this tree that are selected in the user interface."""
  selectedTrees(after: ID, first: Int, whose: Condition): SelectedTreeConnection!

  """
  The immediate child trees of this tree in the user-specified sort ordering.
  """
  trees(after: ID, first: Int, whose: Condition): TreeConnection!
}

type LibraryTreeConnection implements Connection {
  byId(id: ID!): LibraryTree
  edges: [LibraryTreeEdge!]!
  pageInfo: PageInfo!
}

type LibraryTreeEdge implements Edge {
  cursor: String!
  node: LibraryTree!
}

interface LibraryTreeInterface implements Node {
  """The ancestor trees of this tree."""
  ancestorTrees(after: ID, first: Int, whose: Condition): AncestorTreeConnection!

  """
  All the descendant trees in the user-specified sort ordering, listing each tree, then its children and so forth.
  """
  descendantTrees(after: ID, first: Int, whose: Condition): DescendantTreeConnection!

  """This is true if the node is expanded."""
  expanded: Boolean!

  """
  The sibling trees of this tree after it in the user-specified sort ordering.
  """
  followingSiblings(after: ID, first: Int, whose: Condition): FollowingSiblingConnection!

  """The identifier of object being represented by this tree."""
  id: ID! @extractFromObjectDisplayName

  """The descendants of this tree that have no children themselves."""
  leafs(after: ID, first: Int, whose: Condition): LeafConnection!

  """The name of the object being represented by this tree."""
  name: String!

  """This is true if the node note is expanded."""
  noteExpanded: Boolean!

  """
  The sibling trees of this tree before it in the user-specified sort ordering.
  """
  precedingSiblings(after: ID, first: Int, whose: Condition): PrecedingSiblingConnection!

  """
  This is true if the node is selected.  Note that attempts to set this while the node is not visible (collapsed parent, etc.) will silently do nothing.
  """
  selected: Boolean!

  """The trees of this tree that are selected in the user interface."""
  selectedTrees(after: ID, first: Int, whose: Condition): SelectedTreeConnection!

  """
  The immediate child trees of this tree in the user-specified sort ordering.
  """
  trees(after: ID, first: Int, whose: Condition): TreeConnection!
}

type LocationInformation @recordType {
  """Altitude in meters from sea level."""
  altitude: Float!

  """Latitude in degrees from -90 to +90."""
  latitude: Float!

  """Longitude in degrees from -180 to +180."""
  longitude: Float!

  """A display name for the location."""
  name: String!

  """Radius of accuracy in kilometers, from 0.1km to 10km."""
  radius: Float!

  """Location notification trigger."""
  trigger: LocationTrigger!
}

enum LocationTrigger {
  """notify when arriving at this location"""
  NOTIFY_WHEN_ARRIVING

  """notify when leaving this location"""
  NOTIFY_WHEN_LEAVING
}

"""A named style object."""
type NamedStyle implements Node & StyleInterface {
  attributes(after: ID, first: Int, whose: Condition): AttributeConnection!

  """The name of the font of the style."""
  font: String!

  """
  An identifier for the named style that is unique within its document.  Currently this identifier is not persistent between two different sessions of editing the document.
  """
  id: ID! @extractFromObjectDisplayName

  """The name of the style.  Must be unique within the containing document."""
  name: String!
  namedStyles(after: ID, first: Int, whose: Condition): NamedStyleConnection!
}

type NamedStyleConnection implements Connection {
  byId(id: ID!): NamedStyle
  edges: [NamedStyleEdge!]!
  pageInfo: PageInfo!
}

type NamedStyleEdge implements Edge {
  cursor: String!
  node: NamedStyle!
}

interface NamedStyleInterface implements Node {
  attributes(after: ID, first: Int, whose: Condition): AttributeConnection!

  """The name of the font of the style."""
  font: String!

  """
  An identifier for the named style that is unique within its document.  Currently this identifier is not persistent between two different sessions of editing the document.
  """
  id: ID! @extractFromObjectDisplayName

  """The name of the style.  Must be unique within the containing document."""
  name: String!
  namedStyles(after: ID, first: Int, whose: Condition): NamedStyleConnection!
}

interface Node {
  id: ID! @extractFromObjectDisplayName
}

type PageInfo {
  endCursor: String!
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String!
}

"""This subdivides the text into paragraphs."""
type Paragraph implements Node {
  attachments(after: ID, first: Int, whose: Condition): AttachmentConnection!
  attributeRuns(after: ID, first: Int, whose: Condition): AttributeRunConnection!
  characters(after: ID, first: Int, whose: Condition): CharacterConnection!
  fileAttachments(after: ID, first: Int, whose: Condition): FileAttachmentConnection!

  """The name of the font of the first character."""
  font: String!
  id: ID! @extractFromObjectDisplayName
  paragraphs(after: ID, first: Int, whose: Condition): ParagraphConnection!

  """The size in points of the first character."""
  size: Int!

  """The style of the text."""
  style: Style!

  """The plain text contents of the rich text."""
  text: String!
  words(after: ID, first: Int, whose: Condition): WordConnection!
}

type ParagraphConnection implements Connection {
  byId(id: ID!): Paragraph
  edges: [ParagraphEdge!]!
  pageInfo: PageInfo!
}

type ParagraphEdge implements Edge {
  cursor: String!
  node: Paragraph!
}

interface ParagraphInterface implements Node {
  attachments(after: ID, first: Int, whose: Condition): AttachmentConnection!
  attributeRuns(after: ID, first: Int, whose: Condition): AttributeRunConnection!
  characters(after: ID, first: Int, whose: Condition): CharacterConnection!
  fileAttachments(after: ID, first: Int, whose: Condition): FileAttachmentConnection!

  """The name of the font of the first character."""
  font: String!
  id: ID! @extractFromObjectDisplayName
  paragraphs(after: ID, first: Int, whose: Condition): ParagraphConnection!

  """The size in points of the first character."""
  size: Int!

  """The style of the text."""
  style: Style!

  """The plain text contents of the rich text."""
  text: String!
  words(after: ID, first: Int, whose: Condition): WordConnection!
}

"""A perspective."""
type Perspective implements Node & PerspectiveInterface {
  """The identifier of the perspective."""
  id: ID! @extractFromObjectDisplayName

  """The name of the perspective."""
  name: String!
}

type PerspectiveConnection implements Connection {
  byId(id: ID!): PerspectiveInterface
  edges: [PerspectiveEdge!]!
  pageInfo: PageInfo!
}

type PerspectiveEdge implements Edge {
  cursor: String!
  node: PerspectiveInterface!
}

interface PerspectiveInterface implements Node {
  """The identifier of the perspective."""
  id: ID! @extractFromObjectDisplayName

  """The name of the perspective."""
  name: String!
}

"""
The sibling trees of this tree before it in the user-specified sort ordering.
"""
type PrecedingSibling implements Node & TreeInterface {
  """The ancestor trees of this tree."""
  ancestorTrees(after: ID, first: Int, whose: Condition): AncestorTreeConnection!

  """
  All the descendant trees in the user-specified sort ordering, listing each tree, then its children and so forth.
  """
  descendantTrees(after: ID, first: Int, whose: Condition): DescendantTreeConnection!

  """This is true if the node is expanded."""
  expanded: Boolean!

  """
  The sibling trees of this tree after it in the user-specified sort ordering.
  """
  followingSiblings(after: ID, first: Int, whose: Condition): FollowingSiblingConnection!

  """The identifier of object being represented by this tree."""
  id: ID! @extractFromObjectDisplayName

  """The descendants of this tree that have no children themselves."""
  leafs(after: ID, first: Int, whose: Condition): LeafConnection!

  """The name of the object being represented by this tree."""
  name: String!

  """This is true if the node note is expanded."""
  noteExpanded: Boolean!

  """
  The sibling trees of this tree before it in the user-specified sort ordering.
  """
  precedingSiblings(after: ID, first: Int, whose: Condition): PrecedingSiblingConnection!

  """
  This is true if the node is selected.  Note that attempts to set this while the node is not visible (collapsed parent, etc.) will silently do nothing.
  """
  selected: Boolean!

  """The trees of this tree that are selected in the user interface."""
  selectedTrees(after: ID, first: Int, whose: Condition): SelectedTreeConnection!

  """
  The immediate child trees of this tree in the user-specified sort ordering.
  """
  trees(after: ID, first: Int, whose: Condition): TreeConnection!
}

type PrecedingSiblingConnection implements Connection {
  byId(id: ID!): PrecedingSibling
  edges: [PrecedingSiblingEdge!]!
  pageInfo: PageInfo!
}

type PrecedingSiblingEdge implements Edge {
  cursor: String!
  node: PrecedingSibling!
}

interface PrecedingSiblingInterface implements Node {
  """The ancestor trees of this tree."""
  ancestorTrees(after: ID, first: Int, whose: Condition): AncestorTreeConnection!

  """
  All the descendant trees in the user-specified sort ordering, listing each tree, then its children and so forth.
  """
  descendantTrees(after: ID, first: Int, whose: Condition): DescendantTreeConnection!

  """This is true if the node is expanded."""
  expanded: Boolean!

  """
  The sibling trees of this tree after it in the user-specified sort ordering.
  """
  followingSiblings(after: ID, first: Int, whose: Condition): FollowingSiblingConnection!

  """The identifier of object being represented by this tree."""
  id: ID! @extractFromObjectDisplayName

  """The descendants of this tree that have no children themselves."""
  leafs(after: ID, first: Int, whose: Condition): LeafConnection!

  """The name of the object being represented by this tree."""
  name: String!

  """This is true if the node note is expanded."""
  noteExpanded: Boolean!

  """
  The sibling trees of this tree before it in the user-specified sort ordering.
  """
  precedingSiblings(after: ID, first: Int, whose: Condition): PrecedingSiblingConnection!

  """
  This is true if the node is selected.  Note that attempts to set this while the node is not visible (collapsed parent, etc.) will silently do nothing.
  """
  selected: Boolean!

  """The trees of this tree that are selected in the user interface."""
  selectedTrees(after: ID, first: Int, whose: Condition): SelectedTreeConnection!

  """
  The immediate child trees of this tree in the user-specified sort ordering.
  """
  trees(after: ID, first: Int, whose: Condition): TreeConnection!
}

"""Application preference"""
type Preference implements Node {
  """The identifier of the preference."""
  id: ID! @extractFromObjectDisplayName
}

type PreferenceConnection implements Connection {
  byId(id: ID!): Preference
  edges: [PreferenceEdge!]!
  pageInfo: PageInfo!
}

type PreferenceEdge implements Edge {
  cursor: String!
  node: Preference!
}

interface PreferenceInterface implements Node {
  """The identifier of the preference."""
  id: ID! @extractFromObjectDisplayName
}

"""A project."""
type Project implements Node & ProjectInterface & SectionInterface {
  """
  True if the project has a project that must be completed prior to it being actionable.
  """
  blocked: Boolean!

  """
  True if the project is completed. Use the "mark complete" and "mark incomplete" commands to change a project's status.
  """
  completed: Boolean!

  """If true, complete when children are completed."""
  completedByChildren: Boolean!

  """
  The project's date of completion. This can only be modified on a completed project to backdate the completion date.
  """
  completionDate: String

  """
  When the project was created.  This can only be set when the object is still in the inserted state.  For objects created in the document, it can be passed with the creation properties.  For objects in a quick entry tree, it can be set until the quick entry panel is saved.
  """
  creationDate: String!

  """
  True if the project is the default holder of sington actions.  Only one project can have this flag set; setting it on a project will clear it on any other project having it.  Setting this to true will set 'singleton action holder' to true if not already so set.
  """
  defaultSingletonActionHolder: Boolean!

  """When the project should become available for action."""
  deferDate: String

  """
  True if the project is dropped. Use the "mark dropped" and "mark incomplete" commands to change a project's status.
  """
  dropped: Boolean!

  """
  The date the project was dropped. This can only be modified on a dropped project to backdate the dropped date.
  """
  droppedDate: String

  """When the project must be finished."""
  dueDate: String

  """
  When the project should become available for action (including inherited).
  """
  effectiveDeferDate: String

  """When the project must be finished (including inherited)."""
  effectiveDueDate: String

  """The effective status of the project."""
  effectiveStatus: ProjectStatus!

  """True if the project is completed"""
  effectivelyCompleted: Boolean!

  """True if the project is dropped"""
  effectivelyDropped: Boolean!

  """
  The estimated time, in whole minutes, that this project will take to finish.
  """
  estimatedMinutes: Int

  """True if flagged"""
  flagged: Boolean!

  """
  The folder of the project, or missing value if it is contained directly by the document.
  """
  folder: Folder

  """The identifier of the project."""
  id: ID! @extractFromObjectDisplayName

  """When the project was last reviewed."""
  lastReviewDate: String!

  """When the project was last modified."""
  modificationDate: String!

  """The name of the project."""
  name: String!

  """
  The next defer date if this project repeats on a fixed schedule and it has a defer date.
  """
  nextDeferDate: String

  """
  The next due date if this project repeats on a fixed schedule and it has a due date.
  """
  nextDueDate: String

  """
  When the project should next be reviewed. Setting this to missing value will set the review date based off the last review date and review interval.
  """
  nextReviewDate: String

  """The next actionable child of this project."""
  nextTask: Task

  """The note of the project."""
  note: RichText!

  """The number of available direct children of this project."""
  numberOfAvailableTasks: Int!

  """The number of completed direct children of this project."""
  numberOfCompletedTasks: Int!

  """The number of direct children of this project."""
  numberOfTasks: Int!

  """
  The project's first tag. Setting this will remove the current first tag on the project, if any and move or add the new tag as the first tag on the project. Setting this to missing value will remove the current first tag and leave any other remaining tags.
  """
  primaryTag: Tag

  """
  The repetition interval of the project, or missing value if it does not repeat. This property is deprecated in favor of “repetition rule” and is here only for backwards compatibility with existing scripts.
  """
  repetition: RepetitionInterval

  """
  The repetition rule for this project, or missing value if it does not repeat.
  """
  repetitionRule: RepetitionRule

  """The review interval for the project."""
  reviewInterval: RepetitionInterval!

  """
  The root task of this project, holding the project's name, note, dates and child tasks.
  """
  rootTask: Task!

  """If true, any children are sequentially dependent."""
  sequential: Boolean!

  """
  When set, the due date and defer date properties will use floating time zones. (Note: if a Task has no due or defer dates assigned, this property will revert to the database’s default setting.)
  """
  shouldUseFloatingTimeZone: Boolean!

  """True if the project contains singleton actions."""
  singletonActionHolder: Boolean!

  """The status of the project."""
  status: ProjectStatus!
}

type ProjectConnection implements Connection {
  byId(id: ID!): ProjectInterface
  edges: [ProjectEdge!]!
  pageInfo: PageInfo!
}

type ProjectEdge implements Edge {
  cursor: String!
  node: ProjectInterface!
}

interface ProjectInterface implements Node {
  """
  True if the project has a project that must be completed prior to it being actionable.
  """
  blocked: Boolean!

  """
  True if the project is completed. Use the "mark complete" and "mark incomplete" commands to change a project's status.
  """
  completed: Boolean!

  """If true, complete when children are completed."""
  completedByChildren: Boolean!

  """
  The project's date of completion. This can only be modified on a completed project to backdate the completion date.
  """
  completionDate: String

  """
  When the project was created.  This can only be set when the object is still in the inserted state.  For objects created in the document, it can be passed with the creation properties.  For objects in a quick entry tree, it can be set until the quick entry panel is saved.
  """
  creationDate: String!

  """
  True if the project is the default holder of sington actions.  Only one project can have this flag set; setting it on a project will clear it on any other project having it.  Setting this to true will set 'singleton action holder' to true if not already so set.
  """
  defaultSingletonActionHolder: Boolean!

  """When the project should become available for action."""
  deferDate: String

  """
  True if the project is dropped. Use the "mark dropped" and "mark incomplete" commands to change a project's status.
  """
  dropped: Boolean!

  """
  The date the project was dropped. This can only be modified on a dropped project to backdate the dropped date.
  """
  droppedDate: String

  """When the project must be finished."""
  dueDate: String

  """
  When the project should become available for action (including inherited).
  """
  effectiveDeferDate: String

  """When the project must be finished (including inherited)."""
  effectiveDueDate: String

  """The effective status of the project."""
  effectiveStatus: ProjectStatus!

  """True if the project is completed"""
  effectivelyCompleted: Boolean!

  """True if the project is dropped"""
  effectivelyDropped: Boolean!

  """
  The estimated time, in whole minutes, that this project will take to finish.
  """
  estimatedMinutes: Int

  """True if flagged"""
  flagged: Boolean!

  """
  The folder of the project, or missing value if it is contained directly by the document.
  """
  folder: Folder

  """The identifier of the project."""
  id: ID! @extractFromObjectDisplayName

  """When the project was last reviewed."""
  lastReviewDate: String!

  """When the project was last modified."""
  modificationDate: String!

  """The name of the project."""
  name: String!

  """
  The next defer date if this project repeats on a fixed schedule and it has a defer date.
  """
  nextDeferDate: String

  """
  The next due date if this project repeats on a fixed schedule and it has a due date.
  """
  nextDueDate: String

  """
  When the project should next be reviewed. Setting this to missing value will set the review date based off the last review date and review interval.
  """
  nextReviewDate: String

  """The next actionable child of this project."""
  nextTask: Task

  """The note of the project."""
  note: RichText!

  """The number of available direct children of this project."""
  numberOfAvailableTasks: Int!

  """The number of completed direct children of this project."""
  numberOfCompletedTasks: Int!

  """The number of direct children of this project."""
  numberOfTasks: Int!

  """
  The project's first tag. Setting this will remove the current first tag on the project, if any and move or add the new tag as the first tag on the project. Setting this to missing value will remove the current first tag and leave any other remaining tags.
  """
  primaryTag: Tag

  """
  The repetition interval of the project, or missing value if it does not repeat. This property is deprecated in favor of “repetition rule” and is here only for backwards compatibility with existing scripts.
  """
  repetition: RepetitionInterval

  """
  The repetition rule for this project, or missing value if it does not repeat.
  """
  repetitionRule: RepetitionRule

  """The review interval for the project."""
  reviewInterval: RepetitionInterval!

  """
  The root task of this project, holding the project's name, note, dates and child tasks.
  """
  rootTask: Task!

  """If true, any children are sequentially dependent."""
  sequential: Boolean!

  """
  When set, the due date and defer date properties will use floating time zones. (Note: if a Task has no due or defer dates assigned, this property will revert to the database’s default setting.)
  """
  shouldUseFloatingTimeZone: Boolean!

  """True if the project contains singleton actions."""
  singletonActionHolder: Boolean!

  """The status of the project."""
  status: ProjectStatus!
}

enum ProjectStatus {
  """Active"""
  ACTIVE_STATUS

  """Done"""
  DONE_STATUS

  """Dropped"""
  DROPPED_STATUS

  """On Hold"""
  ON_HOLD_STATUS
}

type Query {
  application: Application!
}

"""The Quick Entry panel."""
type QuickEntryTree implements Node & TreeInterface {
  """The ancestor trees of this tree."""
  ancestorTrees(after: ID, first: Int, whose: Condition): AncestorTreeConnection!

  """Deprecated; use tags."""
  deprecatedContexts(after: ID, first: Int, whose: Condition): DeprecatedContextConnection!

  """
  All the descendant trees in the user-specified sort ordering, listing each tree, then its children and so forth.
  """
  descendantTrees(after: ID, first: Int, whose: Condition): DescendantTreeConnection!

  """This is true if the node is expanded."""
  expanded: Boolean!
  folders(after: ID, first: Int, whose: Condition): FolderConnection!

  """
  The sibling trees of this tree after it in the user-specified sort ordering.
  """
  followingSiblings(after: ID, first: Int, whose: Condition): FollowingSiblingConnection!

  """The identifier of object being represented by this tree."""
  id: ID! @extractFromObjectDisplayName
  inboxTasks(after: ID, first: Int, whose: Condition): InboxTaskConnection!

  """The descendants of this tree that have no children themselves."""
  leafs(after: ID, first: Int, whose: Condition): LeafConnection!

  """The name of the object being represented by this tree."""
  name: String!

  """This is true if the node note is expanded."""
  noteExpanded: Boolean!

  """
  The sibling trees of this tree before it in the user-specified sort ordering.
  """
  precedingSiblings(after: ID, first: Int, whose: Condition): PrecedingSiblingConnection!
  projects(after: ID, first: Int, whose: Condition): ProjectConnection!

  """
  This is true if the node is selected.  Note that attempts to set this while the node is not visible (collapsed parent, etc.) will silently do nothing.
  """
  selected: Boolean!

  """The trees of this tree that are selected in the user interface."""
  selectedTrees(after: ID, first: Int, whose: Condition): SelectedTreeConnection!
  tags(after: ID, first: Int, whose: Condition): TagConnection!

  """
  The immediate child trees of this tree in the user-specified sort ordering.
  """
  trees(after: ID, first: Int, whose: Condition): TreeConnection!

  """Whether the quick entry panel is currently visible."""
  visible: Boolean!
}

type QuickEntryTreeConnection implements Connection {
  byId(id: ID!): QuickEntryTree
  edges: [QuickEntryTreeEdge!]!
  pageInfo: PageInfo!
}

type QuickEntryTreeEdge implements Edge {
  cursor: String!
  node: QuickEntryTree!
}

interface QuickEntryTreeInterface implements Node {
  """The ancestor trees of this tree."""
  ancestorTrees(after: ID, first: Int, whose: Condition): AncestorTreeConnection!

  """Deprecated; use tags."""
  deprecatedContexts(after: ID, first: Int, whose: Condition): DeprecatedContextConnection!

  """
  All the descendant trees in the user-specified sort ordering, listing each tree, then its children and so forth.
  """
  descendantTrees(after: ID, first: Int, whose: Condition): DescendantTreeConnection!

  """This is true if the node is expanded."""
  expanded: Boolean!
  folders(after: ID, first: Int, whose: Condition): FolderConnection!

  """
  The sibling trees of this tree after it in the user-specified sort ordering.
  """
  followingSiblings(after: ID, first: Int, whose: Condition): FollowingSiblingConnection!

  """The identifier of object being represented by this tree."""
  id: ID! @extractFromObjectDisplayName
  inboxTasks(after: ID, first: Int, whose: Condition): InboxTaskConnection!

  """The descendants of this tree that have no children themselves."""
  leafs(after: ID, first: Int, whose: Condition): LeafConnection!

  """The name of the object being represented by this tree."""
  name: String!

  """This is true if the node note is expanded."""
  noteExpanded: Boolean!

  """
  The sibling trees of this tree before it in the user-specified sort ordering.
  """
  precedingSiblings(after: ID, first: Int, whose: Condition): PrecedingSiblingConnection!
  projects(after: ID, first: Int, whose: Condition): ProjectConnection!

  """
  This is true if the node is selected.  Note that attempts to set this while the node is not visible (collapsed parent, etc.) will silently do nothing.
  """
  selected: Boolean!

  """The trees of this tree that are selected in the user interface."""
  selectedTrees(after: ID, first: Int, whose: Condition): SelectedTreeConnection!
  tags(after: ID, first: Int, whose: Condition): TagConnection!

  """
  The immediate child trees of this tree in the user-specified sort ordering.
  """
  trees(after: ID, first: Int, whose: Condition): TreeConnection!

  """Whether the quick entry panel is currently visible."""
  visible: Boolean!
}

"""
A task that is not complete, though it may be blocked.  This is simply a filter on the existing tasks and should be considred a read-only element.  These cannot be created directly; instead create a normal task.
"""
type RemainingTask implements Node & TaskInterface {
  """
  True if the task has a task that must be completed prior to it being actionable.
  """
  blocked: Boolean!

  """
  True if the task is completed. Use the "mark complete" and "mark incomplete" commands to change a task's status.
  """
  completed: Boolean!

  """If true, complete when children are completed."""
  completedByChildren: Boolean!

  """
  The task's date of completion. This can only be modified on a completed task to backdate the completion date.
  """
  completionDate: String

  """
  The task's project, up however many levels of parent tasks.  Inbox tasks aren't considered contained by their provisionalliy assigned container, so if the task is actually an inbox task, this will be missing value.
  """
  containingProject: Project

  """
  When the task was created.  This can only be set when the object is still in the inserted state.  For objects created in the document, it can be passed with the creation properties.  For objects in a quick entry tree, it can be set until the quick entry panel is saved.
  """
  creationDate: String!

  """When the task should become available for action."""
  deferDate: String

  """
  True if the task is dropped. Use the "mark dropped" and "mark incomplete" commands to change a task's status.
  """
  dropped: Boolean!

  """
  The date the task was dropped. This can only be modified on a dropped task to backdate the dropped date.
  """
  droppedDate: String

  """When the task must be finished."""
  dueDate: String

  """
  When the task should become available for action (including inherited).
  """
  effectiveDeferDate: String

  """When the task must be finished (including inherited)."""
  effectiveDueDate: String

  """
  True if the task is completed, or any of it's containing tasks or project are completed.
  """
  effectivelyCompleted: Boolean!

  """
  True if the task is dropped, or any of it's containing tasks or project are dropped.
  """
  effectivelyDropped: Boolean!

  """
  The estimated time, in whole minutes, that this task will take to finish.
  """
  estimatedMinutes: Int

  """True if flagged"""
  flagged: Boolean!
  flattenedTasks(after: ID, first: Int, whose: Condition): FlattenedTaskConnection!

  """The identifier of the task."""
  id: ID! @extractFromObjectDisplayName

  """
  Returns true if the task itself is an inbox task or if the task is contained by an inbox task.
  """
  inInbox: Boolean!

  """When the task was last modified."""
  modificationDate: String!

  """The name of the task."""
  name: String!

  """If the task is the next task of its containing project, next is true."""
  next: Boolean!

  """
  The next defer date if this task repeats on a fixed schedule and it has a defer date.
  """
  nextDeferDate: String

  """
  The next due date if this task repeats on a fixed schedule and it has a due date.
  """
  nextDueDate: String

  """The note of the task."""
  note: RichText!

  """The number of available direct children of this task."""
  numberOfAvailableTasks: Int!

  """The number of completed direct children of this task."""
  numberOfCompletedTasks: Int!

  """The number of direct children of this task."""
  numberOfTasks: Int!

  """
  The task holding this task.  If this is missing value, then this is a top level task -- either the root of a project or an inbox item.
  """
  parentTask: Task

  """
  The task's first tag. Setting this will remove the current first tag on the task, if any and move or add the new tag as the first tag on the task. Setting this to missing value will remove the current first tag and leave any other remaining tags.
  """
  primaryTag: Tag

  """
  The repetition interval of the task, or missing value if it does not repeat. This property is deprecated in favor of “repetition rule” and is here only for backwards compatibility with existing scripts.
  """
  repetition: RepetitionInterval

  """
  The repetition rule for this task, or missing value if it does not repeat.
  """
  repetitionRule: RepetitionRule

  """If true, any children are sequentially dependent."""
  sequential: Boolean!

  """
  When set, the due date and defer date properties will use floating time zones. (Note: if a Task has no due or defer dates assigned, this property will revert to the database’s default setting.)
  """
  shouldUseFloatingTimeZone: Boolean!

  """The tags assigned to this task."""
  tags(after: ID, first: Int, whose: Condition): TagConnection!

  """The tasks having this task as their container."""
  tasks(after: ID, first: Int, whose: Condition): TaskConnection!
}

type RemainingTaskConnection implements Connection {
  byId(id: ID!): RemainingTask
  edges: [RemainingTaskEdge!]!
  pageInfo: PageInfo!
}

type RemainingTaskEdge implements Edge {
  cursor: String!
  node: RemainingTask!
}

interface RemainingTaskInterface implements Node {
  """
  True if the task has a task that must be completed prior to it being actionable.
  """
  blocked: Boolean!

  """
  True if the task is completed. Use the "mark complete" and "mark incomplete" commands to change a task's status.
  """
  completed: Boolean!

  """If true, complete when children are completed."""
  completedByChildren: Boolean!

  """
  The task's date of completion. This can only be modified on a completed task to backdate the completion date.
  """
  completionDate: String

  """
  The task's project, up however many levels of parent tasks.  Inbox tasks aren't considered contained by their provisionalliy assigned container, so if the task is actually an inbox task, this will be missing value.
  """
  containingProject: Project

  """
  When the task was created.  This can only be set when the object is still in the inserted state.  For objects created in the document, it can be passed with the creation properties.  For objects in a quick entry tree, it can be set until the quick entry panel is saved.
  """
  creationDate: String!

  """When the task should become available for action."""
  deferDate: String

  """
  True if the task is dropped. Use the "mark dropped" and "mark incomplete" commands to change a task's status.
  """
  dropped: Boolean!

  """
  The date the task was dropped. This can only be modified on a dropped task to backdate the dropped date.
  """
  droppedDate: String

  """When the task must be finished."""
  dueDate: String

  """
  When the task should become available for action (including inherited).
  """
  effectiveDeferDate: String

  """When the task must be finished (including inherited)."""
  effectiveDueDate: String

  """
  True if the task is completed, or any of it's containing tasks or project are completed.
  """
  effectivelyCompleted: Boolean!

  """
  True if the task is dropped, or any of it's containing tasks or project are dropped.
  """
  effectivelyDropped: Boolean!

  """
  The estimated time, in whole minutes, that this task will take to finish.
  """
  estimatedMinutes: Int

  """True if flagged"""
  flagged: Boolean!
  flattenedTasks(after: ID, first: Int, whose: Condition): FlattenedTaskConnection!

  """The identifier of the task."""
  id: ID! @extractFromObjectDisplayName

  """
  Returns true if the task itself is an inbox task or if the task is contained by an inbox task.
  """
  inInbox: Boolean!

  """When the task was last modified."""
  modificationDate: String!

  """The name of the task."""
  name: String!

  """If the task is the next task of its containing project, next is true."""
  next: Boolean!

  """
  The next defer date if this task repeats on a fixed schedule and it has a defer date.
  """
  nextDeferDate: String

  """
  The next due date if this task repeats on a fixed schedule and it has a due date.
  """
  nextDueDate: String

  """The note of the task."""
  note: RichText!

  """The number of available direct children of this task."""
  numberOfAvailableTasks: Int!

  """The number of completed direct children of this task."""
  numberOfCompletedTasks: Int!

  """The number of direct children of this task."""
  numberOfTasks: Int!

  """
  The task holding this task.  If this is missing value, then this is a top level task -- either the root of a project or an inbox item.
  """
  parentTask: Task

  """
  The task's first tag. Setting this will remove the current first tag on the task, if any and move or add the new tag as the first tag on the task. Setting this to missing value will remove the current first tag and leave any other remaining tags.
  """
  primaryTag: Tag

  """
  The repetition interval of the task, or missing value if it does not repeat. This property is deprecated in favor of “repetition rule” and is here only for backwards compatibility with existing scripts.
  """
  repetition: RepetitionInterval

  """
  The repetition rule for this task, or missing value if it does not repeat.
  """
  repetitionRule: RepetitionRule

  """If true, any children are sequentially dependent."""
  sequential: Boolean!

  """
  When set, the due date and defer date properties will use floating time zones. (Note: if a Task has no due or defer dates assigned, this property will revert to the database’s default setting.)
  """
  shouldUseFloatingTimeZone: Boolean!

  """The tags assigned to this task."""
  tags(after: ID, first: Int, whose: Condition): TagConnection!

  """The tasks having this task as their container."""
  tasks(after: ID, first: Int, whose: Condition): TaskConnection!
}

type RepetitionInterval @recordType {
  """
  If fixed, the next repetition will be relative to a fixed calendar.  If sliding, the next repetition will be calculated when needed.
  """
  fixed: Boolean!

  """The count of the repetition interval."""
  steps: Int!

  """The units of the repetition interval."""
  unit: IntervalUnit!
}

enum RepetitionMethod {
  """Due again after completion."""
  DUE_AFTER_COMPLETION

  """Repeat on a fixed schedule."""
  FIXED_REPETITION

  """Start again after completion."""
  START_AFTER_COMPLETION
}

type RepetitionRule @recordType {
  """The iCalendar (RFC 2445) string describing the recurrence."""
  recurrence: String!

  """
  The repetition method. If fixed, the next repetition will be relative to a fixed calendar.  If sliding, the next repetition will be calculated when the action or inbox item is resolved.
  """
  repetitionMethod: RepetitionMethod!
}

scalar RichText

"""A portion of a folder or document; either a project or a folder."""
type Section implements Node & SectionInterface {
  """The identifier of the project or folder."""
  id: ID! @extractFromObjectDisplayName

  """The name of the project or folder."""
  name: String!
}

type SectionConnection implements Connection {
  byId(id: ID!): SectionInterface
  edges: [SectionEdge!]!
  pageInfo: PageInfo!
}

type SectionEdge implements Edge {
  cursor: String!
  node: SectionInterface!
}

interface SectionInterface implements Node {
  """The identifier of the project or folder."""
  id: ID! @extractFromObjectDisplayName

  """The name of the project or folder."""
  name: String!
}

"""
The trees of this tree that are selected in the user interface, possibly including this tree.
"""
type SelectedTree implements Node & TreeInterface {
  """The ancestor trees of this tree."""
  ancestorTrees(after: ID, first: Int, whose: Condition): AncestorTreeConnection!

  """
  All the descendant trees in the user-specified sort ordering, listing each tree, then its children and so forth.
  """
  descendantTrees(after: ID, first: Int, whose: Condition): DescendantTreeConnection!

  """This is true if the node is expanded."""
  expanded: Boolean!

  """
  The sibling trees of this tree after it in the user-specified sort ordering.
  """
  followingSiblings(after: ID, first: Int, whose: Condition): FollowingSiblingConnection!

  """The identifier of object being represented by this tree."""
  id: ID! @extractFromObjectDisplayName

  """The descendants of this tree that have no children themselves."""
  leafs(after: ID, first: Int, whose: Condition): LeafConnection!

  """The name of the object being represented by this tree."""
  name: String!

  """This is true if the node note is expanded."""
  noteExpanded: Boolean!

  """
  The sibling trees of this tree before it in the user-specified sort ordering.
  """
  precedingSiblings(after: ID, first: Int, whose: Condition): PrecedingSiblingConnection!

  """
  This is true if the node is selected.  Note that attempts to set this while the node is not visible (collapsed parent, etc.) will silently do nothing.
  """
  selected: Boolean!

  """The trees of this tree that are selected in the user interface."""
  selectedTrees(after: ID, first: Int, whose: Condition): SelectedTreeConnection!

  """
  The immediate child trees of this tree in the user-specified sort ordering.
  """
  trees(after: ID, first: Int, whose: Condition): TreeConnection!
}

type SelectedTreeConnection implements Connection {
  byId(id: ID!): SelectedTree
  edges: [SelectedTreeEdge!]!
  pageInfo: PageInfo!
}

type SelectedTreeEdge implements Edge {
  cursor: String!
  node: SelectedTree!
}

interface SelectedTreeInterface implements Node {
  """The ancestor trees of this tree."""
  ancestorTrees(after: ID, first: Int, whose: Condition): AncestorTreeConnection!

  """
  All the descendant trees in the user-specified sort ordering, listing each tree, then its children and so forth.
  """
  descendantTrees(after: ID, first: Int, whose: Condition): DescendantTreeConnection!

  """This is true if the node is expanded."""
  expanded: Boolean!

  """
  The sibling trees of this tree after it in the user-specified sort ordering.
  """
  followingSiblings(after: ID, first: Int, whose: Condition): FollowingSiblingConnection!

  """The identifier of object being represented by this tree."""
  id: ID! @extractFromObjectDisplayName

  """The descendants of this tree that have no children themselves."""
  leafs(after: ID, first: Int, whose: Condition): LeafConnection!

  """The name of the object being represented by this tree."""
  name: String!

  """This is true if the node note is expanded."""
  noteExpanded: Boolean!

  """
  The sibling trees of this tree before it in the user-specified sort ordering.
  """
  precedingSiblings(after: ID, first: Int, whose: Condition): PrecedingSiblingConnection!

  """
  This is true if the node is selected.  Note that attempts to set this while the node is not visible (collapsed parent, etc.) will silently do nothing.
  """
  selected: Boolean!

  """The trees of this tree that are selected in the user interface."""
  selectedTrees(after: ID, first: Int, whose: Condition): SelectedTreeConnection!

  """
  The immediate child trees of this tree in the user-specified sort ordering.
  """
  trees(after: ID, first: Int, whose: Condition): TreeConnection!
}

"""Document setting"""
type Setting implements Node {
  """The identifier of the setting."""
  id: ID! @extractFromObjectDisplayName
}

type SettingConnection implements Connection {
  byId(id: ID!): Setting
  edges: [SettingEdge!]!
  pageInfo: PageInfo!
}

type SettingEdge implements Edge {
  cursor: String!
  node: Setting!
}

interface SettingInterface implements Node {
  """The identifier of the setting."""
  id: ID! @extractFromObjectDisplayName
}

"""The tree of objects in the window sidebar."""
type SidebarTree implements Node & SidebarTreeInterface & TreeInterface {
  """The ancestor trees of this tree."""
  ancestorTrees(after: ID, first: Int, whose: Condition): AncestorTreeConnection!

  """
  The list of possible smart group identifiers that can be set as the selected smart group identifier.
  """
  availableSmartGroupIdentifiers: [String!]!

  """
  All the descendant trees in the user-specified sort ordering, listing each tree, then its children and so forth.
  """
  descendantTrees(after: ID, first: Int, whose: Condition): DescendantTreeConnection!

  """This is true if the node is expanded."""
  expanded: Boolean!

  """
  The sibling trees of this tree after it in the user-specified sort ordering.
  """
  followingSiblings(after: ID, first: Int, whose: Condition): FollowingSiblingConnection!

  """The identifier of object being represented by this tree."""
  id: ID! @extractFromObjectDisplayName

  """The descendants of this tree that have no children themselves."""
  leafs(after: ID, first: Int, whose: Condition): LeafConnection!

  """The name of the object being represented by this tree."""
  name: String!

  """This is true if the node note is expanded."""
  noteExpanded: Boolean!

  """
  The sibling trees of this tree before it in the user-specified sort ordering.
  """
  precedingSiblings(after: ID, first: Int, whose: Condition): PrecedingSiblingConnection!

  """
  This is true if the node is selected.  Note that attempts to set this while the node is not visible (collapsed parent, etc.) will silently do nothing.
  """
  selected: Boolean!

  """The currently selected smart group identifier."""
  selectedSmartGroupIdentifier: String

  """The trees of this tree that are selected in the user interface."""
  selectedTrees(after: ID, first: Int, whose: Condition): SelectedTreeConnection!

  """
  The immediate child trees of this tree in the user-specified sort ordering.
  """
  trees(after: ID, first: Int, whose: Condition): TreeConnection!
}

type SidebarTreeConnection implements Connection {
  byId(id: ID!): SidebarTreeInterface
  edges: [SidebarTreeEdge!]!
  pageInfo: PageInfo!
}

type SidebarTreeEdge implements Edge {
  cursor: String!
  node: SidebarTreeInterface!
}

interface SidebarTreeInterface implements Node {
  """The ancestor trees of this tree."""
  ancestorTrees(after: ID, first: Int, whose: Condition): AncestorTreeConnection!

  """
  The list of possible smart group identifiers that can be set as the selected smart group identifier.
  """
  availableSmartGroupIdentifiers: [String!]!

  """
  All the descendant trees in the user-specified sort ordering, listing each tree, then its children and so forth.
  """
  descendantTrees(after: ID, first: Int, whose: Condition): DescendantTreeConnection!

  """This is true if the node is expanded."""
  expanded: Boolean!

  """
  The sibling trees of this tree after it in the user-specified sort ordering.
  """
  followingSiblings(after: ID, first: Int, whose: Condition): FollowingSiblingConnection!

  """The identifier of object being represented by this tree."""
  id: ID! @extractFromObjectDisplayName

  """The descendants of this tree that have no children themselves."""
  leafs(after: ID, first: Int, whose: Condition): LeafConnection!

  """The name of the object being represented by this tree."""
  name: String!

  """This is true if the node note is expanded."""
  noteExpanded: Boolean!

  """
  The sibling trees of this tree before it in the user-specified sort ordering.
  """
  precedingSiblings(after: ID, first: Int, whose: Condition): PrecedingSiblingConnection!

  """
  This is true if the node is selected.  Note that attempts to set this while the node is not visible (collapsed parent, etc.) will silently do nothing.
  """
  selected: Boolean!

  """The currently selected smart group identifier."""
  selectedSmartGroupIdentifier: String

  """The trees of this tree that are selected in the user interface."""
  selectedTrees(after: ID, first: Int, whose: Condition): SelectedTreeConnection!

  """
  The immediate child trees of this tree in the user-specified sort ordering.
  """
  trees(after: ID, first: Int, whose: Condition): TreeConnection!
}

"""A style object."""
type Style implements Node & StyleInterface {
  attributes(after: ID, first: Int, whose: Condition): AttributeConnection!

  """The name of the font of the style."""
  font: String!
  id: ID! @extractFromObjectDisplayName
  namedStyles(after: ID, first: Int, whose: Condition): NamedStyleConnection!
}

type StyleConnection implements Connection {
  byId(id: ID!): StyleInterface
  edges: [StyleEdge!]!
  pageInfo: PageInfo!
}

type StyleEdge implements Edge {
  cursor: String!
  node: StyleInterface!
}

interface StyleInterface implements Node {
  attributes(after: ID, first: Int, whose: Condition): AttributeConnection!

  """The name of the font of the style."""
  font: String!
  id: ID! @extractFromObjectDisplayName
  namedStyles(after: ID, first: Int, whose: Condition): NamedStyleConnection!
}

"""A tag."""
type Tag implements Node & TagInterface {
  """
  If false, tasks associated with this tag will be skipped when determining the next action for a project.
  """
  allowsNextAction: Boolean!

  """
  A count of the number of unblocked and incomplete tasks of this tag and all its active descendent tags.
  """
  availableTaskCount: Int!
  availableTasks(after: ID, first: Int, whose: Condition): AvailableTaskConnection!

  """The containing tag."""
  container: Tag!

  """Deprecated; use tags."""
  deprecatedContexts(after: ID, first: Int, whose: Condition): DeprecatedContextConnection!

  """
  Set if the tag is currently hidden or any of its container tags are hidden.
  """
  effectivelyHidden: Boolean!
  flattenedTags(after: ID, first: Int, whose: Condition): FlattenedTagConnection!

  """Set if the tag is currently hidden."""
  hidden: Boolean!

  """The identifier of the tag."""
  id: ID! @extractFromObjectDisplayName

  """The physical location associated with the tag."""
  location: LocationInformation

  """The name of the tag."""
  name: String!

  """The note of the tag."""
  note: RichText!

  """
  A count of the number of incomplete tasks of this tag and all its active descendent tags.
  """
  remainingTaskCount: Int!
  remainingTasks(after: ID, first: Int, whose: Condition): RemainingTaskConnection!

  """The tags having this tag as their container."""
  tags(after: ID, first: Int, whose: Condition): TagConnection!

  """The tasks having this tag."""
  tasks(after: ID, first: Int, whose: Condition): TaskConnection!
}

type TagConnection implements Connection {
  byId(id: ID!): TagInterface
  edges: [TagEdge!]!
  pageInfo: PageInfo!
}

type TagEdge implements Edge {
  cursor: String!
  node: TagInterface!
}

interface TagInterface implements Node {
  """
  If false, tasks associated with this tag will be skipped when determining the next action for a project.
  """
  allowsNextAction: Boolean!

  """
  A count of the number of unblocked and incomplete tasks of this tag and all its active descendent tags.
  """
  availableTaskCount: Int!
  availableTasks(after: ID, first: Int, whose: Condition): AvailableTaskConnection!

  """The containing tag."""
  container: Tag!

  """Deprecated; use tags."""
  deprecatedContexts(after: ID, first: Int, whose: Condition): DeprecatedContextConnection!

  """
  Set if the tag is currently hidden or any of its container tags are hidden.
  """
  effectivelyHidden: Boolean!
  flattenedTags(after: ID, first: Int, whose: Condition): FlattenedTagConnection!

  """Set if the tag is currently hidden."""
  hidden: Boolean!

  """The identifier of the tag."""
  id: ID! @extractFromObjectDisplayName

  """The physical location associated with the tag."""
  location: LocationInformation

  """The name of the tag."""
  name: String!

  """The note of the tag."""
  note: RichText!

  """
  A count of the number of incomplete tasks of this tag and all its active descendent tags.
  """
  remainingTaskCount: Int!
  remainingTasks(after: ID, first: Int, whose: Condition): RemainingTaskConnection!

  """The tags having this tag as their container."""
  tags(after: ID, first: Int, whose: Condition): TagConnection!

  """The tasks having this tag."""
  tasks(after: ID, first: Int, whose: Condition): TaskConnection!
}

"""
A task. This might represent the root of a project, an action within a project or other action or an inbox item.
"""
type Task implements Node & TaskInterface {
  """
  True if the task has a task that must be completed prior to it being actionable.
  """
  blocked: Boolean!

  """
  True if the task is completed. Use the "mark complete" and "mark incomplete" commands to change a task's status.
  """
  completed: Boolean!

  """If true, complete when children are completed."""
  completedByChildren: Boolean!

  """
  The task's date of completion. This can only be modified on a completed task to backdate the completion date.
  """
  completionDate: String

  """
  The task's project, up however many levels of parent tasks.  Inbox tasks aren't considered contained by their provisionalliy assigned container, so if the task is actually an inbox task, this will be missing value.
  """
  containingProject: Project

  """
  When the task was created.  This can only be set when the object is still in the inserted state.  For objects created in the document, it can be passed with the creation properties.  For objects in a quick entry tree, it can be set until the quick entry panel is saved.
  """
  creationDate: String!

  """When the task should become available for action."""
  deferDate: String

  """
  True if the task is dropped. Use the "mark dropped" and "mark incomplete" commands to change a task's status.
  """
  dropped: Boolean!

  """
  The date the task was dropped. This can only be modified on a dropped task to backdate the dropped date.
  """
  droppedDate: String

  """When the task must be finished."""
  dueDate: String

  """
  When the task should become available for action (including inherited).
  """
  effectiveDeferDate: String

  """When the task must be finished (including inherited)."""
  effectiveDueDate: String

  """
  True if the task is completed, or any of it's containing tasks or project are completed.
  """
  effectivelyCompleted: Boolean!

  """
  True if the task is dropped, or any of it's containing tasks or project are dropped.
  """
  effectivelyDropped: Boolean!

  """
  The estimated time, in whole minutes, that this task will take to finish.
  """
  estimatedMinutes: Int

  """True if flagged"""
  flagged: Boolean!
  flattenedTasks(after: ID, first: Int, whose: Condition): FlattenedTaskConnection!

  """The identifier of the task."""
  id: ID! @extractFromObjectDisplayName

  """
  Returns true if the task itself is an inbox task or if the task is contained by an inbox task.
  """
  inInbox: Boolean!

  """When the task was last modified."""
  modificationDate: String!

  """The name of the task."""
  name: String!

  """If the task is the next task of its containing project, next is true."""
  next: Boolean!

  """
  The next defer date if this task repeats on a fixed schedule and it has a defer date.
  """
  nextDeferDate: String

  """
  The next due date if this task repeats on a fixed schedule and it has a due date.
  """
  nextDueDate: String

  """The note of the task."""
  note: RichText!

  """The number of available direct children of this task."""
  numberOfAvailableTasks: Int!

  """The number of completed direct children of this task."""
  numberOfCompletedTasks: Int!

  """The number of direct children of this task."""
  numberOfTasks: Int!

  """
  The task holding this task.  If this is missing value, then this is a top level task -- either the root of a project or an inbox item.
  """
  parentTask: Task

  """
  The task's first tag. Setting this will remove the current first tag on the task, if any and move or add the new tag as the first tag on the task. Setting this to missing value will remove the current first tag and leave any other remaining tags.
  """
  primaryTag: Tag

  """
  The repetition interval of the task, or missing value if it does not repeat. This property is deprecated in favor of “repetition rule” and is here only for backwards compatibility with existing scripts.
  """
  repetition: RepetitionInterval

  """
  The repetition rule for this task, or missing value if it does not repeat.
  """
  repetitionRule: RepetitionRule

  """If true, any children are sequentially dependent."""
  sequential: Boolean!

  """
  When set, the due date and defer date properties will use floating time zones. (Note: if a Task has no due or defer dates assigned, this property will revert to the database’s default setting.)
  """
  shouldUseFloatingTimeZone: Boolean!

  """The tags assigned to this task."""
  tags(after: ID, first: Int, whose: Condition): TagConnection!

  """The tasks having this task as their container."""
  tasks(after: ID, first: Int, whose: Condition): TaskConnection!
}

type TaskConnection implements Connection {
  byId(id: ID!): TaskInterface
  edges: [TaskEdge!]!
  pageInfo: PageInfo!
}

type TaskEdge implements Edge {
  cursor: String!
  node: TaskInterface!
}

interface TaskInterface implements Node {
  """
  True if the task has a task that must be completed prior to it being actionable.
  """
  blocked: Boolean!

  """
  True if the task is completed. Use the "mark complete" and "mark incomplete" commands to change a task's status.
  """
  completed: Boolean!

  """If true, complete when children are completed."""
  completedByChildren: Boolean!

  """
  The task's date of completion. This can only be modified on a completed task to backdate the completion date.
  """
  completionDate: String

  """
  The task's project, up however many levels of parent tasks.  Inbox tasks aren't considered contained by their provisionalliy assigned container, so if the task is actually an inbox task, this will be missing value.
  """
  containingProject: Project

  """
  When the task was created.  This can only be set when the object is still in the inserted state.  For objects created in the document, it can be passed with the creation properties.  For objects in a quick entry tree, it can be set until the quick entry panel is saved.
  """
  creationDate: String!

  """When the task should become available for action."""
  deferDate: String

  """
  True if the task is dropped. Use the "mark dropped" and "mark incomplete" commands to change a task's status.
  """
  dropped: Boolean!

  """
  The date the task was dropped. This can only be modified on a dropped task to backdate the dropped date.
  """
  droppedDate: String

  """When the task must be finished."""
  dueDate: String

  """
  When the task should become available for action (including inherited).
  """
  effectiveDeferDate: String

  """When the task must be finished (including inherited)."""
  effectiveDueDate: String

  """
  True if the task is completed, or any of it's containing tasks or project are completed.
  """
  effectivelyCompleted: Boolean!

  """
  True if the task is dropped, or any of it's containing tasks or project are dropped.
  """
  effectivelyDropped: Boolean!

  """
  The estimated time, in whole minutes, that this task will take to finish.
  """
  estimatedMinutes: Int

  """True if flagged"""
  flagged: Boolean!
  flattenedTasks(after: ID, first: Int, whose: Condition): FlattenedTaskConnection!

  """The identifier of the task."""
  id: ID! @extractFromObjectDisplayName

  """
  Returns true if the task itself is an inbox task or if the task is contained by an inbox task.
  """
  inInbox: Boolean!

  """When the task was last modified."""
  modificationDate: String!

  """The name of the task."""
  name: String!

  """If the task is the next task of its containing project, next is true."""
  next: Boolean!

  """
  The next defer date if this task repeats on a fixed schedule and it has a defer date.
  """
  nextDeferDate: String

  """
  The next due date if this task repeats on a fixed schedule and it has a due date.
  """
  nextDueDate: String

  """The note of the task."""
  note: RichText!

  """The number of available direct children of this task."""
  numberOfAvailableTasks: Int!

  """The number of completed direct children of this task."""
  numberOfCompletedTasks: Int!

  """The number of direct children of this task."""
  numberOfTasks: Int!

  """
  The task holding this task.  If this is missing value, then this is a top level task -- either the root of a project or an inbox item.
  """
  parentTask: Task

  """
  The task's first tag. Setting this will remove the current first tag on the task, if any and move or add the new tag as the first tag on the task. Setting this to missing value will remove the current first tag and leave any other remaining tags.
  """
  primaryTag: Tag

  """
  The repetition interval of the task, or missing value if it does not repeat. This property is deprecated in favor of “repetition rule” and is here only for backwards compatibility with existing scripts.
  """
  repetition: RepetitionInterval

  """
  The repetition rule for this task, or missing value if it does not repeat.
  """
  repetitionRule: RepetitionRule

  """If true, any children are sequentially dependent."""
  sequential: Boolean!

  """
  When set, the due date and defer date properties will use floating time zones. (Note: if a Task has no due or defer dates assigned, this property will revert to the database’s default setting.)
  """
  shouldUseFloatingTimeZone: Boolean!

  """The tags assigned to this task."""
  tags(after: ID, first: Int, whose: Condition): TagConnection!

  """The tasks having this task as their container."""
  tasks(after: ID, first: Int, whose: Condition): TaskConnection!
}

"""A tree representing an object, along with its sub-trees."""
type Tree implements Node & TreeInterface {
  """The ancestor trees of this tree."""
  ancestorTrees(after: ID, first: Int, whose: Condition): AncestorTreeConnection!

  """
  All the descendant trees in the user-specified sort ordering, listing each tree, then its children and so forth.
  """
  descendantTrees(after: ID, first: Int, whose: Condition): DescendantTreeConnection!

  """This is true if the node is expanded."""
  expanded: Boolean!

  """
  The sibling trees of this tree after it in the user-specified sort ordering.
  """
  followingSiblings(after: ID, first: Int, whose: Condition): FollowingSiblingConnection!

  """The identifier of object being represented by this tree."""
  id: ID! @extractFromObjectDisplayName

  """The descendants of this tree that have no children themselves."""
  leafs(after: ID, first: Int, whose: Condition): LeafConnection!

  """The name of the object being represented by this tree."""
  name: String!

  """This is true if the node note is expanded."""
  noteExpanded: Boolean!

  """
  The sibling trees of this tree before it in the user-specified sort ordering.
  """
  precedingSiblings(after: ID, first: Int, whose: Condition): PrecedingSiblingConnection!

  """
  This is true if the node is selected.  Note that attempts to set this while the node is not visible (collapsed parent, etc.) will silently do nothing.
  """
  selected: Boolean!

  """The trees of this tree that are selected in the user interface."""
  selectedTrees(after: ID, first: Int, whose: Condition): SelectedTreeConnection!

  """
  The immediate child trees of this tree in the user-specified sort ordering.
  """
  trees(after: ID, first: Int, whose: Condition): TreeConnection!
}

type TreeConnection implements Connection {
  byId(id: ID!): TreeInterface
  edges: [TreeEdge!]!
  pageInfo: PageInfo!
}

type TreeEdge implements Edge {
  cursor: String!
  node: TreeInterface!
}

interface TreeInterface implements Node {
  """The ancestor trees of this tree."""
  ancestorTrees(after: ID, first: Int, whose: Condition): AncestorTreeConnection!

  """
  All the descendant trees in the user-specified sort ordering, listing each tree, then its children and so forth.
  """
  descendantTrees(after: ID, first: Int, whose: Condition): DescendantTreeConnection!

  """This is true if the node is expanded."""
  expanded: Boolean!

  """
  The sibling trees of this tree after it in the user-specified sort ordering.
  """
  followingSiblings(after: ID, first: Int, whose: Condition): FollowingSiblingConnection!

  """The identifier of object being represented by this tree."""
  id: ID! @extractFromObjectDisplayName

  """The descendants of this tree that have no children themselves."""
  leafs(after: ID, first: Int, whose: Condition): LeafConnection!

  """The name of the object being represented by this tree."""
  name: String!

  """This is true if the node note is expanded."""
  noteExpanded: Boolean!

  """
  The sibling trees of this tree before it in the user-specified sort ordering.
  """
  precedingSiblings(after: ID, first: Int, whose: Condition): PrecedingSiblingConnection!

  """
  This is true if the node is selected.  Note that attempts to set this while the node is not visible (collapsed parent, etc.) will silently do nothing.
  """
  selected: Boolean!

  """The trees of this tree that are selected in the user interface."""
  selectedTrees(after: ID, first: Int, whose: Condition): SelectedTreeConnection!

  """
  The immediate child trees of this tree in the user-specified sort ordering.
  """
  trees(after: ID, first: Int, whose: Condition): TreeConnection!
}

"""A window."""
type Window implements Node & WindowInterface {
  """Does the window have a close button?"""
  closeable: Boolean!

  """The document whose contents are displayed in the window."""
  document: Document!

  """The unique identifier of the window."""
  id: ID! @extractFromObjectDisplayName

  """The index of the window, ordered front to back."""
  index: Int!

  """Does the window have a minimize button?"""
  miniaturizable: Boolean!

  """Is the window minimized right now?"""
  miniaturized: Boolean!

  """The title of the window."""
  name: String!

  """Can the window be resized?"""
  resizable: Boolean!

  """Is the window visible right now?"""
  visible: Boolean!

  """Does the window have a zoom button?"""
  zoomable: Boolean!

  """Is the window zoomed right now?"""
  zoomed: Boolean!
}

type WindowConnection implements Connection {
  byId(id: ID!): WindowInterface
  edges: [WindowEdge!]!
  pageInfo: PageInfo!
}

type WindowEdge implements Edge {
  cursor: String!
  node: WindowInterface!
}

interface WindowInterface implements Node {
  """Does the window have a close button?"""
  closeable: Boolean!

  """The document whose contents are displayed in the window."""
  document: Document!

  """The unique identifier of the window."""
  id: ID! @extractFromObjectDisplayName

  """The index of the window, ordered front to back."""
  index: Int!

  """Does the window have a minimize button?"""
  miniaturizable: Boolean!

  """Is the window minimized right now?"""
  miniaturized: Boolean!

  """The title of the window."""
  name: String!

  """Can the window be resized?"""
  resizable: Boolean!

  """Is the window visible right now?"""
  visible: Boolean!

  """Does the window have a zoom button?"""
  zoomable: Boolean!

  """Is the window zoomed right now?"""
  zoomed: Boolean!
}

"""This subdivides the text into words."""
type Word implements Node {
  attachments(after: ID, first: Int, whose: Condition): AttachmentConnection!
  attributeRuns(after: ID, first: Int, whose: Condition): AttributeRunConnection!
  characters(after: ID, first: Int, whose: Condition): CharacterConnection!
  fileAttachments(after: ID, first: Int, whose: Condition): FileAttachmentConnection!

  """The name of the font of the first character."""
  font: String!
  id: ID! @extractFromObjectDisplayName
  paragraphs(after: ID, first: Int, whose: Condition): ParagraphConnection!

  """The size in points of the first character."""
  size: Int!

  """The style of the text."""
  style: Style!

  """The plain text contents of the rich text."""
  text: String!
  words(after: ID, first: Int, whose: Condition): WordConnection!
}

type WordConnection implements Connection {
  byId(id: ID!): Word
  edges: [WordEdge!]!
  pageInfo: PageInfo!
}

type WordEdge implements Edge {
  cursor: String!
  node: Word!
}

interface WordInterface implements Node {
  attachments(after: ID, first: Int, whose: Condition): AttachmentConnection!
  attributeRuns(after: ID, first: Int, whose: Condition): AttributeRunConnection!
  characters(after: ID, first: Int, whose: Condition): CharacterConnection!
  fileAttachments(after: ID, first: Int, whose: Condition): FileAttachmentConnection!

  """The name of the font of the first character."""
  font: String!
  id: ID! @extractFromObjectDisplayName
  paragraphs(after: ID, first: Int, whose: Condition): ParagraphConnection!

  """The size in points of the first character."""
  size: Int!

  """The style of the text."""
  style: Style!

  """The plain text contents of the rich text."""
  text: String!
  words(after: ID, first: Int, whose: Condition): WordConnection!
}
`;
